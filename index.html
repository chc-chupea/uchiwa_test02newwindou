<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Myうちわ - デコレーション</title>
  <!-- 推し活にぴったりなフォントを読み込み -->
  <link href="https://fonts.googleapis.com/css2?family=Cherry+Bomb+One&family=DotGothic16&family=Kaisei+Tokumin&family=Train+One&family=M+PLUS+Rounded+1c:wght@800&family=Kosugi+Maru&family=M+PLUS+1p:wght@800&family=Reggae+One&family=RocknRoll+One&family=Yomogi&family=Hachi+Maru+Pop&display=swap" rel="stylesheet">

  <style>
    /* 全体的なスタイル */
    body {
      font-family: 'Arial', sans-serif; /* 基本フォント設定 */
      text-align: center;
      background: linear-gradient(135deg, #f0f7ff, #eaf6ff); /* 背景グラデーション */
      margin: 0;
      padding: 10px;
      color: #333;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 20px;
      color: #1565c0;
    }
    .area {
      background: #fff; /* 白い背景のカード */
      border-radius: 20px; /* 角丸 */
      padding: 16px;
      margin-bottom: 16px; /* 間隔を少し詰める */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* 影 */
    }
    .divider {
      border: none;
      border-top: 1px solid #ccc; /* 薄いグレーの線 */
      margin: 12px 0;             /* 上下の余白を少しだけ */
    }
    .area h2 {
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 12px;
      color: #1565c0;
    }
    
    /* エディタ（キャンバス）のラッパー */
    #editorWrapper {
      position: relative;
      width: 100%;
      max-width: 900px; /* 最大幅 */
      /* 見た目比率を A3 に合わせる（実際の論理サイズは mainCanvas の width/height で決まる）*/
      aspect-ratio: 4961 / 3508; /* A3 比率（幅:x 高さ） */
      margin: 0 auto;
      background-color: #f9f9f9;


      overflow: hidden;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    /* メインキャンバスとオーバーレイキャンバス */
    #mainCanvas, #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none; /* タッチイベントのデフォルト動作を無効化 */
    }
    /* うちわテンプレート画像（低解像度版） */
    #templateOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* クリックイベントを透過 */
      object-fit: contain; /* アスペクト比を保ちつつ要素内に収める */
    }

    /* フォーム要素の共通スタイル */
    select, input[type="text"], input[type="color"], button, label {
      display: block;
      width: 100%;
      margin: 10px 0;
      padding: 12px;
      border-radius: 12px;
      font-size: 16px;
      border: 1px solid #ccc;
      background: #fff;
      box-sizing: border-box;
    }
    /* ボタンの共通スタイル */
    button {
      background: #4cafef;
      color: white;
      font-size: 16px;
      padding: 12px 24px;
      border-radius: 30px;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s, background 0.3s; /* ホバー時のアニメーション */
    }
    button:hover {
      background: #2196f3;
      transform: translateY(-2px);
    }
    /* ファイル選択ボタンのカスタムスタイル */
    #customFileLabel {
      background: linear-gradient(135deg, #4cafef, #2196f3);
      color: #fff;
      border-radius: 20px;
      padding: 8px 16px;   /* ← 太さを調整 */
      cursor: pointer;
      font-size: 16px;
      transition: 0.3s;
      display: inline-block;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
    }

    #customFileLabel:hover {
      background: linear-gradient(135deg, #42a5f5, #1e88e5);
      transform: scale(1.05);
    }
    /* フォームへ進むボタンのスタイル */
    .form-button {
      background: linear-gradient(135deg, #2196f3, #1976d2);
      color: white;
      padding: 12px 24px;
      margin-top: 20px;
      text-decoration: none;
      font-weight: bold;
      font-size: 18px;
      border-radius: 30px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      display: block;
      width: auto; /* コンテンツに合わせて幅を調整 */
      margin-left: auto;
      margin-right: auto;
    }
    .form-button:hover {
      background: linear-gradient(135deg, #1976d2, #0d47a1);
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
    }
    /* プレビュー画像のスタイル */
    #previewWrapper img {
      max-width: 100%;
      border: none;           /* ← 白い枠を削除 */
      border-radius: 0;       /* ← 角丸も不要なら 0 に */
      box-shadow: none;       /* ← 影も不要なら削除 */
      margin-top: 12px;
    }
    /* 選択中のオブジェクトの枠線 */
    .active-object-outline {
      outline: 2px dashed #42a5f5; /* 点線で表示 */
      outline-offset: 5px; /* 要素からのオフセット */
    }
    /* エディタの初期背景（うちわの形状）*/
    #editorWrapper::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url(fan1-lowres.png) no-repeat center center / contain; /* デフォルトうちわの形 */
      pointer-events: none;
      opacity: 0.5; /* 半透明 */
    }

    /* スタンプボタン専用スタイル */
    .stamp-buttons-container {
      display: flex;
      flex-wrap: wrap;
      gap: 5px; /* ボタン間の隙間を均一に */
      justify-content: center;
      margin-top: 8px; /* スタンプエリアの上マージンを調整 */
      margin-bottom: 8px; /* スタンプエリアの下マージンを調整 */
    }
    .stamp-buttons-container .stamp-button {
      width: auto; /* コンテンツに合わせて幅を調整 */
      min-width: 45px; /* 最低幅を確保し、タッチしやすくする */
      padding: 8px 12px; /* パディングを調整 */
      font-size: 24px; /* 絵文字のサイズを大きく */
      display: inline-flex; /* flexアイテムとして表示し、中央揃え */
      align-items: center;
      justify-content: center;
      height: 45px; /* ボタンの高さを固定 */
      margin: 0; /* flex containerでgapを指定するため、個別のmarginをリセット */
      box-shadow: 0 2px 4px rgba(0,0,0,0.15); /* 影を少し控えめに */
    }

    .stamp-buttons-container .stamp-button img {
        height: 30px; /* 画像スタンプのサイズを調整 */
        vertical-align: middle; /* 垂直方向中央揃え */
    }

    /* メンバーカラー用カラーピッカーの背景色 */
    #backgroundColorPicker {
        background-color: #ffe6f2; /* 薄いピンク色 */
    }

    /* 自由テキスト用カラーピッカーの背景色 */
    #colorPicker {
        background-color: #ffe6f2; /* 薄いピンク色 */
    }

    /* 編集ツールボタンのレイアウト調整 */
    .edit-tools-container {
      display: flex;
      flex-wrap: wrap;
      gap: 3px; /* ボタン間の隙間をさらに詰める */
      justify-content: center;
      margin-top: 8px; /* 編集ツールエリアの上マージンを維持 */
    }
    .edit-tools-container button {
        flex: 0 0 auto; /* 固定幅にせず、内容に合わせて伸縮 */
        padding: 6px 10px; /* パディングをさらに小さく */
        font-size: 13px; /* フォントサイズをさらに小さく */
        margin: 0; /* flex containerでgapを指定するため、個別のmarginをリセット */
        min-width: 60px; /* 最低幅を調整 */
    }

    /* 自由テキスト入力エリア内の要素の間隔調整 */
    #customText {
      margin-bottom: 8px; /* 自由テキスト入力の下マージン */
      padding: 10px; /* パディングも少し小さく */
    }
    #area-decorations > h3:nth-of-type(1) + input[type="text"] + div { /* 自由テキストのカラーピッカーとフォントピッカーを含むdiv */
      margin-top: 8px;
      margin-bottom: 8px;
    }
    #area-decorations button[onclick="addTextToOverlay()"] {
      margin-top: 8px; /* テキスト追加ボタンの上マージン */
      margin-bottom: 16px; /* 次のセクションへのマージン */
    }


    /* ====== ここから追加：#area-decorations の「白い帯」を消す（ツールは fixed のまま維持） ====== */
    #area-decorations {
      background: transparent !important;
      box-shadow: none !important;
      border-radius: 0 !important;
      padding: 0 !important;
      margin-bottom: 0 !important;
    }
    /* ====== ここまで追加 ====== */

    /* うちわのデザイン選択ラベルから縁の線をなくす */
    #templateLabel {
        border: none;
        outline: none;
    }

    /* --- フォント選択ボタン用の見た目 --- */
    .font-picker-wrap { position: relative; flex: 1; }

    #fontPickerBtn {
      width: 100%;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 12px;
      background: #fff;
      font-size: 16px;
      cursor: pointer;
      text-align: left;
      color: #000;  /* ← これを追加 */
    }

    /* --- 追加: テキストツール横並び（修正版 v3） --- */
    #panel-text .text-tools-row {
      display:flex;
      gap:8px;
      align-items:flex-end;  /* 👈 下端そろえに変更 */
      width:100%;
      box-sizing:border-box;
      height:44px; /* 3つともこの高さに統一 */
    }

    /* --- 縁取りコントロール 2段レイアウト --- */
    #outlineControls {
      display: flex;
      flex-direction: column; /* 👈 縦に2段並べる */
      align-items: flex-start; /* 左寄せ */
      gap: 6px;               /* 行間を少し詰める */
      margin-bottom: 8px;
    }

    #outlineControls .row-top {
      display: flex;
      align-items: center;
      gap: 12px;  /* 「ON/OFF」と「色」の間隔 */
    }
    
    #outlineControls .row-top label {
      display: flex;
      align-items: center;
      white-space: nowrap;   /* 👈 テキストの折返し禁止 */
      min-width: 140px;      /* 👈 横幅を確保して1行に収める */
    }
 
    #outlineControls label {
      display: flex;
      align-items: center;
      font-size: 14px;
      margin: 0;
    }

    #outlineControls input[type="color"] {
      flex-shrink: 0;        /* 👈 狭い画面でも縮まない */
      width: 30px;           /* 👈 横幅を少し広めに */
      height: 20px;          /* 👈 チェックボックスと同じぐらいの高さに揃える */
      margin-left: 6px;
      padding: 0;
      border-radius: 4px;
      box-sizing: border-box;
    }

    #outlineControls input[type="range"] {
      margin: 0 6px;
    }

    /* ====== 追加：縁取りコントロールの高さを左右で揃える ====== */
    #outlineControls .row-top {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* ラベル自体を「ボックスに見える横並び要素」にして高さを固定 */
    #outlineControls .row-top label {
      display: inline-flex;        /* 横並びで中身を中央揃えにする */
      align-items: center;
      gap: 8px;                    /* テキストと input の間隔 */
      padding: 8px 12px;           /* 上下の余白を小さめに固定（高さ揃えの肝） */
      height: 44px;                /* 好みの高さに調整（40〜48pxが目安） */
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid #ccc;
      background: #fff;
      font-size: 14px;
      margin: 0;                   /* グローバル label の余白を上書き */
      white-space: nowrap;         /* テキスト折返しを防止 */
    }

    /* チェックボックスをラベル内で適正な大きさに */
    #outlineControls .row-top label input[type="checkbox"] {
      width: 20px;
      height: 20px;
      margin: 0;      /* label の gap で間隔を取るので余計な margin は消す */
      flex-shrink: 0; /* 縮まらないようにする */
    }

    /* カラーピッカーもラベル高さに合わせる */
    #outlineControls .row-top label input[type="color"] {
      width: 28px;
      height: 28px;
      padding: 0;
      border-radius: 6px;
      border: 1px solid #ddd;
      flex-shrink: 0;
    }

    /* 小さい画面では少し小さくする（必要に応じて調整） */
    @media (max-width: 420px) {
      #outlineControls .row-top label {
        height: 40px;
        padding: 6px 10px;
        font-size: 13px;
      }

      #outlineControls .row-top label input[type="color"] {
        width: 26px;
        height: 26px;
      }
    }

    /* 左：カラー（正方形） */
    #panel-text .text-tools-row input[type="color"] {
      width:44px !important;
      height:44px !important;
      flex:0 0 44px;
      padding:2px;
      border-radius:8px;
      box-sizing:border-box;
      margin:0; /* 👈 余計な隙間を消す */
    }

    /* 中央：フォントを選ぶ（残り幅の約1.2倍を確保） */
    #panel-text .text-tools-row #fontPickerBtn,
    #panel-text .text-tools-row .font-icon-btn {
      flex:1.2 1 0;
      height:44px !important;
      min-width:0;
      padding:0 10px !important;
      border-radius:8px !important;
      font-size:15px;
      display:flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
    }

    /* 右：文字をうちわに配置（幅を広げて文字数に対応） */
    #panel-text .text-tools-row .add-text-btn,
    #panel-text .text-tools-row button[onclick^="addTextToOverlay"] {
      flex:1.5 1 0;  /* フォントボタンより少し広め */
      height:44px !important;
      min-width:0;
      padding:0 12px !important;
      border-radius:8px !important;
      box-sizing:border-box;
      font-size:14px;  /* 文字数が多いので少し小さめに */
      white-space:nowrap; /* 折り返さず1行に収める */
    }

    /* 小さい画面向け微調整（iPhone 14 等） */
    @media (max-width:420px) {
      #panel-text .text-tools-row { gap:6px; }
      #panel-text .text-tools-row #fontPickerBtn { font-size:13px; }
      #panel-text .text-tools-row .add-text-btn { font-size:13px; }
    }


    #fontDropdown {
      position: absolute;
      z-index: 9999;
      left: 0;
      right: 0;
      top: calc(100% + 6px);
      border: 1px solid #ddd;
      border-radius: 12px;
      background: #fff;
      box-shadow: 0 8px 20px rgba(0,0,0,0.08);
      max-height: 260px;
      overflow: auto;
      padding: 6px;
    }

    .font-option {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #f0f0f0;
      margin-bottom: 6px;
      cursor: pointer;
    }

    .font-option:hover { background: #f7fbff; }

    .font-sample { font-size: 20px; line-height: 1.2; }
    .font-name   { font-size: 12px; color: #666; margin-top: 2px; }

    .native-font-select {
      position: absolute !important;
      left: -9999px !important; /* 画面からよける（フォーム値は残す） */
    }

    /* === CapCut風：横スクロールツールバー === */
    .cc-toolbar {
      display: flex;
      gap: 12px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding: 8px 6px;
      margin: 8px -6px 10px;   /* 端まで広くドラッグできるように少しはみ出させる */
      border-top: 1px solid #eee;
      border-bottom: 1px solid #eee;
      scroll-snap-type: x proximity;
    }
    .cc-toolbar::-webkit-scrollbar { display: none; } /* スクロールバーを隠す（スマホ向け） */

    .cc-item {
      flex: 0 0 auto;          /* 横に並ぶ（折り返さない） */
      width: 84px;             /* 指で押しやすい幅 */
      scroll-snap-align: center;
      border: 1px solid #ddd;
      border-radius: 14px;
      background: #fff;
      padding: 8px 6px;
      text-align: center;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,.06);
    }
    .cc-item .icon { font-size: 20px; display: block; line-height: 1.2; }
    .cc-item .label { font-size: 12px; color: #333; display: block; margin-top: 4px; }

    .cc-item.active {
      background: linear-gradient(135deg, #e3f2fd, #ffffff);
      border-color: #90caf9;
      box-shadow: 0 3px 10px rgba(33,150,243,.15);
    }

    /* パネル（ツールの中身） */
    .cc-panels { margin-top: 8px; }
    .cc-panel[hidden] { display: none; }

    /* 既存のボタン群がぎゅうぎゅうにならないように少し調整 */
    .cc-panel button { margin: 4px 2px; }
    /* -------- 小型「決定」アイコンのスタイル -------- */
    .generate-icon {
      /* 基本の見た目 */
      width: 56px;
      min-width: 56px;
      height: 44px;
      padding: 6px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 2px;
      background: linear-gradient(135deg,#4cafef,#1976d2);
      color: white;
      border: none;
      box-shadow: 0 4px 10px rgba(33,150,243,0.18);
      font-size: 12px;
    }
    .generate-icon .icon { font-size: 18px; line-height: 1; }
    .generate-icon .label { font-size: 10px; opacity: 0.95; }

    /* 押下フィードバック */
    .generate-icon.pressed {
      transform: translateY(2px) scale(0.98);
      box-shadow: 0 2px 6px rgba(33,150,243,0.12) !important;
      transition: transform .08s, box-shadow .08s;
    }

    /* モバイル時：既存の大きなボタンを隠し、小アイコンは表示する */
    @media (max-width: 1024px) {
      #generateBtn {
        display: none !important;
      }
      /* ラベルを小さくしてボタン内で見映えを調整（必要なら非表示も可） */
      .generate-icon .label { display: none; } /* ラベルを消したければこの行をそのまま */
    }

    /* PC/スマホ共通で隠したいものを明示 */
    #generateBtn,
    #generateIconBtn {
      display: none !important;
    }

    /* area-result は初期非表示に任せるので CSS で強制しない */

    /* デスクトップでは小アイコンを補助的に表示（必要なら非表示に） */
    @media (min-width: 1025px) {
      /* 任意：PCで小アイコンを非表示にしたければ以下をアンコメント */
      /* #generateIconBtn { display: none; } */
    }
    /* ツールバー内で generate-icon を右端に寄せる（flex の空間を利用） */
    .cc-toolbar .generate-icon {
      margin-left: auto; /* これで行の最後に寄ります */
    }


    /* === 画面下固定（CapCut風） === */
    /* ツールバー本体を下固定 */
    .cc-toolbar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: env(safe-area-inset-bottom, 0);
      z-index: 1000;
      margin: 0;                 /* 既存の margin を打ち消す */
      border-top: 1px solid #eee;
      border-bottom: 0;
      background: #fff;
      padding: 8px 6px;
      display: flex;
      gap: 12px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: x proximity;
    }
    .cc-toolbar::-webkit-scrollbar { display: none; }

    /* パネル（ツールの中身）も下固定：ツールバーの“すぐ上”に出す */
    .cc-panels {
      position: fixed;
      left: 0;
      right: 0;
      /* ツールバー高さ（約64px） + セーフエリアぶんだけ持ち上げる */
      bottom: calc(64px + env(safe-area-inset-bottom, 0));
      z-index: 999;
      max-height: 42vh;          /* 片手操作で見切れない程度 */
      overflow-y: auto;
      margin: 0;                 /* 既存の margin を打ち消す */
      padding: 8px 10px 12px;
      background: #fff;
      box-shadow: 0 -4px 12px rgba(0,0,0,.08);
      border-top: 1px solid #eee;
    }
    .cc-panel[hidden] { display: none; }

    /* キャンバスが下固定UIに隠れないようボディ下に余白をつける */
    body {
      padding-bottom: calc(220px + env(safe-area-inset-bottom, 0));
    }


    /* === 初回ガイドモーダル用 === */
    .guide-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .guide-content {
      background: #fff;
      color: #333;
      max-width: 320px;
      width: 90%;
      border-radius: 20px;
      padding: 24px;
      text-align: left;
      box-shadow: 0 6px 20px rgba(0,0,0,0.25);
    }
    .guide-content h2 {
      margin-top: 0;
      font-size: 20px;
      text-align: center;
      color: #1565c0;
    }
    .guide-content ol {
      margin: 12px 0 20px;
      padding-left: 20px;
      font-size: 16px;
    }

    /* === アーチ文字設定：常に横並び === */
    #archControls {
      display: flex;
      align-items: center;  /* 高さを揃える */
      gap: 16px;            /* 各枠の間隔 */
      flex-wrap: nowrap;    /* 常に１行に収める */
    }

    #archControls > label,
    #archControls > div {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  </style>
</head>
<body>

  <h1 id="title">Myうちわ</h1>

  <div class="area" id="area-select">
    <h2 id="section1-title">1) 背景を決める</h2>
    <label id="templateLabel">うちわのサイズ・型を選んでね👇</label>
    <select id="templateSelector">
      <option value="fan1-highres.png" data-lowres="fan1-lowres.png">A4サイズレギュラー型</option>
      <option value="fan2-highres.png" data-lowres="fan2-lowres.png">A3サイズ♡型</option>
      <option value="fan3-highres.png" data-lowres="fan3-lowres.png">A3サイズ大型</option>
    </select>
    <label for="imageLoader" id="customFileLabel">写真で背景を作る</label>
    <input type="file" id="imageLoader" accept="image/*" style="display:none;" />
    <p id="reuploadNotice" style="font-size: 12px; color: #666;">※ 画像は何度でも選び直せます。</p>
    <hr class="divider">
    <h3 style="margin-top: 20px;">メンバーカラーで背景を作る</h3>
    <input type="color" id="backgroundColorPicker" value="#ff8fff" title="背景色選択" />
  </div>

  <div class="area" id="area-canvas">
    <h2 id="section2-title">2) デザイン編集スペース</h2>
    <div id="editorWrapper">
      <!-- 編集は軽量キャンバス（例：1240x877）で行う -->
      <canvas id="mainCanvas" width="1240" height="877"></canvas>
      <img id="templateOverlay" src="fan1-lowres.png" alt="うちわテンプレート">
    </div>
    <p id="editNotice" style="font-size: 12px; color: #666; margin-top: 10px;">
      ※ 画像は1本の指で位置を動かせます。2本の指で大きさや向きを変えることができます。
    </p>
    <button id="confirmPhotoBtn" style="margin-top: 10px;">写真の配置を確定</button>
    <button id="reEditPhotoBtn" style="margin-top: 10px; display: none;">写真の配置をやり直す</button>
    <!-- 追加：配置完了後の分岐コントロール（保存→プレビュー / 編集） -->
    <div id="arrangeControls" style="display:none; position: fixed; bottom: calc(78px + env(safe-area-inset-bottom, 0)); left: 50%; transform: translateX(-50%); z-index: 1100; gap:8px;">
      <button id="toPreviewBtn" class="form-button"
        style="padding:6px 16px; margin-right:8px;
               min-width:150px;
               border:none; background:#1976d2; color:#fff;
               border-radius:16px; font-weight:bold;
               font-size:14px;
               box-shadow:0 2px 4px rgba(0,0,0,0.2);
               cursor:pointer;">
        決定 → プレビュー
      </button>

      <button id="toEditBtn" class="form-button"
        style="padding:6px 16px;
               min-width:150px;
               border:1px solid #1976d2;
               background:#fff; color:#1976d2;
               border-radius:16px; font-weight:bold;
               font-size:14px;
               box-shadow:0 2px 4px rgba(0,0,0,0.2);
               cursor:pointer;">
        デコレーション
      </button>
    </div>
  </div>

  <div class="area" id="area-decorations" style="display: none;">
    <h2 id="section3-title">3) デコレーション</h2>
    <style>
      @media (max-width: 768px) {
        #section3-title { display: none; }
      }
    </style>
    <!-- <p id="decorationNotice" style="font-size: 12px; color: #666;">
      ※ オブジェクトをタップすると選択され、移動・サイズ変更・回転できます。
    </p> -->

    <!-- ▼▼ ここから “横スライド メニュー” を追加 ▼▼ -->
    <div class="cc-toolbar" role="tablist">
      <button class="cc-item active" data-target="panel-text">
        <!-- <span class="icon">T</span> --><span class="label">テキスト</span>
      </button>
      <button class="cc-item" data-target="panel-stamp">
        <!-- <span class="icon">🌟</span> --><span class="label">スタンプ</span>
      </button>
      <button class="cc-item" data-target="panel-arrange">
        <!-- <span class="icon">📋</span> --><span class="label">複製／削除</span>
      </button>
      <button class="cc-item" data-target="panel-history">
        <!-- <span class="icon">↩ ↪</span> --><span class="label">↩ ↪</span>
      </button>
      <button class="cc-item" data-target="panel-layer">
        <!-- <span class="icon">⬆︎⬇︎</span> --><span class="label">レイヤー</span>
      </button>
      <!-- 追加：ツールバー右端の小さな「決定」ボタン（モバイル向け） -->
      <button class="cc-item generate-icon" id="generateIconBtn" title="決定・プレビュー">
         <span class=""label"">決定→プレビュー</span>
      </button>


    </div>

    <div class="cc-panels">
      <!-- テキスト -->
      <section id="panel-text" class="cc-panel">
                <input type="text" id="customText" placeholder="推しへのメッセージ♡" />
        <!-- ====== ここを丸ごと置き換えます（開始） ====== -->
        <div class="text-tools-row" style="display:flex; gap:8px; align-items:center; margin-bottom:10px;" id="textToolsRow">
          <!-- 小さなカラーピッカー（サイズはCSSで統一） -->
          <input type="color" id="colorPicker" value="#ff69b4" title="文字色選択" />

          <!-- フォント選択と追加ボタンを同じ行に並べるラッパー -->
          <div class="font-picker-wrap" style="display:flex; gap:8px; align-items:center;">
            <!-- 小さなアイコン風フォントボタン（表示は "Aa"） -->
            <button id="fontPickerBtn" type="button" class="font-icon-btn" aria-label="フォントを選ぶ">Aa</button>

            <!-- 大きく横に広がる「テキスト追加」ボタン（既存の addText 関数を利用） -->
            <button class="add-text-btn" onclick="addTextToOverlay()">文字をうちわへ配置</button>

            <!-- ドロップダウンはここに置く（表示/非表示は既存のJSで制御） -->
            <div id="fontDropdown" hidden></div>
          </div>

          <!-- hidden の native select（値保持のためそのまま DOM に残す） -->
          <select id="fontPicker" class="native-font-select">
            <option value="Arial, sans-serif">Arial</option>
            <option value="'DotGothic16', sans-serif">ドットゴシック</option>
            <option value="'Train One', cursive">Train One</option>
            <option value="'Cherry Bomb One', cursive">手書き風</option>
            <option value="'Kaisei Tokumin', serif">丸文字</option>
            <option value="'M PLUS Rounded 1c', sans-serif">M PLUS Rounded 太字</option>
            <option value="'M PLUS 1p', sans-serif">M PLUS 1p 太字</option>
            <option value="'Kosugi Maru', sans-serif">Kosugi Maru</option>
            <option value="'Reggae One', cursive">Reggae One</option>
            <option value="'RocknRoll One', sans-serif">RocknRoll One</option>
            <option value="'Yomogi', cursive">Yomogi</option>
            <option value="'Hachi Maru Pop', cursive">Hachi Maru Pop</option>
          </select>
        </div>
        <!-- ====== ここを丸ごと置き換えます（終了） ====== -->

        <!-- ▼ 縁取り設定（ここから追加） -->
          <div id="outlineControls" class="control-row">
            <div class="row-top">
              <label>
                <input type="checkbox" id="outlineToggle" checked>
                縁取りON/OFF
              </label>

              <label>
                外側の縁の色：
                <input type="color" id="outlineColorPicker" value="#ffffff" title="縁取り色" />
              </label>
            </div>

            <label>
              外側の縁の太さ：
              <input type="range" id="outlineWidthPercent" min="0" max="30" value="12" step="1">
              <span id="outlineWidthValue">12%</span>
            </label>
          </div>
          <!-- ▲ 縁取り設定（ここまで追加） -->

          <!-- ▼ アーチ文字設定（ここから追加） -->
          <div id="archControls" class="control-row" style="margin:10px 0 14px;">
            <label>
              <input type="checkbox" id="archToggle">
              アーチ文字にする
            </label>

            <div>              
              <label>
                <input type="radio" name="archStyle" value="rainbow" checked> 虹型（∩）
              </label>
              <label>
                <input type="radio" name="archStyle" value="smile"> スマイル型（∪）
              </label>
            </div>
          </div>

            <div style="margin-top:8px;">
              <span style="min-width:6em; display:inline-block;">カーブ：</span>
              <input type="range" id="archAmount" min="0" max="100" value="50" step="1">
              <span id="archAmountValue">50</span>
            </div>
          </div>
          <!-- ▲ アーチ文字設定（ここまで追加） -->


      </section>

      <!-- スタンプ -->
      <section id="panel-stamp" class="cc-panel" hidden>
        <h3 style="margin:6px 0 8px;">スタンプ</h3>
        <div class="stamp-buttons-container">
          <button class="stamp-button" onclick="addStamp('❤️')">❤️</button>
          <button class="stamp-button" onclick="addStamp('⭐')">⭐</button>
          <button class="stamp-button" onclick="addStamp('🎶')">🎶</button>
          <button class="stamp-button" onclick="addStamp('01loveu.png')"><img src="01loveu.png" alt="Love You"></button>
          <button class="stamp-button" onclick="addStamp('02ntwithFace.png')"><img src="02ntwithFace.png" alt="NT with Face"></button>
          <button class="stamp-button" onclick="addStamp('03eyestome.png')"><img src="03eyestome.png" alt="Eyes to me"></button>
          <button class="stamp-button" onclick="addStamp('04getmyheart.png')"><img src="04getmyheart.png" alt="Get my heart"></button>
          <button class="stamp-button" onclick="addStamp('05angel.png')"><img src="05angel.png" alt="Angel"></button>
          <button class="stamp-button" onclick="addStamp('06god.png')"><img src="06god.png" alt="God"></button>
          <button class="stamp-button" onclick="addStamp('07precious.png')"><img src="07precious.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('08osi_pink.png')"><img src="08osi_pink.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('09osi_yellow.png')"><img src="09osi_yellow.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('10osi_lightblue.png')"><img src="10osi_lightblue.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('11osi_green.png')"><img src="11osi_green.png" alt="Precious"></button>
        </div>
      </section>

      <!-- 並べ替え（複製・削除） -->
      <section id="panel-arrange" class="cc-panel" hidden>
        <button id="duplicateBtn">複製</button>
        <button id="deleteBtn" style="background:#f44336;">削除</button>
      </section>

      <!-- 履歴（戻る・やり直し） -->
      <section id="panel-history" class="cc-panel" hidden>
        <button id="undoBtn">戻る</button>
        <button id="redoBtn">やり直し</button>
      </section>

      <!-- レイヤー（前面/背面） -->
      <section id="panel-layer" class="cc-panel" hidden>
        <button id="sendBackwardBtn">背面へ</button>
        <button id="bringForwardBtn">前面へ</button>
      </section>
    </div>
    <!-- ▲▲ ここまで “横スライド メニュー” ▲▲ -->

    <!-- 「決定 → プレビュー」ボタンをデコレーションエリア内に移動 -->
    <button id="generateBtn" class="form-button" style="margin-top: 20px;">決定 → プレビュー</button>
    <!-- ここから追加：編集モードの右上ボタン（初期は非表示） -->
    <button id="previewBtnTopRight" class="form-button"
            style="position:fixed; top:12px; right:12px; z-index:1201; display:none;
                   padding:8px 12px; border-radius:20px; box-shadow:0 6px 12px rgba(0,0,0,0.15);">
      決定 → プレビュー
    </button>
<!-- ここまで追加 -->

    
  </div>

  <div class="area" id="area-result" style="display: none;">
    <h2 id="section4-title">4) 裏面を作る or 注文</h2>
    <div id="previewWrapper">
      <img id="previewImage" alt="" style="display:none;" />
    </div>
    <div id="previewNotice" style="font-size:14px; color:black; margin-top:10px;"></div>

    <!-- ここから追加 -->
    <div id="previewSpinner" style="display:none; margin-top:10px; font-size:14px; align-items:center;">
      <span style="display:inline-block; width:18px; height:18px; border-radius:50%; margin-right:8px; vertical-align:middle; animation:spin 1s linear infinite; background:linear-gradient(135deg,#ff9fcf,#ff6fa6);"></span>
      画像を合成しています…（少しお待ちください）
    </div>

    <style>
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    /* 小さなスタイル：必要なら後でCSSファイルへ移動してください */
    /* ← ここに追加する（次の行を貼る） */
    #previewContainer { display: none !important; }
    </style>
    <!-- ここまで追加 -->

    <!-- ここから追加 -->
    <button id="makeBackBtn" class="form-button" style="display:none; margin-top:12px; background: linear-gradient(135deg, #ff9fcf, #ff6fa6);">
      🔁 裏面も作る
    </button>

    <div id="orderNote" style="font-size:12px; color:#555; margin-top:8px; display:none;">
      ※ 表と裏の画像を２枚アップロードして送信してください
    </div>
    <!-- ここまで追加 -->


    <!-- 「注文フォームへ進む」ボタンはここに残し、JavaScriptで表示制御 -->
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSf1wV724Vnag4FCcjeU1z-3vaCcfhCjAvGyU8432bu8dyciow/viewform?usp=dialog"
       target="_blank"
       class="form-button"
       id="goToOrderFormBtn"
       style="display: none;">📝 注文フォームへ進む</a>
  </div>
  <!-- ここから追加：プレビューオーバーレイ（長押しで保存を想定） -->
  <div id="previewScreen" style="display:none; position:fixed; inset:0; z-index:1300;
                                background:rgba(0,0,0,0.75); align-items:center; justify-content:center;">
    <div style="position:relative; max-width:95%; max-height:95%; margin:auto; display:flex; flex-direction:column; align-items:center;">


      <div style="background:#fff; padding:6px; border-radius:12px; overflow:auto; max-height:88vh;">
        <img id="previewFullImage" alt="合成プレビュー（長押しで保存）" 
             style="display:block; max-width:100%; height:auto; -webkit-user-select:none; user-select:none; touch-action:manipulation;">
      </div>

      <div style="color:#fff; font-size:14px; text-align:center; margin-top:8px;">
        画像を＜長押し👆＞して「画像を保存」してください
      </div>
      <!-- 長押し保存の説明の下に閉じるボタン配置 -->
      <button id="previewCloseBtn"
              style="margin-top:12px; padding:6px 18px; border:none;
                     background:#fff; border-radius:20px; font-weight:600;
                     box-shadow:0 3px 8px rgba(0,0,0,0.2);
                     color:black; display:inline-block; width:auto;">
        閉じる
      </button>
    </div>
  </div>
  <!-- ここまで追加 -->

  <footer style="font-size: 6px; color: #888; margin-top: 20px;">
    © 2025 Chugoku Shimbun Hanbai Center. Web application developed by Hitomi Sasaki. All rights reserved.<br />
    このウェブアプリケーションは、株式会社中国新聞販売センターの従業員による地域イベント向けの自主開発プロジェクトです。<br />
    ※本アプリは公式サービスではありませんが、業務との親和性を考慮して使用されています。
  </footer>

  <!-- Hammer.jsを読み込み：タッチジェスチャーをよりスムーズにするため -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script>

    let backSideCreated = false;


    // ← ここに追加！
      window.addEventListener('DOMContentLoaded', () => {
        // 初期値をピンクに統一
        colorPicker.value = "#ff69b4";
        outlineColorPicker.value = "#ffc9d2";

        // 見た目（背景色）も更新
        colorPicker.style.backgroundColor = "#ff69b4";
        outlineColorPicker.style.backgroundColor = "#ffc9d2";

        // ★ 初回ガイドモーダル表示（ここから追加）
        const guide = document.getElementById('firstGuide');
        const closeBtn = document.getElementById('guideCloseBtn');
        if (!localStorage.getItem('myUchiwaGuideSeen')) {
          guide.style.display = 'flex';
        }
        closeBtn.addEventListener('click', () => {
          guide.style.display = 'none';
          localStorage.setItem('myUchiwaGuideSeen', 'true');
        });
        // ★ ここまで追加
      });

    // DOM要素の取得
    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d');
    const templateOverlay = document.getElementById('templateOverlay');
    const imageLoader = document.getElementById('imageLoader');
    const templateSelector = document.getElementById('templateSelector');




    // --- ここから追加 ---
    const templateCache = {}; // src -> Image

    function preloadTemplate(src) {
      if (!src) return;
      if (templateCache[src]) return templateCache[src];
      const img = new Image();
      img.src = src;
      templateCache[src] = img;
      // decode が使えれば非同期にデコードを促す（エラーは無視）
      if (img.decode) img.decode().catch(() => {});
      return img;
    }

    // 選択が変わったらプリロード
    templateSelector.addEventListener('change', () => {
      preloadTemplate(templateSelector.value);
    });

    // ページ読み込み時に現在のテンプレートをプリロード（あれば）
    preloadTemplate(templateSelector.value);
    // --- ここまで追加 ---

    const confirmPhotoBtn = document.getElementById('confirmPhotoBtn');
    const reEditPhotoBtn = document.getElementById('reEditPhotoBtn');
    const generateBtn = document.getElementById('generateBtn');
    const goToOrderFormBtn = document.getElementById('goToOrderFormBtn');
    const customText = document.getElementById('customText');
    const colorPicker = document.getElementById('colorPicker');

    // --- 縁取りコントロールを参照する ---
    const outlineToggle = document.getElementById('outlineToggle');
    const outlineColorPicker = document.getElementById('outlineColorPicker');
    const outlineWidthPercent = document.getElementById('outlineWidthPercent');
    const outlineWidthValue = document.getElementById('outlineWidthValue');

    // --- アーチ文字コントロールを参照する ---
    const archToggle = document.getElementById('archToggle');
    const archStyleRadios = document.querySelectorAll('input[name="archStyle"]');
    const archAmount = document.getElementById('archAmount');
    const archAmountValue = document.getElementById('archAmountValue');



    // スライダーの数字を表示に反映
    outlineWidthPercent.addEventListener('input', () => {
      outlineWidthValue.textContent = outlineWidthPercent.value + '%';
    });
    const fontPicker = document.getElementById('fontPicker');

    const fontPickerBtn = document.getElementById('fontPickerBtn');
    const fontDropdown  = document.getElementById('fontDropdown');


    // === CapCut風ツールバーの表示切替 ===
    const ccToolbar = document.querySelector('.cc-toolbar');
    const ccItems   = document.querySelectorAll('.cc-item');
    const ccPanels  = document.querySelectorAll('.cc-panel');

    function showPanel(id) {
      // パネルの表示/非表示
      ccPanels.forEach(p => p.hidden = (p.id !== id));
      // アクティブ表示
      ccItems.forEach(b => b.classList.toggle('active', b.dataset.target === id));
      // 押したボタンを中央へ寄せる（横スクロールがスッと動く）
      const btn = document.querySelector(`.cc-item[data-target="${id}"]`);
      if (btn) btn.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
    }
    
    // 追加：すべての詳細パネルを閉じ、アクティブ表示もリセット
    function hidePanels() {
      ccPanels.forEach(p => p.hidden = true);
      ccItems.forEach(b => b.classList.remove('active'));
    }

    ccToolbar.addEventListener('click', (e) => {
      const btn = e.target.closest('.cc-item');
      if (!btn) return;
      showPanel(btn.dataset.target);
    });

    // 追加：ツールバー右端の小さな「決定」アイコンのクリックでプレビュー生成を呼ぶ
    (function() {
      const generateIconBtn = document.getElementById('generateIconBtn');
      // 無しでもエラーにならないよう existence check
      if (!generateIconBtn) return;

      generateIconBtn.addEventListener('click', (ev) => {
        ev.preventDefault();

        // 簡単な押下アニメーション（短く見せる）
        generateIconBtn.classList.add('pressed');
        setTimeout(() => generateIconBtn.classList.remove('pressed'), 120);

        // 既存の大ボタンがあるなら click を発火させて既存ロジックを再利用
        if (typeof generateBtn !== 'undefined' && generateBtn) {
          generateBtn.click();
          return;
        }

        // 万一 generateBtn が見つからない（将来の差し替えで消えた等）は
        // ここで直接プレビュー生成関数を呼び出すロジックを入れることもできます。
        console.warn('generateBtn not found — generateIconBtn clicked');
      });
    })();

    // 初期表示は何も開かない（選択時に自動オープン）
    hidePanels()





    // この配列の順序／内容は <select id="fontPicker"> と揃えています
    const FONT_CANDIDATES = [
      { name: 'Arial',          value: 'Arial, sans-serif' },
      { name: 'ドットゴシック',   value: "'DotGothic16', sans-serif" },
      { name: 'Train One',      value: "'Train One', cursive" },
      { name: '手書き風',        value: "'Cherry Bomb One', cursive" },
      { name: '丸文字',          value: "'Kaisei Tokumin', serif" },
      { name: 'M PLUS Rounded', value: "'M PLUS Rounded 1c', sans-serif" },
      { name: 'M PLUS 1p', value: "'M PLUS 1p', sans-serif" },
      { name: 'Kosugi Maru', value: "'Kosugi Maru', sans-serif" },
      { name: 'Reggae One', value: "'Reggae One', cursive" },
      { name: 'RocknRoll One', value: "'RocknRoll One', sans-serif" },
      { name: 'Yomogi', value: "'Yomogi', cursive" },
      { name: 'Hachi Maru Pop', value: "'Hachi Maru Pop', cursive" },
    ];

    // ドロップダウンの中身を作る
    function buildFontDropdown() {
      fontDropdown.innerHTML = '';
      FONT_CANDIDATES.forEach(f => {
        const item = document.createElement('div');
        item.className = 'font-option';

        const sample = document.createElement('div');
        sample.className = 'font-sample';
        sample.textContent = 'Aaあア愛';
        sample.style.fontFamily = f.value;

        const name = document.createElement('div');
        name.className = 'font-name';
        name.textContent = f.name;

        item.appendChild(sample);
        item.appendChild(name);

        item.addEventListener('click', () => {
          setFont(f.value, f.name);
          fontDropdown.hidden = true;
        });

        fontDropdown.appendChild(item);
      });
    }

    // 実際にフォントを選んだときの処理
    function setFont(value, label) {
      // 1) 元の<select>に値をセット
      fontPicker.value = value;

      // 2) 既存の「change」処理をそのまま動かす
      fontPicker.dispatchEvent(new Event('change', { bubbles: true }));

      // 3) ボタン自体も選んだフォントで表示
      fontPickerBtn.style.fontFamily = value;
      fontPickerBtn.textContent = 'Aa あア愛 – ' + label;
    }

    // ボタンをタップ／クリックでメニュー開閉
    fontPickerBtn.addEventListener('click', () => {
      fontDropdown.hidden = !fontDropdown.hidden;
    });

    // 外側をクリックしたら閉じる
    document.addEventListener('click', (e) => {
      const wrap = document.querySelector('.font-picker-wrap');
      if (wrap && !wrap.contains(e.target)) fontDropdown.hidden = true;
    });

    // 初期化：リストを組み立てて、最初は「フォントを選ぶ」と表示だけする
    buildFontDropdown();
    (() => {
      fontPickerBtn.textContent = 'フォントを選ぶ';
      fontPickerBtn.style.fontFamily = 'Arial, sans-serif'; // ← フォントを指定しておくと見やすい！
    })();




    const previewWrapper = document.getElementById('previewWrapper');

    // --- ここから追加 ---
    let mode = 'front'; // 'front' (表) または 'back' (裏)
    let frontImageDataUrl = null; // 表面のプレビュー画像(DataURL)を一時保存（必要なら利用）
    //
    // 注意：初期は 'front'。「裏面も作る」ボタンで 'back' に切替えます。
    // --- ここまで追加 ---





    const previewImage = document.getElementById('previewImage');
    const previewNotice = document.getElementById('previewNotice');
    const areaDecorations = document.getElementById('area-decorations');
    const areaResult = document.getElementById('area-result');
    // 追加: 背景色ピッカーの取得
    const backgroundColorPicker = document.getElementById('backgroundColorPicker');

    // 状態変数
    let uploadedImg = null;
    let photoObject = null;
    let isPhotoLocked = false;
    let decorationObjects = [];
    let selectedObject = null;
    let history = [];
    let historyIndex = -1;
    // 追加: 背景色を保持する変数
    let backgroundColor = '#ffffff'; // デフォルトは白

    // --- ここから追加 ---
    let isRendering = false; // generate処理中フラグ（多重クリック防止）
    // --- ここまで追加 ---

    // ジェスチャー開始時のオブジェクトの状態とタッチ中心
    var initialObjX, initialObjY, initialObjScale, initialObjRotation;
    var initialTouchCenterX, initialTouchCenterY;
    // オブジェクトの中心からタッチ中心への初期ベクトル（キャンバス座標系）
    var initialVecOffsetX, initialVecOffsetY; 

    // --- 履歴管理機能 ---
    /**
     * 現在のデコレーションオブジェクトの状態を履歴に保存します。
     */
    function saveState() {
      // 現在のインデックス以降の履歴を削除し、新しい状態を追加
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }

      // decorationObjects を「JSONにできる形」に変換する（img は src に置き換える）
      const snapshot = decorationObjects.map(obj => {
        if (obj.type === 'image') {
          return {
            id: obj.id,
            type: 'image',
            src: obj.src || (obj.img && obj.img.src) || '',
            x: obj.x,
            y: obj.y,
            scale: obj.scale,
            rotation: obj.rotation,
            width: obj.width,
            height: obj.height
          };
        } else {
          // text 等
          return {
            id: obj.id,
            type: obj.type,
            content: obj.content,
            x: obj.x,
            y: obj.y,
            scale: obj.scale,
            rotation: obj.rotation,
            color: obj.color,
            fontFamily: obj.fontFamily,
            fontSize: obj.fontSize,
            // ▼ 縁取り・アーチのプロパティも保存（無ければデフォルト）
            outlineEnabled: !!obj.outlineEnabled,
            outlineColor: obj.outlineColor || '#000000',
            outlineWidthRatio: (typeof obj.outlineWidthRatio === 'number') ? obj.outlineWidthRatio : 0.12,
            isArched: !!obj.isArched,
            archStyle: obj.archStyle || 'rainbow',
            archAmount: (typeof obj.archAmount === 'number') ? obj.archAmount : 50
          };
        }
      });

      // 履歴配列に追加してインデックスを進める
      history.push(JSON.stringify(snapshot));
      historyIndex++;
    }


    function restoreDecorationsFromSnapshot(snapshotStr) {
      if (!snapshotStr) {
        decorationObjects = [];
        selectedObject = null;
        drawAll();
        return;
      }
      const arr = JSON.parse(snapshotStr);
      decorationObjects = arr.map(item => {
        if (item.type === 'image') {
          // 事前読み込み済みの stampImages があれば使い、なければ新しい Image を作る
          let img = (typeof stampImages !== 'undefined' && stampImages[item.src]) ? stampImages[item.src] : new Image();
          // stampImages にない場合は src をセットして読み込み開始
          if (!stampImages || !stampImages[item.src]) {
            img.src = item.src;
          }
          // 画像がまだ読み込み中でも、読み込み完了時に再描画するようにする
          if (!img.complete) {
            img.onload = () => { drawAll(); };
          }
          return {
            id: item.id,
            type: 'image',
            src: item.src,
            img: img,
            x: item.x,
            y: item.y,
            scale: item.scale,
            rotation: item.rotation,
            width: item.width,
            height: item.height
          };
        } else {
          // text 等（過去の履歴に装飾プロパティが無い場合に備えてデフォルト補完）
          return {
            id: item.id,
            type: item.type,
            content: item.content,
            x: item.x,
            y: item.y,
            scale: item.scale,
            rotation: item.rotation,
            color: item.color,
            fontFamily: item.fontFamily,
            fontSize: item.fontSize,
            // ▼ 追加：縁取り／アーチを復元（無ければデフォルト）
            outlineEnabled: (typeof item.outlineEnabled !== 'undefined') ? item.outlineEnabled : false,
            outlineColor: item.outlineColor || '#000000',
            outlineWidthRatio: (typeof item.outlineWidthRatio === 'number') ? item.outlineWidthRatio : 0.12,
            isArched: (typeof item.isArched !== 'undefined') ? item.isArched : false,
            archStyle: item.archStyle || 'rainbow',
            archAmount: (typeof item.archAmount === 'number') ? item.archAmount : 50
          };
        }
      });

      selectedObject = null;
      drawAll();
    }

    /**
     * 一つ前の編集状態に戻します（アンドゥ）。
     */
    function undo() {
      if (historyIndex > 0) {
    historyIndex--;
        restoreDecorationsFromSnapshot(history[historyIndex]);
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreDecorationsFromSnapshot(history[historyIndex]);
      }
    }

    // --- 描画機能 ---
    /**
     * 写真をキャンバスに描画します。
     */
    function drawImage() {
      if (!photoObject || !uploadedImg) return;

      ctx.save(); // 現在のキャンバスの状態を保存
      // 写真の中心を基準に移動、回転、拡大縮小
      ctx.translate(photoObject.x, photoObject.y);
      ctx.rotate(photoObject.rotation);
      ctx.scale(photoObject.scale, photoObject.scale);
      // 画像を描画（中心座標が0,0になるようにオフセット）
      ctx.drawImage(uploadedImg, -uploadedImg.width / 2, -uploadedImg.height / 2);
      ctx.restore(); // 保存した状態に戻す
    }

    // --- 直線／アーチ文字の共通描画関数 -----------------------------
    function drawTextByStyle(ctx, obj) {
      // フォントとアラインを統一
      ctx.font = `${obj.fontSize}px ${obj.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const ratio  = obj.outlineWidthRatio || 0.12;
      const outerW = Math.max(1, obj.fontSize * ratio);
      const innerW = Math.max(1, outerW * 0.35);

      const strokeAndFill = (ch) => {
        if (obj.outlineEnabled) {
          ctx.lineJoin = 'round';
          ctx.miterLimit = 2;

          // 外側
          ctx.strokeStyle = obj.outlineColor || '#000000';
          ctx.lineWidth   = outerW;
          ctx.strokeText(ch, 0, 0);

          // 内側（白）
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth   = innerW;
          ctx.strokeText(ch, 0, 0);
        }
        // 本体
        ctx.fillStyle = obj.color;
        ctx.fillText(ch, 0, 0);
      };

      const isArched = !!obj.isArched && (obj.archAmount || 0) > 0;

      if (!isArched) {
        // まっすぐ描画（従来）
        strokeAndFill(obj.content);
        return;
      }

      // --- アーチ描画 ---
      const text = obj.content || '';
      if (!text) return;

      const chars  = [...text];
      const widths = chars.map(ch => ctx.measureText(ch).width);
      const totalWidth = widths.reduce((a, b) => a + b, 0);

      const MAX_RAD = 2.4; // 最大カーブ角（約137°）
      const amount  = Math.max(0, Math.min(100, obj.archAmount || 0));
      const theta   = Math.max(0.001, MAX_RAD * (amount / 100)); // 全体角度

      const R = totalWidth / theta; // 弧長 = R * θ
      // ← ここを入れ替えます（虹型=rainbow を U ＝下に膨らむにする）
      const dir = (obj.archStyle === 'rainbow') ? +1 : -1; // rainbow=U(下にふくらむ), smile=∩(上にふくらむ)

      let angle = -theta / 2; // 左端スタート
      for (let i = 0; i < chars.length; i++) {
        const w = widths[i];
        const charAngle = w / R;
        const mid = angle + charAngle / 2; // その文字の中心角

        const x = R * Math.sin(mid);
        const y = dir * R * (1 - Math.cos(mid)); // φ=0 で y=0 になる座標系

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(dir * mid); // 接線方向に回転

        strokeAndFill(chars[i]);

        ctx.restore();
        angle += charAngle;
      }
    }
    // --------------------------------------------------------------








    /**
     * デコレーションオブジェクト（テキスト、スタンプ）をキャンバスに描画します。
     */
    function drawDecorations() {
      decorationObjects.forEach(obj => {
        ctx.save();
        // オブジェクトの中心を基準に移動、回転、拡大縮小
        ctx.translate(obj.x, obj.y);
        ctx.rotate(obj.rotation);
        ctx.scale(obj.scale, obj.scale);

        if (obj.type === 'text') {
          drawTextByStyle(ctx, obj);


        } else if (obj.type === 'image') {
          // 画像を描画（中心座標が0,0になるようにオフセット）
          ctx.drawImage(obj.img, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
        }

        // 選択中のオブジェクトに枠線を表示
        if (obj === selectedObject) {
          ctx.strokeStyle = '#42a5f5';
          ctx.lineWidth = 10 / obj.scale; // スケーリングに合わせて線幅を調整
          ctx.setLineDash([20 / obj.scale, 10 / obj.scale]); // スケーリングに合わせて点線の間隔を調整
          // オブジェクトの描画サイズを計算し、枠線を描画
          const rectWidth  = obj.type === 'text' ? ctx.measureText(obj.content).width : obj.width;
          const rectHeight = obj.type === 'text' ? obj.fontSize * 1.2 : obj.height;
          ctx.strokeRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight);
          ctx.setLineDash([]); // 点線モードをリセット
        }

        ctx.restore();
      });
    }

    /**
     * キャンバス全体をクリアし、写真とデコレーションを再描画します。
     */
    function drawAll() {
      // 1. まず背景色で全体を塗りつぶす
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
      // 2. 写真を描画
      drawImage();
      // 3. デコレーションを描画
      drawDecorations();
    }

    /**
     * マウス/タッチイベントのクライアント座標をキャンバス内の論理座標に変換します。
     * @param {number} clientX - イベントのclientX座標
     * @param {number} clientY - イベントのclientY座標
     * @returns {{x: number, y: number}} キャンバス内の座標
     */
    function getCanvasCoords(clientX, clientY) {
      const rect = mainCanvas.getBoundingClientRect(); // キャンバスの画面上での位置とサイズ
      const x = (clientX - rect.left) * (mainCanvas.width / rect.width);
      const y = (clientY - rect.top) * (mainCanvas.height / rect.height);
      return { x, y };
    }

    /**
     * 指定された点がオブジェクトの境界内にあるか判定します。
     * @param {{x: number, y: number}} p - 判定したい点（キャンバス座標）
     * @param {object} obj - 判定対象のオブジェクト
     * @returns {boolean} 点がオブジェクト内にあるか
     */
    function isPointInObject(p, obj) {
      // 1. 点をオブジェクトのローカル座標系に変換する (逆変換)
      // まずオブジェクトの中心を原点に移動
      const translatedX = p.x - obj.x;
      const translatedY = p.y - obj.y;

      // 回転を元に戻す
      const cos = Math.cos(-obj.rotation);
      const sin = Math.sin(-obj.rotation);
      const rotatedX = translatedX * cos - translatedY * sin;
      const rotatedY = translatedX * sin + translatedY * cos;

      // スケールを元に戻す
      const scaledX = rotatedX / obj.scale;
      const scaledY = rotatedY / obj.scale;

      // 2. オブジェクトのローカル座標系での幅と高さを計算
      let objWidth, objHeight;
      if (obj.type === 'text') {
        // テキストの場合、現在のフォント設定でテキストの実際の幅を測定
        ctx.save();
        ctx.font = `${obj.fontSize}px ${obj.fontFamily}`; // オリジナルのフォントサイズで測定
        objWidth = ctx.measureText(obj.content).width;
        objHeight = obj.fontSize * 1.2; // テキストの高さは行高を考慮
        ctx.restore();
      } else if (obj.type === 'image') {
        objWidth = obj.width;
        objHeight = obj.height;
      } else {
          return false; // 未知のタイプ
      }

      const halfObjWidth = objWidth / 2;
      const halfObjHeight = objHeight / 2;

      // 3. 変換された点が、オブジェクトのローカル境界ボックス内にあるか判定
      return scaledX >= -halfObjWidth && scaledX <= halfObjWidth &&
             scaledY >= -halfObjHeight && scaledY <= halfObjHeight;
    }

    // --- イベントリスナー ---
    /**
     * 画像ファイルの読み込み処理
     */
    imageLoader.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        uploadedImg = new Image();
        uploadedImg.onload = () => {
          // 写真オブジェクトの初期位置、スケール、回転を設定
          photoObject = {
            x: mainCanvas.width / 2, // キャンバス中央
            y: mainCanvas.height / 2, // キャンバス中央
            scale: 1,
            rotation: 0
          };

          // ====> ここに以下のコードを追加します <====
      
          // 写真がアップロードされたら背景色を白にリセット
                backgroundColor = '#ffffff'; 
                
          // ====> ここまで <====


          isPhotoLocked = false; // 写真編集を可能にする
          reEditPhotoBtn.style.display = 'none'; // 再編集ボタンは非表示
          confirmPhotoBtn.style.display = 'block'; // 確定ボタンを表示
          areaDecorations.style.display = 'none'; // デコレーションエリアを非表示
          areaResult.style.display = 'none'; // 完成イメージエリアも非表示にリセット
          drawAll(); // 全体を再描画

          // ====== ここから追加（描画反映後に #area-canvas へスクロール） ======
          // double requestAnimationFrame で描画反映を待ち、スクロール対象が window か内部スクロールかを自動判定してスクロールします
          requestAnimationFrame(function(){
            requestAnimationFrame(function(){
              var el = document.getElementById('area-canvas');
              if (!el) {
                console.log('[scroll] #area-canvas が見つかりません');
                return;
              }

              function getScrollableAncestor(node) {
                while (node && node !== document.body) {
                  var s = window.getComputedStyle(node);
                  if ((s.overflowY === 'auto' || s.overflowY === 'scroll') && node.scrollHeight > node.clientHeight) {
                    return node;
                  }
                  node = node.parentNode;
                }
                return window;
              }

              var container = getScrollableAncestor(el);

              if (container === window) {
                var top = el.getBoundingClientRect().top + window.scrollY;
                window.scrollTo({ top: top, behavior: 'smooth' });
              } else {
                var contRect = container.getBoundingClientRect();
                var elRect = el.getBoundingClientRect();
                var offsetTop = elRect.top - contRect.top + container.scrollTop;
                container.scrollTo({ top: offsetTop, behavior: 'smooth' });
              }

              // 固定ヘッダー等に被る場合のオフセット（必要なら調整してください）
              setTimeout(function(){
                var headerOffset = 60; // 固定ヘッダーの高さ(px)。環境に合わせて変更
                if (container === window) {
                  window.scrollBy(0, -headerOffset);
                } else {
                  container.scrollBy(0, -headerOffset);
                }
              }, 350);
            });
          });
          // ====== ここまで追加 ======

        };
        uploadedImg.src = event.target.result;
      };
      reader.readAsDataURL(file);
      
    });

    /**
     * うちわテンプレートの選択変更処理
     */
    templateSelector.addEventListener('change', e => {
      // 低解像度テンプレートに切り替えて表示
      templateOverlay.src = e.target.selectedOptions[0].dataset.lowres;
    });
    
    // ====> この行の直後に追加 <====

    // 新規追加: 背景色ピッカーの変更イベント
    backgroundColorPicker.addEventListener('input', (e) => {
        backgroundColor = e.target.value; 
        e.target.style.backgroundColor = e.target.value; 
        uploadedImg = null; 
        photoObject = null;
        isPhotoLocked = true;

        // デコレーションエリアを表示
        areaDecorations.style.display = 'block'; 

        // 完成エリアは閉じる
        areaResult.style.display = 'none'; 

        // 写真配置確定ボタンや再編集ボタンは非表示にする
        reEditPhotoBtn.style.display = 'none';
        confirmPhotoBtn.style.display = 'none';

        // すぐ編集パネルにスクロールさせると親切
        areaDecorations.scrollIntoView({ behavior: 'smooth' });

        drawAll(); 
    });

    // ====> ここまで <====



    /**
     * 写真の配置確定ボタンの処理
     */
    confirmPhotoBtn.addEventListener('click', () => {
      if (!uploadedImg) return; // 写真がアップロードされていなければ何もしない

      // 写真をロックして「分岐」UIを出す（編集パネルは最初は閉じる）
      isPhotoLocked = true;
      confirmPhotoBtn.style.display = 'none';
      reEditPhotoBtn.style.display = 'block';
      areaDecorations.style.display = 'none'; // 編集パネルは閉じた状態で分岐表示
      document.getElementById('arrangeControls').style.display = 'flex'; // 保存/編集の入口を表示
      document.getElementById('editorWrapper').scrollIntoView({ behavior: 'smooth' });

      saveState(); // 最初のデコレーション状態を保存
    });

    /**
     * 写真の再編集ボタンの処理
     */
    reEditPhotoBtn.addEventListener('click', () => {
      isPhotoLocked = false; // 写真のロックを解除
      reEditPhotoBtn.style.display = 'none'; // 再編集ボタンを非表示
      confirmPhotoBtn.style.display = 'block'; // 確定ボタンを表示
      areaDecorations.style.display = 'none'; // デコレーションエリアを非表示
      selectedObject = null; // 選択中のデコレーションオブジェクトを解除
      areaResult.style.display = 'none'; // 完成イメージエリアも非表示にリセット
      drawAll(); // 全体を再描画
    });

    // --- ここから置き換え：決定 → プレビュー（低解像度で素早く表示 → 裏でA3生成） ---
    generateBtn.addEventListener('click', async () => {
      if (isRendering) return; // 多重クリック防止
      isRendering = true;
      generateBtn.disabled = true;

      // 選択を一時退避して消す（プレビューに選択枠を入れないため）
      let _prevSelectedForPreview = selectedObject;
      selectedObject = null;

      const spinner = document.getElementById('previewSpinner');
      if (spinner) spinner.style.display = 'flex';

      // ヘルパ：テンプレートに適用されている filter/opacity を取得（DOM要素 or ::before に対応）
      function _getTemplateFilterAndOpacity() {
        try {
          const tplEl = document.getElementById('templateOverlay');
          if (tplEl) {
            const cs = window.getComputedStyle(tplEl);
            return { filter: cs.filter || 'none', opacity: parseFloat(cs.opacity || '1') || 1 };
          }
          // fallback: #editorWrapper::before にテンプレがあるケース
          const editor = document.getElementById('editorWrapper');
          if (editor) {
            const csBefore = window.getComputedStyle(editor, '::before');
            return { filter: csBefore.filter || 'none', opacity: parseFloat(csBefore.opacity || '1') || 1 };
          }
        } catch (e) {
          // ignore
        }
        return { filter: 'none', opacity: 1 };
      }

      try {
        // ---------- 1) 素早い「縮小プレビュー」生成（低解像度ベース） ----------
        const smallCanvas = document.createElement('canvas');
        smallCanvas.width = mainCanvas.width;
        smallCanvas.height = mainCanvas.height;
        const sctx = smallCanvas.getContext('2d');

        // 背景
        sctx.fillStyle = backgroundColor;
        sctx.fillRect(0, 0, smallCanvas.width, smallCanvas.height);

        // 写真（低解像度で概算描画）
        if (uploadedImg) {
          if (uploadedImg.decode) try { await uploadedImg.decode(); } catch(e){/*ignore*/ }
          const srcW = (uploadedImg.naturalWidth || uploadedImg.width);
          const srcH = (uploadedImg.naturalHeight || uploadedImg.height);
          const drawW = srcW * (photoObject.scale || 1);
          const drawH = srcH * (photoObject.scale || 1);
          sctx.save();
          sctx.translate(photoObject.x, photoObject.y);
          sctx.rotate(photoObject.rotation || 0);
          sctx.drawImage(uploadedImg, -drawW / 2, -drawH / 2, drawW, drawH);
          sctx.restore();
        }

        // デコレーション（低解像度で描画 — 選択枠は selectedObject を null にしているため描かれない）
        decorationObjects.forEach(obj => {
          sctx.save();
          sctx.translate(obj.x, obj.y);
          sctx.rotate(obj.rotation || 0);
          if (obj.type === 'text') {
            drawTextByStyle(sctx, obj);
          } else if (obj.type === 'image') {
            sctx.drawImage(obj.img, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
          }
          sctx.restore();
        });

        // テンプレート（縮小版）を描画：DOMの filter/opacity を反映
        let tplImg = templateCache[templateSelector.value];
        if (!tplImg) {
          tplImg = new Image();
          tplImg.src = templateSelector.value;
          if (tplImg.decode) try { await tplImg.decode(); } catch(e){/*ignore*/ }
        } else {
          if (tplImg.decode) try { await tplImg.decode(); } catch(e){/*ignore*/ }
        }
        const tplStyle = _getTemplateFilterAndOpacity();
        try {
          if (tplStyle.filter && tplStyle.filter !== 'none') sctx.filter = tplStyle.filter;
          sctx.globalAlpha = tplStyle.opacity;
        } catch (e) {/* ignore */}
        sctx.drawImage(tplImg, 0, 0, smallCanvas.width, smallCanvas.height);
        sctx.filter = 'none';
        sctx.globalAlpha = 1;

        // 縮小して先に素早く表示
        const MAX_PREVIEW_WIDTH = 1200;
        const previewScale = Math.min(1, MAX_PREVIEW_WIDTH / smallCanvas.width);
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = Math.max(1, Math.round(smallCanvas.width * previewScale));
        previewCanvas.height = Math.max(1, Math.round(smallCanvas.height * previewScale));
        const pctx = previewCanvas.getContext('2d');
        pctx.drawImage(smallCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
        const quickDataUrl = previewCanvas.toDataURL('image/png');
        previewImage.src = quickDataUrl; // まずは縮小版を素早く表示
        areaResult.style.display = 'block';
        previewWrapper.style.display = 'block';
        goToOrderFormBtn.style.display = 'block';
        if (mode === 'front') frontImageDataUrl = quickDataUrl;

        // ---------- 2) 裏でフル解像度生成（A3相当） ----------
        setTimeout(async () => {
          try {
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = Math.round(3508); // 必要ならここを動的に計算
            fullCanvas.height = Math.round(4961); // 必要ならここを動的に計算
            const fctx = fullCanvas.getContext('2d');

            // 背景
            fctx.fillStyle = backgroundColor;
            fctx.fillRect(0, 0, fullCanvas.width, fullCanvas.height);

            // 写真（高解像度で描画 — スケーリングに注意）
            if (uploadedImg) {
              try { if (uploadedImg.decode) await uploadedImg.decode(); } catch(e){/*ignore*/ }
              const srcW = (uploadedImg.naturalWidth || uploadedImg.width);
              const srcH = (uploadedImg.naturalHeight || uploadedImg.height);
              // scaleX/scaleY を適切に計算する（ここは既存ロジックを踏襲）
              const scaleX = fullCanvas.width / mainCanvas.width;
              const scaleY = fullCanvas.height / mainCanvas.height;
              const drawW = srcW * (photoObject.scale || 1) * scaleX;
              const drawH = srcH * (photoObject.scale || 1) * scaleY;
              fctx.save();
              fctx.translate((photoObject.x || 0) * scaleX, (photoObject.y || 0) * scaleY);
              fctx.rotate(photoObject.rotation || 0);
              fctx.drawImage(uploadedImg, -drawW / 2, -drawH / 2, drawW, drawH);
              fctx.restore();
            }

            // デコレーション（高解像度）
            const scaleX = fullCanvas.width / mainCanvas.width;
            const scaleY = fullCanvas.height / mainCanvas.height;
            const avgScale = (scaleX + scaleY) / 2;
            for (const obj of decorationObjects) {
              fctx.save();
              fctx.translate(obj.x * scaleX, obj.y * scaleY);
              fctx.rotate(obj.rotation || 0);
              if (obj.type === 'text') {
                const scaledText = Object.assign({}, obj, {
                  fontSize: (obj.fontSize || 16) * (obj.scale || 1) * avgScale,
                  scale: 1
                });
                drawTextByStyle(fctx, scaledText);
              } else if (obj.type === 'image') {
                try { obj.img && obj.img.decode && obj.img.decode().catch(()=>{}); } catch(e){}
                const w = (obj.width || (obj.img && (obj.img.naturalWidth || obj.img.width))) * (obj.scale || 1) * scaleX;
                const h = (obj.height || (obj.img && (obj.img.naturalHeight || obj.img.height))) * (obj.scale || 1) * scaleY;
                fctx.drawImage(obj.img, -w / 2, -h / 2, w, h);
              }
              fctx.restore();
            }

            // テンプレート（高解像度）を描画（DOMの filter/opacity を反映）
            let tplImg2 = templateCache[templateSelector.value];
            if (!tplImg2) {
              tplImg2 = new Image();
              tplImg2.src = templateSelector.value;
              if (tplImg2.decode) try { await tplImg2.decode(); } catch(e){/*ignore*/ }
            } else {
              if (tplImg2.decode) try { await tplImg2.decode(); } catch(e){/*ignore*/ }
            }
            try {
              const tplStyle2 = _getTemplateFilterAndOpacity();
              if (tplStyle2.filter && tplStyle2.filter !== 'none') fctx.filter = tplStyle2.filter;
              fctx.globalAlpha = tplStyle2.opacity;
            } catch (e) { /* ignore */ }
            fctx.drawImage(tplImg2, 0, 0, fullCanvas.width, fullCanvas.height);
            fctx.filter = 'none';
            fctx.globalAlpha = 1;

            // 完全解像度画像をプレビューに差し替え
            const fullDataUrl = fullCanvas.toDataURL('image/png');
            previewImage.src = fullDataUrl;
            if (mode === 'front') frontImageDataUrl = fullDataUrl;
          } catch (err) {
            console.warn('フル解像度生成に失敗しました', err);
          }
        }, 50);

      } catch (e) {
        console.error('preview generate error:', e);
        alert('プレビュー生成中にエラーが発生しました。コンソールを確認してください。');
      } finally {
        // プレビュー終了後に選択を復元して UI を再描画
        selectedObject = _prevSelectedForPreview;
        if (spinner) spinner.style.display = 'none';
        isRendering = false;
        generateBtn.disabled = false;
        try { drawAll(); } catch(e) { /* ignore */ }
      }
    });
    // --- ここまで置き換え ---





    // ここから追加：裏面作成モードに切り替える処理（変更：裏面は完全リセットして "1) 裏面の背景を決める" から開始）
    document.getElementById('makeBackBtn').addEventListener('click', () => {
      // 1) モード切替
      mode = 'back';

      // 2) 完全リセット（表での状態は保持したい場合は frontImageDataUrl は触らない）
      uploadedImg = null;
      photoObject = null;
      isPhotoLocked = true;      // 初期状態は写真操作をロック（写真を選択したら解除される想定）
      decorationObjects = [];    // デコを空に
      selectedObject = null;
      history = [];
      historyIndex = -1;

      // 3) 入力コントロールを初期値に戻す（安全に getElementById して存在チェック）
      const bgPicker = document.getElementById('backgroundColorPicker');
      if (bgPicker) {
        bgPicker.value = '#ffffff'; // 初期色を白に（お好みで変更可）
      }
      backgroundColor = '#ffffff';

      const tpl = document.getElementById('templateSelector');
      if (tpl) {
        tpl.selectedIndex = 0; // 最初のテンプレートに戻す
        if (typeof preloadTemplate === 'function') {
          preloadTemplate(tpl.value); // プリロード関数があれば呼ぶ（存在チェック）
        }
      }

      // ---------- 追加：裏面モードに入ったらテンプレート選択を隠す ----------
        const tplLabel = document.getElementById('templateLabel');
        // tpl は既に上で取得済み（document.getElementById('templateSelector')）
        if (tpl) tpl.style.display = 'none'; // セレクタを非表示にする
        if (tplLabel) tplLabel.textContent = '※ 表で選んだ「サイズ・型」が裏面にも適用されます';
        // ----

      // 4) UI 表示を「1) 背景を決める」エリアに合わせる
      const areaSelect = document.getElementById('area-select');
      const areaCanvas = document.getElementById('area-canvas');
      const areaDecor = document.getElementById('area-decorations');
      const areaResultEl = document.getElementById('area-result');

      if (areaResultEl) areaResultEl.style.display = 'none'; // プレビューは隠す
      if (areaDecor) areaDecor.style.display = 'none';       // デコは非表示
      if (areaSelect) areaSelect.style.display = 'block';     // 1) 背景選択を先頭に
      if (areaCanvas) areaCanvas.style.display = 'block';     // キャンバスは見せる（空の状態）

      // 写真操作系ボタンは初期非表示（写真が無ければ確定できないため）
      const confirmBtn = document.getElementById('confirmPhotoBtn');
      if (confirmBtn) confirmBtn.style.display = 'none';
      const reEditBtn = document.getElementById('reEditPhotoBtn');
      if (reEditBtn) reEditBtn.style.display = 'none';

      // 「裏面も作る」ボタンはプレビュー側にのみ出す仕様なのでここでは隠す
      const makeBackBtnEl = document.getElementById('makeBackBtn');
      if (makeBackBtnEl) makeBackBtnEl.style.display = 'none';

      // プレビュー案内リセット
      const previewNoticeEl = document.getElementById('previewNotice');
      if (previewNoticeEl) previewNoticeEl.innerHTML = '';

      // 5) 見出しを裏面向けの初期文言に変更
      const s1 = document.getElementById('section1-title');
      const s2 = document.getElementById('section2-title');
      const s3 = document.getElementById('section3-title');
      if (s1) s1.textContent = '1) 裏面の背景を決める';
      if (s2) s2.textContent = '2) 裏面をデザイン';
      if (s3) s3.textContent = '3) 裏面のデコレーション';

      // 6) 初期描画（背景色だけの空の裏面を描画）
      drawAll();

      // 7) スクロールして1番目のエリアへ
      if (areaSelect) areaSelect.scrollIntoView({ behavior: 'smooth' });
    });
    // ここまで追加

    // --- デコレーションオブジェクト追加機能 ---
    /**
     * 自由テキストをデコレーションとして追加します。
     */
    function addTextToOverlay() {
      const text = customText.value.trim();
      if (!text) return; // テキストが空なら何もしない
      const newText = {
        id: Date.now(), // 一意なID
        type: 'text',
        content: text,
        x: mainCanvas.width / 2, // キャンバス中央に配置
        y: mainCanvas.height / 2,
        scale: 1,
        rotation: 0,
        color: colorPicker.value,
        fontFamily: fontPicker.value,
        fontSize: 500, // 初期フォントサイズ

        outlineEnabled: outlineToggle.checked,
        outlineColor: outlineColorPicker.value,
        outlineWidthRatio: parseInt(outlineWidthPercent.value, 10) / 100,
        isArched: false,
        archStyle: 'rainbow',
        archAmount: 50,
      };

      decorationObjects.push(newText); // 配列に追加
      selectedObject = newText; // 追加したものを選択状態にする
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    }

    // PNGステッカー画像を事前に読み込む
    const stampImages = {};
    const pngStickers = ['01loveu.png', '02ntwithFace.png', '03eyestome.png', '04getmyheart.png',  '05angel.png', '06god.png', '07precious.png'];
    pngStickers.forEach(src => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        stampImages[src] = img; // 読み込み完了後、オブジェクトに格納
      };
    });

    /**
     * スタンプ（絵文字またはPNG画像）をデコレーションとして追加します。
     * @param {string} content - 絵文字文字列またはPNG画像ファイル名
     */
    function addStamp(content) { 
      if (content.endsWith('.png')) {
        // 画像ステッカーの場合
        const img = new Image();
        img.src = content;

        const newStamp = {
          id: Date.now(),
          type: 'image',
          src: content,
          img: img,
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
          scale: 1,
          rotation: 0,
          width: 200,  // 仮のサイズ（読み込み前）
          height: 200
        };

        img.onload = () => {
          // 本当のサイズをセット
          newStamp.width = img.naturalWidth;
          newStamp.height = img.naturalHeight;

          // 大きすぎる場合はリサイズ
          const maxDim = Math.max(newStamp.width, newStamp.height);
          const targetSize = 400; // 初期表示サイズの目標
          if (maxDim > targetSize) {
            const scaleFactor = targetSize / maxDim;
            newStamp.width *= scaleFactor;
            newStamp.height *= scaleFactor;
          }

          // 配列に追加・選択・描画
          decorationObjects.push(newStamp);
          selectedObject = newStamp;
          drawAll();
          saveState();
        };

      } else {
        // テキストや絵文字の場合
        const newStamp = {
          id: Date.now(),
          type: 'text',
          content: content,
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
          scale: 1,
          rotation: 0,
          color: 'black',
          fontFamily: 'sans-serif',
          fontSize: 500,
          // ▼ 追加：縁取り／アーチの初期値
          outlineEnabled: false,
          outlineColor: '#000000',
          outlineWidthRatio: 0.12,
          isArched: false,
          archStyle: 'rainbow',
          archAmount: 50
        };

        decorationObjects.push(newStamp);
        selectedObject = newStamp;
        drawAll();
        saveState();
      }
    }


    // --- デコレーションオブジェクトの編集コントロール ---
    /**
     * デコレーションオブジェクトの選択を切り替えます。
     */
    const _selectBtn = document.getElementById('selectBtn'); // ★追加①：ボタンを変数に入れる
    if (_selectBtn) {                                        // ★追加②：ボタンがある時だけ中を実行
      _selectBtn.addEventListener('click', () => {           // ← 元の行を _selectBtn に差し替えて中へ移動
        if (decorationObjects.length === 0) return;
        const currentIndex = decorationObjects.indexOf(selectedObject);
        const nextIndex = (currentIndex + 1) % decorationObjects.length;
        selectedObject = decorationObjects[nextIndex];
        drawAll();
      });
    } // ← if の閉じカッコ（新規ではないけど、②を開いたのでここで閉じます）

    document.getElementById('undoBtn').addEventListener('click', undo); // 戻るボタン
    document.getElementById('redoBtn').addEventListener('click', redo); // やり直しボタン

    /**
     * 選択中のデコレーションオブジェクトを削除します。
     */
    document.getElementById('deleteBtn').addEventListener('click', () => {
      if (!selectedObject) return;
      decorationObjects = decorationObjects.filter(obj => obj !== selectedObject); // 選択中のオブジェクトを除外
      selectedObject = null; // 選択状態を解除
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    });

    /**
     * 選択中のデコレーションオブジェクトを複製します。
     */
    document.getElementById('duplicateBtn').addEventListener('click', () => {
      if (!selectedObject) return;
      // 選択オブジェクトを一度シリアライズしてから戻す（img は消えるが、後で src から再作成）
      const plain = JSON.parse(JSON.stringify(selectedObject));
      const newObj = Object.assign({}, plain);
      newObj.id = Date.now();
      newObj.x += 20;
      newObj.y += 20;

      if (newObj.type === 'image') {
        // 画像の場合は src から Image を作る/使う
        const img = (typeof stampImages !== 'undefined' && stampImages[newObj.src]) ? stampImages[newObj.src] : new Image();
        img.src = newObj.src;
        newObj.img = img;
      }

      decorationObjects.push(newObj);
      selectedObject = newObj;
      drawAll();
      saveState();
    });

    /**
     * 選択中のデコレーションオブジェクトを背面へ移動します。
     */
    document.getElementById('sendBackwardBtn').addEventListener('click', () => {
      const index = decorationObjects.indexOf(selectedObject);
      if (index > 0) { // 最前面でなければ
        const obj = decorationObjects.splice(index, 1)[0]; // 選択中のオブジェクトを配列から取り出す
        decorationObjects.splice(index - 1, 0, obj); // 一つ前の位置に挿入
        drawAll(); // 全体を再描画
        saveState(); // 状態を履歴に保存
      }
    });

    /**
     * 選択中のデコレーションオブジェクトを前面へ移動します。
     */
    document.getElementById('bringForwardBtn').addEventListener('click', () => {
      const index = decorationObjects.indexOf(selectedObject);
      if (index < decorationObjects.length - 1) { // 最背面でなければ
        const obj = decorationObjects.splice(index, 1)[0]; // 選択中のオブジェクトを配列から取り出す
        decorationObjects.splice(index + 1, 0, obj); // 一つ後の位置に挿入
        drawAll(); // 全体を再描画
        saveState(); // 状態を履歴に保存
      }
    });

    // --- テキストデコレーションのリアルタイム更新 ---
    customText.addEventListener('input', () => {
      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.content = customText.value; // テキスト内容を更新
        drawAll(); // 全体を再描画
      }
    });

    colorPicker.addEventListener('input', (e) => {
      // 自由テキスト用カラーピッカーの背景色を、選択された色にリアルタイムで更新
      e.target.style.backgroundColor = e.target.value;

      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.color = colorPicker.value; // 色を更新
        drawAll(); // 全体を再描画
      }
    });

    fontPicker.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.fontFamily = fontPicker.value; // フォントを更新
        drawAll(); // 全体を再描画
      }
    });

    // ← この下に追加！
    outlineColorPicker.addEventListener('input', (e) => {
      // 縁取りカラーピッカーの見た目をリアルタイムで更新
      e.target.style.backgroundColor = e.target.value;

      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.outlineColor = outlineColorPicker.value;
        drawAll();
      }
    });

    function updateSelectedTextOutline(updater) {
      if (selectedObject && selectedObject.type === 'text') {
        updater(selectedObject);
        drawAll(); // 再描画（あなたのコードでは drawDecorations() かもしれません）
      }
    }

    outlineToggle.addEventListener('change', () => {
      updateSelectedTextOutline(obj => obj.outlineEnabled = outlineToggle.checked);
      saveState(); // ← 追加
    });
    outlineColorPicker.addEventListener('input', () => {
      updateSelectedTextOutline(obj => obj.outlineColor = outlineColorPicker.value);
    });
    outlineColorPicker.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        saveState();
      }
    });



    outlineWidthPercent.addEventListener('input', () => {
      outlineWidthValue.textContent = outlineWidthPercent.value + '%';
      updateSelectedTextOutline(obj => obj.outlineWidthRatio = parseInt(outlineWidthPercent.value, 10) / 100);
    });
    outlineWidthPercent.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        saveState();
      }
    });
    // --- アーチ文字のリアルタイム更新 ---
    function updateSelectedTextArch(updater) {
      if (selectedObject && selectedObject.type === 'text') {
        updater(selectedObject);
        drawAll();
      }
    }

    archToggle.addEventListener('change', () => {
      updateSelectedTextArch(obj => obj.isArched = archToggle.checked);
      saveState(); // ← 追加
    });

    archStyleRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        const checked = document.querySelector('input[name="archStyle"]:checked');
        updateSelectedTextArch(obj => obj.archStyle = checked ? checked.value : 'rainbow');
        saveState(); // ← 追加
      });
    });

    archAmount.addEventListener('input', () => {
      archAmountValue.textContent = archAmount.value;
      updateSelectedTextArch(obj => obj.archAmount = parseInt(archAmount.value, 10));
    });
    archAmount.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        saveState();
      }
    });


    // --- Hammer.js によるタッチ/マウスジェスチャーハンドリング ---
    const hammertime = new Hammer(mainCanvas);

    // ブラウザの慣性スクロール/ページズームを確実に無効化（CSSに加えて保険）
    mainCanvas.style.touchAction = 'none';

    const pan    = hammertime.get('pan');
    const pinch  = hammertime.get('pinch');
    const rotate = hammertime.get('rotate');

    // 1本指パンのみ許可（2本以上の指では pan を発火させない）
    pan.set({ enable: true, pointers: 1, threshold: 0 });

    // ピンチ／回転は常に有効
    pinch.set({ enable: true });
    rotate.set({ enable: true });

    // 2本指ジェスチャー（pinch/rotate）が認識されたら pan は発火しないようにする
    pinch.recognizeWith(rotate);
    pan.requireFailure([pinch, rotate]);



    // 操作対象のオブジェクトを返すヘルパー関数
    function getActiveObject() {
        if (!isPhotoLocked) {
            return photoObject; // 写真編集中は写真がターゲット
        } else if (selectedObject) {
            return selectedObject; // デコレーション編集中は選択中のデコレーションがターゲット
        }
        return null; // 何も操作対象がない場合
    }

    // タップでデコレーションを選択
    hammertime.on('tap', function(e) {
      if (isPhotoLocked) { // 写真がロックされている場合のみデコレーションを選択
        const p = getCanvasCoords(e.srcEvent.clientX, e.srcEvent.clientY); // タッチ位置をキャンバス座標に変換
        let found = false;
        // Zオーダーを考慮し、配列の最後（最も手前）から逆順に判定
        for (let i = decorationObjects.length - 1; i >= 0; i--) {
          const obj = decorationObjects[i];


          if (isPointInObject(p, obj)) {
            selectedObject = obj; // オブジェクトを選択状態にする
            drawAll(); // 全体を再描画

            // 追加：選択内容に応じて詳細パネルを自動オープン
            if (selectedObject && selectedObject.type === 'text') {
              showPanel('panel-text');
            } else if (selectedObject) {
              // 画像スタンプなどは配置・レイヤー操作中心に
              showPanel('panel-arrange');
            }

            found = true;
            break;
          }
        }
        if (!found) { // どのオブジェクトも選択されなかった場合
          selectedObject = null; // 選択状態を解除
          drawAll(); // 全体を再描画
          // 追加：未選択ならパネルを閉じる
          hidePanels();
        }
      }
    });

    // パン（移動）ジェスチャー
    hammertime.on('panstart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
        // --- 基準値を必ずリセット ---
          initialObjX = activeObj.x;
          initialObjY = activeObj.y;
          initialObjScale = activeObj.scale;
          initialObjRotation = activeObj.rotation;
          // 2本指以上なら pan は処理しない（念のための安全弁）
          if (e.pointers && e.pointers.length !== 1) return;

          // 直前の位置・拡大率・回転を基準にする
          initialObjX = activeObj.x;
          initialObjY = activeObj.y;
          initialObjScale = activeObj.scale;
          initialObjRotation = activeObj.rotation;

          // ジェスチャー開始時のタッチ中心点をキャンバス座標で記録
          const touchCenter = getCanvasCoords(e.center.x, e.center.y);
          initialTouchCenterX = touchCenter.x;
          initialTouchCenterY = touchCenter.y;
        }
    });
    hammertime.on('pan', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
        // 2本指以上なら pan は処理しない（念のための安全弁）
        if (e.pointers && e.pointers.length !== 1) return;
            // 現在のタッチ中心点をキャンバス座標で取得
            const currentTouchCenter = getCanvasCoords(e.center.x, e.center.y);
            // オブジェクトの新しい位置は、開始時の位置にタッチ中心点の移動量を加算
            activeObj.x = initialObjX + (currentTouchCenter.x - initialTouchCenterX);
            activeObj.y = initialObjY + (currentTouchCenter.y - initialTouchCenterY);
            drawAll();
        }
    });
    hammertime.on('panend', function() {
        if(isPhotoLocked) saveState(); // デコレーション移動後に履歴保存
    });

    // ピンチ（拡大縮小）ジェスチャー
    hammertime.on('pinchstart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
        // --- ピンチ開始時に必ず基準をリセット ---
        initialObjX = activeObj.x;
        initialObjY = activeObj.y;
        initialObjScale = activeObj.scale;
        initialObjRotation = activeObj.rotation;
            // 軽タッチ（変化が小さい）なら初期値をまだ更新しない
            const scaleDelta = Math.abs(e.scale - 1);
            let scaleThreshold = 0.1;
            let rotationThreshold = 5;

            // activeObj がスタンプなら、もっと大きめのしきい値を設定
            if (activeObj && activeObj.type === 'stamp') {
                scaleThreshold = 0.15;     // 15% 未満なら軽タッチ扱い
                rotationThreshold = 8;     // 8° 未満なら軽タッチ扱い
            }

            if (scaleDelta < scaleThreshold && Math.abs(e.rotation) < rotationThreshold) {
                return; // 軽タッチ扱い
            }

            const touchCenter = getCanvasCoords(e.center.x, e.center.y);
            initialTouchCenterX = touchCenter.x;
            initialTouchCenterY = touchCenter.y;

            initialObjX = activeObj.x;
            initialObjY = activeObj.y;
            initialObjScale = activeObj.scale;
            initialObjRotation = activeObj.rotation;

            // オブジェクトの中心からタッチ中心への初期ベクトル (キャンバス座標系)
            initialVecOffsetX = initialTouchCenterX - initialObjX;
            initialVecOffsetY = initialTouchCenterY - initialObjY;
        }
    });
    
    // --- ここに追加する ---
    // スケールの範囲を制限する関数
    function clampScale(s) {
      const MIN = 0.1;   // 最小 10%
      const MAX = 10;    // 最大 10倍
      return Math.min(MAX, Math.max(MIN, s));
    }
    // --- ここまで追加 ---

    hammertime.on('pinch', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            // スケールだけ更新
            const newScale = clampScale(initialObjScale * e.scale);
            activeObj.scale = newScale;

            // 回転だけ更新
            activeObj.rotation = initialObjRotation + (e.rotation * Math.PI / 180);

            // 位置 (x, y) は変更しない → ズレ防止
            drawAll();
        }
    });

    hammertime.on('pinchend', function(e) {
        // 最後に計算した状態を確定させる
        initialObjX = photoObject.x;
        initialObjY = photoObject.y;
        initialObjScale = photoObject.scale;
        initialObjRotation = photoObject.rotation;

        if (isPhotoLocked) saveState();
    });


    // --- PC向けマウスイベントハンドリング ---
    let isDragging = false; // ドラッグ中かどうかのフラグ
    let lastPos = { x: 0, y: 0 }; // 前回のマウス位置 (クライアント座標)
    let dragTarget = null; // 'photo', 'decoration', 'rotate-photo', 'rotate-decoration'

    mainCanvas.addEventListener('mousedown', function(e) {
      const p = getCanvasCoords(e.clientX, e.clientY); // クリック位置をキャンバス座標に変換
      isDragging = true;
      lastPos = { x: e.clientX, y: e.clientY }; // クライアント座標を保存

      if (e.button === 0) { // 左クリック（移動）
        if (!isPhotoLocked) {
          dragTarget = 'photo';
        } else {
          selectedObject = null; // まず選択を解除
          // デコレーションを逆順で探し、一番手前のものを選択
          for (let i = decorationObjects.length - 1; i >= 0; i--) {
            const obj = decorationObjects[i];
            if (isPointInObject(p, obj)) {
              selectedObject = obj;
            // 追加：選択内容で詳細パネルを自動オープン
              if (selectedObject && selectedObject.type === 'text') {
                showPanel('panel-text');
              } else {
                showPanel('panel-arrange');
              }


              dragTarget = 'decoration';
              break;
            }
          }
          // 追加：何も選べなかった場合は閉じる
          if (!selectedObject) {
            hidePanels();
          }

        }
      } else if (e.button === 2) { // 右クリック（回転）
        if (!isPhotoLocked) {
          dragTarget = 'rotate-photo';
        } else if (selectedObject) {
          dragTarget = 'rotate-decoration';
        }
      }
      drawAll();
    });

    mainCanvas.addEventListener('mousemove', function(e) {
      if (!isDragging || !dragTarget) return;

      // 移動量をキャンバスの論理ピクセルに変換
      const dx_canvas = (e.clientX - lastPos.x) * (mainCanvas.width / mainCanvas.getBoundingClientRect().width);
      const dy_canvas = (e.clientY - lastPos.y) * (mainCanvas.height / mainCanvas.getBoundingClientRect().height);

      if (dragTarget === 'photo') {
        photoObject.x += dx_canvas;
        photoObject.y += dy_canvas;
      } else if (dragTarget === 'decoration' && selectedObject) {
        selectedObject.x += dx_canvas;
        selectedObject.y += dy_canvas;
      } else if (dragTarget === 'rotate-photo') {
        photoObject.rotation += dx_canvas * 0.0005; // マウスの横移動量に応じて回転（調整済み）
      } else if (dragTarget === 'rotate-decoration' && selectedObject) {
        selectedObject.rotation += dx_canvas * 0.0005; // マウスの横移動量に応じて回転（調整済み）
      }

      lastPos = { x: e.clientX, y: e.clientY };
      drawAll();
    });

    mainCanvas.addEventListener('mouseup', function(e) {
      isDragging = false;
      dragTarget = null;
      if(isPhotoLocked) saveState(); // デコレーション操作後に履歴保存
    });

    mainCanvas.addEventListener('mouseleave', function() {
      isDragging = false;
      dragTarget = null;
    });

    // 右クリックメニューを無効化
    mainCanvas.addEventListener('contextmenu', e => e.preventDefault());

    // 初期描画
    drawAll();

    // === 「保存→プレビュー」「編集」「右上プレビュー」ボタンのイベント ===
    const toPreviewBtnEl = document.getElementById('toPreviewBtn');
    const toEditBtnEl = document.getElementById('toEditBtn');
    const previewBtnTopRightEl = document.getElementById('previewBtnTopRight');

    if (toPreviewBtnEl) {
      toPreviewBtnEl.addEventListener('click', async () => {
        console.log("✅ 保存→プレビュー ボタンが押されました");
        await showPreviewOverlay();
      });
    }

    if (toEditBtnEl) {
      toEditBtnEl.addEventListener('click', () => {
        console.log("✅ 編集 ボタンが押されました");
        document.getElementById('arrangeControls').style.display = 'none';
        areaDecorations.style.display = 'block';
        document.getElementById('previewBtnTopRight').style.display = 'block';
        document.getElementById('area-decorations').scrollIntoView({ behavior: 'smooth' });
      });
    }

    if (previewBtnTopRightEl) {
      previewBtnTopRightEl.addEventListener('click', async () => {
        console.log("✅ 右上の保存→プレビュー ボタンが押されました");
        await showPreviewOverlay();
      });
    }

    async function showPreviewOverlay() {
      const previewScreen = document.getElementById('previewScreen');
      const previewFullImage = document.getElementById('previewFullImage');
      if (!previewScreen || !previewFullImage) {
        console.error("previewScreen or previewFullImage not found");
        return;
      }

      // 画面上の重なる UI を隠す
      const arrange = document.getElementById('arrangeControls');
      if (arrange) arrange.style.display = 'none';
      if (areaDecorations) areaDecorations.style.display = 'none';

      // ヘルパ（template の filter/opacity を取得）
      function _getTemplateFilterAndOpacity() {
        try {
          const tplEl = document.getElementById('templateOverlay');
          if (tplEl) {
            const cs = window.getComputedStyle(tplEl);
            return { filter: cs.filter || 'none', opacity: parseFloat(cs.opacity || '1') || 1 };
          }
          const editor = document.getElementById('editorWrapper');
          if (editor) {
            const csBefore = window.getComputedStyle(editor, '::before');
            return { filter: csBefore.filter || 'none', opacity: parseFloat(csBefore.opacity || '1') || 1 };
          }
        } catch (e) { /* ignore */ }
        return { filter: 'none', opacity: 1 };
      }

      try {
        // 1) メインの描画を最新化（念のため）
        try { drawAll(); } catch(e) { console.warn('drawAll() failed in preview', e); }

        // 2) 選択枠を一時的に非表示にして mainCanvas の内容を取得
        const prevSel = selectedObject;
        selectedObject = null;
        try { drawAll(); } catch(e) { /* ignore */ } // mainCanvas を選択無しで更新
        // ここで mainCanvas には「写真 + デコレーション（選択枠無し）」が描かれている

        // 3) オフスクリーンキャンバスを作り mainCanvas をコピー → その上にテンプレート（filter反映）を合成
        const tmp = document.createElement('canvas');
        tmp.width = mainCanvas.width;
        tmp.height = mainCanvas.height;
        const tctx = tmp.getContext('2d');
        // main の内容をコピー
        tctx.drawImage(mainCanvas, 0, 0);

        // テンプレート画像を取得（プリロード済みならそれを使う）
        let tplImg = templateCache[templateSelector.value];
        if (!tplImg) {
          tplImg = new Image();
          tplImg.src = templateSelector.value;
          try { if (tplImg.decode) await tplImg.decode(); } catch(e){/*ignore*/ }
        } else {
          try { if (tplImg.decode) await tplImg.decode(); } catch(e){/*ignore*/ }
        }

        // テンプレートの filter/opacity を反映して描画
        const tplStyle = _getTemplateFilterAndOpacity();
        try {
          if (tplStyle.filter && tplStyle.filter !== 'none') tctx.filter = tplStyle.filter;
          tctx.globalAlpha = tplStyle.opacity;
        } catch (e) { /* ignore */ }
        tctx.drawImage(tplImg, 0, 0, tmp.width, tmp.height);
        tctx.filter = 'none';
        tctx.globalAlpha = 1;

        // 4) 生成した合成を DataURL にしてプレビュー表示
        const dataUrl = tmp.toDataURL('image/png');
        previewFullImage.src = dataUrl;
        previewFullImage.alt = '合成プレビュー（長押しで保存）';

        // 5) UI 表示
        previewScreen.style.display = 'flex';
        previewScreen.onclick = function(e) {
          if (e.target === previewScreen) previewScreen.style.display = 'none';
        };
      } catch (err) {
        console.error('preview canvas toDataURL error:', err);
        previewFullImage.src = '';
        previewFullImage.alt = 'プレビューエラー';
      } finally {
        // 選択を復元して編集画面を元に戻す
        selectedObject = (typeof prevSel !== 'undefined') ? prevSel : null;
        try { drawAll(); } catch(e) { /* ignore */ } // 元の UI を再描画
      }
    }

    // --- 裏面も作るボタンの処理 ---
    document.getElementById('makeBackBtn').addEventListener('click', () => {
      backSideCreated = true; // 裏面を作り始めたらフラグON
      console.log("✅ 裏面を作るボタン押下 → backSideCreated = true");
      // 裏面用の処理（すでにある処理をここに書く）
    });

    // --- プレビュー閉じる処理 ---
    document.getElementById('previewCloseBtn').addEventListener('click', () => {
      console.log("✅ 閉じるボタン押された"); // デバッグ確認用

      // プレビューオーバーレイを閉じる
      const previewScreen = document.getElementById('previewScreen');
      if (previewScreen) previewScreen.style.display = "none";

      // 完成領域（#area-result）を表示して、その中のボタンを見えるようにする
      const areaResult = document.getElementById('area-result');
      if (areaResult) areaResult.style.display = "block";

      const backBtn = document.getElementById('makeBackBtn');
      const orderBtn = document.getElementById('goToOrderFormBtn');
      const orderNote = document.getElementById('orderNote');

      console.log("取得した要素:", backBtn, orderBtn, orderNote);

      // まだ裏面を作っていないときだけ「裏面も作る」を表示
      if (!backSideCreated && backBtn) backBtn.style.display = "block";

      // 注文フォームボタンと注釈は常に表示
      if (orderBtn) orderBtn.style.display = "block";
      if (orderNote) orderNote.style.display = "block";

      // 編集サイドメニューは閉じる（UI整理）
      const arrange = document.getElementById('arrangeControls');
      if (arrange) arrange.style.display = "none";
    });
  </script>
    <!-- 初回ガイドモーダル -->
    <div id="firstGuide" class="guide-overlay" style="display:none;">
      <div class="guide-content">
        <h2>📖 使い方ガイド</h2>
        <ol>
          <li><b>背景を決める</b><br>
              写真を選ぶか、メンバーカラー（背景色）を指定します。</li>
          <li><b>写真を選んだ場合</b><br>
              アップロード後に指で位置やサイズ・角度を調整します。</li>
          <li><b>写真だけでもOK</b><br>
              写真だけを配置して、そのままプレビューへ進めます。</li>
          <li><b>文字やスタンプでデコレーション</b><br>
              好きなフォントでメッセージを入れたり、スタンプを配置できます。</li>
          <li><b>プレビュー画像を保存</b><br>
              「決定 → プレビュー」で表示し、長押しして保存してください。</li>
          <li><b>裏面を作成 or 注文</b><br>
              裏面を作る場合は「裏面も作る」を選択。<br>
              完成した画像を保存したら「注文フォームへ進む」から申し込めます。</li>
        </ol>
        <button id="guideCloseBtn" class="form-button">OK</button>
      </div>
    </div>
</body>
</html>