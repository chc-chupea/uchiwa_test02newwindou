<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Myうちわ - デコレーション</title>
  <!-- 推し活にぴったりなフォントを読み込み -->
  <link href="https://fonts.googleapis.com/css2?family=Cherry+Bomb+One&family=DotGothic16&family=Kaisei+Tokumin&family=Train+One&display=swap" rel="stylesheet">
  <style>
    /* 全体的なスタイル */
    body {
      font-family: 'Arial', sans-serif; /* 基本フォント設定 */
      text-align: center;
      background: linear-gradient(135deg, #f0f7ff, #eaf6ff); /* 背景グラデーション */
      margin: 0;
      padding: 10px;
      color: #333;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 20px;
      color: #1565c0;
    }
    .area {
      background: #fff; /* 白い背景のカード */
      border-radius: 20px; /* 角丸 */
      padding: 16px;
      margin-bottom: 16px; /* 間隔を少し詰める */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* 影 */
    }
    .area h2 {
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 12px;
      color: #1565c0;
    }

    /* エディタ（キャンバス）のラッパー */
    #editorWrapper {
      position: relative;
      width: 100%;
      max-width: 900px; /* 最大幅 */
      aspect-ratio: 4 / 3; /* アスペクト比を固定 */
      margin: 0 auto;
      background-color: #f9f9f9;
      overflow: hidden;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    /* メインキャンバスとオーバーレイキャンバス */
    #mainCanvas, #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none; /* タッチイベントのデフォルト動作を無効化 */
    }
    /* うちわテンプレート画像（低解像度版） */
    #templateOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* クリックイベントを透過 */
      object-fit: contain; /* アスペクト比を保ちつつ要素内に収める */
    }

    /* フォーム要素の共通スタイル */
    select, input[type="text"], input[type="color"], button, label {
      display: block;
      width: 100%;
      margin: 10px 0;
      padding: 12px;
      border-radius: 12px;
      font-size: 16px;
      border: 1px solid #ccc;
      background: #fff;
      box-sizing: border-box;
    }
    /* ボタンの共通スタイル */
    button {
      background: #4cafef;
      color: white;
      font-size: 16px;
      padding: 12px 24px;
      border-radius: 30px;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s, background 0.3s; /* ホバー時のアニメーション */
    }
    button:hover {
      background: #2196f3;
      transform: translateY(-2px);
    }
    /* ファイル選択ボタンのカスタムスタイル */
    #customFileLabel {
      background: linear-gradient(135deg, #4cafef, #2196f3);
      color: #fff;
      border-radius: 30px;
      padding: 14px 26px;
      cursor: pointer;
      font-size: 16px;
      transition: 0.3s;
      display: inline-block; /* ボタンのように表示 */
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
    }
    #customFileLabel:hover {
      background: linear-gradient(135deg, #42a5f5, #1e88e5);
      transform: scale(1.05);
    }
    /* フォームへ進むボタンのスタイル */
    .form-button {
      background: linear-gradient(135deg, #2196f3, #1976d2);
      color: white;
      padding: 12px 24px;
      margin-top: 20px;
      text-decoration: none;
      font-weight: bold;
      font-size: 18px;
      border-radius: 30px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      display: block;
      width: auto; /* コンテンツに合わせて幅を調整 */
      margin-left: auto;
      margin-right: auto;
    }
    .form-button:hover {
      background: linear-gradient(135deg, #1976d2, #0d47a1);
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
    }
    /* プレビュー画像のスタイル */
    #previewWrapper img {
      max-width: 100%;
      border: 6px solid #fff;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      margin-top: 12px;
    }
    /* 選択中のオブジェクトの枠線 */
    .active-object-outline {
      outline: 2px dashed #42a5f5; /* 点線で表示 */
      outline-offset: 5px; /* 要素からのオフセット */
    }
    /* エディタの初期背景（うちわの形状）*/
    #editorWrapper::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url(fan1-lowres.png) no-repeat center center / contain; /* デフォルトうちわの形 */
      pointer-events: none;
      opacity: 0.5; /* 半透明 */
    }

    /* スタンプボタン専用スタイル */
    .stamp-buttons-container {
      display: flex;
      flex-wrap: wrap;
      gap: 5px; /* ボタン間の隙間を均一に */
      justify-content: center;
      margin-top: 8px; /* スタンプエリアの上マージンを調整 */
      margin-bottom: 8px; /* スタンプエリアの下マージンを調整 */
    }
    .stamp-buttons-container .stamp-button {
      width: auto; /* コンテンツに合わせて幅を調整 */
      min-width: 45px; /* 最低幅を確保し、タッチしやすくする */
      padding: 8px 12px; /* パディングを調整 */
      font-size: 24px; /* 絵文字のサイズを大きく */
      display: inline-flex; /* flexアイテムとして表示し、中央揃え */
      align-items: center;
      justify-content: center;
      height: 45px; /* ボタンの高さを固定 */
      margin: 0; /* flex containerでgapを指定するため、個別のmarginをリセット */
      box-shadow: 0 2px 4px rgba(0,0,0,0.15); /* 影を少し控えめに */
    }

    .stamp-buttons-container .stamp-button img {
        height: 30px; /* 画像スタンプのサイズを調整 */
        vertical-align: middle; /* 垂直方向中央揃え */
    }

    /* メンバーカラー用カラーピッカーの背景色 */
    #backgroundColorPicker {
        background-color: #ffe6f2; /* 薄いピンク色 */
    }

    /* 自由テキスト用カラーピッカーの背景色 */
    #colorPicker {
        background-color: #ffe6f2; /* 薄いピンク色 */
    }

    /* 編集ツールボタンのレイアウト調整 */
    .edit-tools-container {
      display: flex;
      flex-wrap: wrap;
      gap: 3px; /* ボタン間の隙間をさらに詰める */
      justify-content: center;
      margin-top: 8px; /* 編集ツールエリアの上マージンを維持 */
    }
    .edit-tools-container button {
        flex: 0 0 auto; /* 固定幅にせず、内容に合わせて伸縮 */
        padding: 6px 10px; /* パディングをさらに小さく */
        font-size: 13px; /* フォントサイズをさらに小さく */
        margin: 0; /* flex containerでgapを指定するため、個別のmarginをリセット */
        min-width: 60px; /* 最低幅を調整 */
    }

    /* 自由テキスト入力エリア内の要素の間隔調整 */
    #customText {
      margin-bottom: 8px; /* 自由テキスト入力の下マージン */
      padding: 10px; /* パディングも少し小さく */
    }
    #area-decorations > h3:nth-of-type(1) + input[type="text"] + div { /* 自由テキストのカラーピッカーとフォントピッカーを含むdiv */
      margin-top: 8px;
      margin-bottom: 8px;
    }
    #area-decorations button[onclick="addTextToOverlay()"] {
      margin-top: 8px; /* テキスト追加ボタンの上マージン */
      margin-bottom: 16px; /* 次のセクションへのマージン */
    }

    /* うちわのデザイン選択ラベルから縁の線をなくす */
    #templateLabel {
        border: none;
        outline: none;
    }
  </style>
</head>
<body>

  <h1 id="title">Myうちわ</h1>

  <div class="area" id="area-select">
    <h2 id="section1-title">1) 背景を決める</h2>
    <label id="templateLabel">うちわのデザインフィルターを選んでね👇</label>
    <select id="templateSelector">
      <option value="fan1-highres.png" data-lowres="fan1-lowres.png">無地</option>
      <option value="fan2-highres.png" data-lowres="fan2-lowres.png">夏祭り①</option>
      <option value="fan3-highres.png" data-lowres="fan3-lowres.png">夏祭り②</option>
    </select>
    <label for="imageLoader" id="customFileLabel">写真で背景を作る</label>
    <input type="file" id="imageLoader" accept="image/*" style="display:none;" />
    <p id="reuploadNotice" style="font-size: 12px; color: #666;">※ 画像は何度でも選び直せます。</p>

    <h3 style="margin-top: 20px;">メンバーカラーで背景を作る</h3>
    <input type="color" id="backgroundColorPicker" value="#ff8fff" title="背景色選択" />
  </div>

  <div class="area" id="area-canvas">
    <h2 id="section2-title">2) デザイン編集スペース</h2>
    <div id="editorWrapper">
      <canvas id="mainCanvas" width="3508" height="2480"></canvas>
      <img id="templateOverlay" src="fan1-lowres.png" alt="うちわテンプレート">
    </div>
    <p id="editNotice" style="font-size: 12px; color: #666; margin-top: 10px;">
      ※ 画像は1本の指で位置を動かせます。2本の指で大きさや向きを変えることができます。
    </p>
    <button id="confirmPhotoBtn" style="margin-top: 10px;">写真の配置を確定</button>
    <button id="reEditPhotoBtn" style="margin-top: 10px; display: none;">写真の再編集</button>
  </div>

  <div class="area" id="area-decorations" style="display: none;">
    <h2 id="section3-title">3) デコレーション</h2>
    <p id="decorationNotice" style="font-size: 12px; color: #666;">
      ※ オブジェクトをタップすると選択され、移動・サイズ変更・回転できます。
    </p>

    <!-- 自由テキスト入力エリア -->
    <input type="text" id="customText" placeholder="推しへのメッセージ♡" />
    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
      <input type="color" id="colorPicker" value="#ff69b4" title="文字色選択" style="width: 50px;" />
      <div style="display: flex; flex-direction: column; align-items: stretch; flex: 1;">
        <select id="fontPicker" style="flex: 1;"></select>
        <span id="fontPreview" style="font-size: 20px; text-align: center; margin-top: 5px; padding: 5px; border: 1px dashed #ccc; border-radius: 8px;">文字のプレビュー</span>
      </div>
    </div>

    <button onclick="addTextToOverlay()">テキスト追加</button>

    <!-- スタンプ（絵文字・PNG）エリア -->
    <h3>スタンプ</h3>
    <div class="stamp-buttons-container">
      <button class="stamp-button" onclick="addStamp('❤️')">❤️</button>
      <button class="stamp-button" onclick="addStamp('⭐')">⭐</button>
      <button class="stamp-button" onclick="addStamp('🎶')">🎶</button>
      <button class="stamp-button" onclick="addStamp('01loveu.png')">
        <img src="01loveu.png" alt="Love You">
      </button>
      <button class="stamp-button" onclick="addStamp('02ntwithFace.png')">
        <img src="02ntwithFace.png" alt="NT with Face">
      </button>
      <button class="stamp-button" onclick="addStamp('03eyestome.png')">
        <img src="03eyestome.png" alt="Eyes to me">
      </button>
      <button class="stamp-button" onclick="addStamp('04getmyheart.png')">
        <img src="04getmyheart.png" alt="Get my heart">
      </button>
    </div>
    
    <!-- 編集コントロールボタンエリア -->
    <div class="edit-tools-container">
      <button id="selectBtn">選択切替</button>
      <button id="undoBtn">戻る</button>
      <button id="redoBtn">やり直し</button>
      <button id="duplicateBtn">複製</button>
      <button id="deleteBtn" style="background: #f44336;">削除</button>
      <button id="sendBackwardBtn">背面へ</button>
      <button id="bringForwardBtn">前面へ</button>
    </div>

    <!-- 「決定 → プレビュー」ボタンをデコレーションエリア内に移動 -->
    <button id="generateBtn" class="form-button" style="margin-top: 20px;">決定 → プレビュー</button>
  </div>

  <div class="area" id="area-result" style="display: none;">
    <h2 id="section4-title">4) 完成イメージ</h2>
    <div id="previewWrapper">
      <img id="previewImage" alt="合成画像プレビュー" />
    </div>
    <div id="previewNotice" style="font-size:14px; color:black; margin-top:10px;"></div>
    <!-- 「注文フォームへ進む」ボタンはここに残し、JavaScriptで表示制御 -->
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSf1wV724Vnag4FCcjeU1z-3vaCcfhCjAvGyU8432bu8dyciow/viewform?usp=dialog"
       target="_blank"
       class="form-button"
       id="goToOrderFormBtn"
       style="display: none;">📝 注文フォームへ進む</a>
  </div>

  <footer style="font-size: 6px; color: #888; margin-top: 20px;">
    © 2025 Chugoku Shimbun Hanbai Center. Web application developed by Hitomi Sasaki. All rights reserved.<br />
    このウェブアプリケーションは、株式会社中国新聞販売センターの従業員による地域イベント向けの自主開発プロジェクトです。<br />
    ※本アプリは公式サービスではありませんが、業務との親和性を考慮して使用されています。
  </footer>

  <!-- Hammer.jsを読み込み：タッチジェスチャーをよりスムーズにするため -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script>
    // DOM要素の取得

    const fontOptions = [
        { value: 'Arial, sans-serif', text: 'Arial' },
        { value: "'DotGothic16', sans-serif", text: 'ドットゴシック' },
        { value: "'Train One', cursive", text: 'Train One' },
        { value: "'Cherry Bomb One', cursive", text: '手書き風' },
        { value: "'Kaisei Tokumin', serif", text: '丸文字' }
    ];
    
    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d');
    const templateOverlay = document.getElementById('templateOverlay');
    const imageLoader = document.getElementById('imageLoader');
    const templateSelector = document.getElementById('templateSelector');
    const confirmPhotoBtn = document.getElementById('confirmPhotoBtn');
    const reEditPhotoBtn = document.getElementById('reEditPhotoBtn');
    const generateBtn = document.getElementById('generateBtn');
    const goToOrderFormBtn = document.getElementById('goToOrderFormBtn');
    const customText = document.getElementById('customText');
    const colorPicker = document.getElementById('colorPicker');
    const fontPicker = document.getElementById('fontPicker');
    const fontPreview = document.getElementById('fontPreview'); // ★この行を追加
    const previewWrapper = document.getElementById('previewWrapper');
    const previewImage = document.getElementById('previewImage');
    const previewNotice = document.getElementById('previewNotice');
    const areaDecorations = document.getElementById('area-decorations');
    const areaResult = document.getElementById('area-result');
    // 追加: 背景色ピッカーの取得
    const backgroundColorPicker = document.getElementById('backgroundColorPicker');

    // 状態変数
    let uploadedImg = null;
    let photoObject = null;
    let isPhotoLocked = false;
    let decorationObjects = [];
    let selectedObject = null;
    let history = [];
    let historyIndex = -1;
    // 追加: 背景色を保持する変数
    let backgroundColor = '#ffffff'; // デフォルトは白

    // ジェスチャー開始時のオブジェクトの状態とタッチ中心
    var initialObjX, initialObjY, initialObjScale, initialObjRotation;
    var initialTouchCenterX, initialTouchCenterY;
    // オブジェクトの中心からタッチ中心への初期ベクトル（キャンバス座標系）
    var initialVecOffsetX, initialVecOffsetY; 

    // ★ ステップ3: 初期化関数を追加
      function initializeFontPicker() {
        fontPicker.innerHTML = '';
        fontOptions.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value;
            optionElement.textContent = option.text;
            fontPicker.appendChild(optionElement);
        });
        updateFontPreview();
      }

      // ★ ステップ4: プレビュー更新関数を追加
      function updateFontPreview() {
        const selectedValue = fontPicker.value;
        const selectedText = fontPicker.options[fontPicker.selectedIndex].textContent;
        fontPreview.style.fontFamily = selectedValue;
        fontPreview.textContent = `文字のプレビュー：${selectedText}`;
        if (selectedObject && selectedObject.type === 'text') {
          selectedObject.fontFamily = selectedValue;
          drawAll();
        }
      }

      // ★ ステップ5: 新しいイベントリスナーを追加
      fontPicker.addEventListener('change', updateFontPreview);
      window.addEventListener('load', initializeFontPicker);
  
      // ... (他のイベントリスナーや既存のコード) ...
      // colorPickerのイベントリスナーはそのまま残す
      colorPicker.addEventListener('input', (e) => {
        e.target.style.backgroundColor = e.target.value;
        if (selectedObject && selectedObject.type === 'text') {
          selectedObject.color = colorPicker.value;
          drawAll(); 
        }
      });


    // --- 履歴管理機能 ---
    /**
     * 現在のデコレーションオブジェクトの状態を履歴に保存します。
     */
    function saveState() {
      // 現在のインデックス以降の履歴を削除し、新しい状態を追加
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(JSON.stringify(decorationObjects)); // オブジェクトのディープコピーを保存
      historyIndex++;
    }

    /**
     * 一つ前の編集状態に戻します（アンドゥ）。
     */
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        decorationObjects = JSON.parse(history[historyIndex]); // 履歴から状態を復元
        selectedObject = null; // 選択状態を解除
        drawAll(); // 全体を再描画
      }
    }

    /**
     * 一つ後の編集状態に進みます（リドゥ）。
     */
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        decorationObjects = JSON.parse(history[historyIndex]); // 履歴から状態を復元
        selectedObject = null; // 選択状態を解除
        drawAll(); // 全体を再描画
      }
    }

    // --- 描画機能 ---
    /**
     * 写真をキャンバスに描画します。
     */
    function drawImage() {
      if (!photoObject || !uploadedImg) return;

      ctx.save(); // 現在のキャンバスの状態を保存
      // 写真の中心を基準に移動、回転、拡大縮小
      ctx.translate(photoObject.x, photoObject.y);
      ctx.rotate(photoObject.rotation);
      ctx.scale(photoObject.scale, photoObject.scale);
      // 画像を描画（中心座標が0,0になるようにオフセット）
      ctx.drawImage(uploadedImg, -uploadedImg.width / 2, -uploadedImg.height / 2);
      ctx.restore(); // 保存した状態に戻す
    }

    /**
     * デコレーションオブジェクト（テキスト、スタンプ）をキャンバスに描画します。
     */
    function drawDecorations() {
      decorationObjects.forEach(obj => {
        ctx.save();
        // オブジェクトの中心を基準に移動、回転、拡大縮小
        ctx.translate(obj.x, obj.y);
        ctx.rotate(obj.rotation);
        ctx.scale(obj.scale, obj.scale);

        if (obj.type === 'text') {
          ctx.fillStyle = obj.color;
          // フォントサイズはスケーリング前に設定 (px単位)
          ctx.font = `${obj.fontSize / obj.scale}px ${obj.fontFamily}`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(obj.content, 0, 0);
        } else if (obj.type === 'image') {
          // 画像を描画（中心座標が0,0になるようにオフセット）
          ctx.drawImage(obj.img, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
        }

        // 選択中のオブジェクトに枠線を表示
        if (obj === selectedObject) {
          ctx.strokeStyle = '#42a5f5';
          ctx.lineWidth = 10 / obj.scale; // スケーリングに合わせて線幅を調整
          ctx.setLineDash([20 / obj.scale, 10 / obj.scale]); // スケーリングに合わせて点線の間隔を調整
          // オブジェクトの描画サイズを計算し、枠線を描画
          const rectWidth = obj.type === 'text' ? ctx.measureText(obj.content).width : obj.width;
          const rectHeight = obj.type === 'text' ? obj.fontSize * 1.2 / obj.scale : obj.height; // テキストは行高考慮
          ctx.strokeRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight);
          ctx.setLineDash([]); // 点線モードをリセット
        }

        ctx.restore();
      });
    }

    /**
     * キャンバス全体をクリアし、写真とデコレーションを再描画します。
     */
    function drawAll() {
      // 1. まず背景色で全体を塗りつぶす
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
      // 2. 写真を描画
      drawImage();
      // 3. デコレーションを描画
      drawDecorations();
    }

    /**
     * マウス/タッチイベントのクライアント座標をキャンバス内の論理座標に変換します。
     * @param {number} clientX - イベントのclientX座標
     * @param {number} clientY - イベントのclientY座標
     * @returns {{x: number, y: number}} キャンバス内の座標
     */
    function getCanvasCoords(clientX, clientY) {
      const rect = mainCanvas.getBoundingClientRect(); // キャンバスの画面上での位置とサイズ
      const x = (clientX - rect.left) * (mainCanvas.width / rect.width);
      const y = (clientY - rect.top) * (mainCanvas.height / rect.height);
      return { x, y };
    }

    /**
     * 指定された点がオブジェクトの境界内にあるか判定します。
     * @param {{x: number, y: number}} p - 判定したい点（キャンバス座標）
     * @param {object} obj - 判定対象のオブジェクト
     * @returns {boolean} 点がオブジェクト内にあるか
     */
    function isPointInObject(p, obj) {
      // 1. 点をオブジェクトのローカル座標系に変換する (逆変換)
      // まずオブジェクトの中心を原点に移動
      const translatedX = p.x - obj.x;
      const translatedY = p.y - obj.y;

      // 回転を元に戻す
      const cos = Math.cos(-obj.rotation);
      const sin = Math.sin(-obj.rotation);
      const rotatedX = translatedX * cos - translatedY * sin;
      const rotatedY = translatedX * sin + translatedY * cos;

      // スケールを元に戻す
      const scaledX = rotatedX / obj.scale;
      const scaledY = rotatedY / obj.scale;

      // 2. オブジェクトのローカル座標系での幅と高さを計算
      let objWidth, objHeight;
      if (obj.type === 'text') {
        // テキストの場合、現在のフォント設定でテキストの実際の幅を測定
        ctx.save();
        ctx.font = `${obj.fontSize}px ${obj.fontFamily}`; // オリジナルのフォントサイズで測定
        objWidth = ctx.measureText(obj.content).width;
        objHeight = obj.fontSize * 1.2; // テキストの高さは行高を考慮
        ctx.restore();
      } else if (obj.type === 'image') {
        objWidth = obj.width;
        objHeight = obj.height;
      } else {
          return false; // 未知のタイプ
      }

      const halfObjWidth = objWidth / 2;
      const halfObjHeight = objHeight / 2;

      // 3. 変換された点が、オブジェクトのローカル境界ボックス内にあるか判定
      return scaledX >= -halfObjWidth && scaledX <= halfObjWidth &&
             scaledY >= -halfObjHeight && scaledY <= halfObjHeight;
    }

    // --- イベントリスナー ---
    /**
     * 画像ファイルの読み込み処理
     */
    imageLoader.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        uploadedImg = new Image();
        uploadedImg.onload = () => {
          // 写真オブジェクトの初期位置、スケール、回転を設定
          photoObject = {
            x: mainCanvas.width / 2, // キャンバス中央
            y: mainCanvas.height / 2, // キャンバス中央
            scale: 1,
            rotation: 0
          };

          // ====> ここに以下のコードを追加します <====
      
          // 写真がアップロードされたら背景色を白にリセット
                backgroundColor = '#ffffff'; 
                
          // ====> ここまで <====


          isPhotoLocked = false; // 写真編集を可能にする
          reEditPhotoBtn.style.display = 'none'; // 再編集ボタンは非表示
          confirmPhotoBtn.style.display = 'block'; // 確定ボタンを表示
          areaDecorations.style.display = 'none'; // デコレーションエリアを非表示
          areaResult.style.display = 'none'; // 完成イメージエリアも非表示にリセット
          drawAll(); // 全体を再描画
        };
        uploadedImg.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    /**
     * うちわテンプレートの選択変更処理
     */
    templateSelector.addEventListener('change', e => {
      // 低解像度テンプレートに切り替えて表示
      templateOverlay.src = e.target.selectedOptions[0].dataset.lowres;
    });
    
    // ====> この行の直後に追加 <====

    // 新規追加: 背景色ピッカーの変更イベント
    backgroundColorPicker.addEventListener('input', (e) => {
        backgroundColor = e.target.value; 
        // メンバーカラーピッカーの背景色を、選択された色にリアルタイムで更新
        e.target.style.backgroundColor = e.target.value; 
        uploadedImg = null; 
        photoObject = null;
        isPhotoLocked = true;
        areaDecorations.style.display = 'block'; 
        reEditPhotoBtn.style.display = 'none';
        confirmPhotoBtn.style.display = 'none';
        drawAll(); 
    });

    // ====> ここまで <====



    /**
     * 写真の配置確定ボタンの処理
     */
    confirmPhotoBtn.addEventListener('click', () => {
      if (!uploadedImg) return; // 写真がアップロードされていなければ何もしない
      isPhotoLocked = true; // 写真をロック
      confirmPhotoBtn.style.display = 'none'; // 確定ボタンを非表示
      reEditPhotoBtn.style.display = 'block'; // 再編集ボタンを表示
      areaDecorations.style.display = 'block'; // デコレーションエリアを表示
      document.getElementById('area-decorations').scrollIntoView({ behavior: 'smooth' }); // デコレーションエリアへスクロール
      saveState(); // 最初のデコレーション状態を保存
    });

    /**
     * 写真の再編集ボタンの処理
     */
    reEditPhotoBtn.addEventListener('click', () => {
      isPhotoLocked = false; // 写真のロックを解除
      reEditPhotoBtn.style.display = 'none'; // 再編集ボタンを非表示
      confirmPhotoBtn.style.display = 'block'; // 確定ボタンを表示
      areaDecorations.style.display = 'none'; // デコレーションエリアを非表示
      selectedObject = null; // 選択中のデコレーションオブジェクトを解除
      areaResult.style.display = 'none'; // 完成イメージエリアも非表示にリセット
      drawAll(); // 全体を再描画
    });

    /**
     * 決定 → プレビューボタンの処理
     */
    generateBtn.addEventListener('click', () => {
      // ... 既存のチェックロジック ...

      // 高解像度での最終画像を生成するためのオフスクリーンキャンバス
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = mainCanvas.width;
      tempCanvas.height = mainCanvas.height;
      const tempCtx = tempCanvas.getContext('2d');

      // 1. まず背景色で全体を塗りつぶす
      tempCtx.fillStyle = backgroundColor;
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

      // 2. 写真を描画（存在する場合）
      if (uploadedImg) {
        tempCtx.save();
        tempCtx.translate(photoObject.x, photoObject.y);
        tempCtx.rotate(photoObject.rotation);
        tempCtx.scale(photoObject.scale, photoObject.scale);
        tempCtx.drawImage(uploadedImg, -uploadedImg.width / 2, -uploadedImg.height / 2);
        tempCtx.restore();
      }

      // 3. デコレーションを描画
      decorationObjects.forEach(obj => {
        tempCtx.save();
        tempCtx.translate(obj.x, obj.y);
        tempCtx.rotate(obj.rotation);
        tempCtx.scale(obj.scale, obj.scale);
        if (obj.type === 'text') {
          tempCtx.fillStyle = obj.color;
          // フォントサイズはスケーリング前に設定 (px単位)
          tempCtx.font = `${obj.fontSize / obj.scale}px ${obj.fontFamily}`;
          tempCtx.textAlign = 'center';
          tempCtx.textBaseline = 'middle';
          tempCtx.fillText(obj.content, 0, 0);
        } else if (obj.type === 'image') {
          tempCtx.drawImage(obj.img, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
        }
        tempCtx.restore();
      });

      // 4. 高解像度うちわテンプレートを重ねる
      const templateHighRes = new Image();
      templateHighRes.onload = () => {
        tempCtx.drawImage(templateHighRes, 0, 0, tempCanvas.width, tempCanvas.height);
        previewImage.src = tempCanvas.toDataURL('image/png'); // 完成イメージをDataURLとして設定

        areaResult.style.display = 'block'; // ★ 完成イメージエリア全体を表示
        previewWrapper.style.display = 'block'; // プレビュー表示エリアを表示
        goToOrderFormBtn.style.display = 'block'; // 注文フォームボタンを表示

        // 保存案内メッセージ
        previewNotice.innerHTML = `iPhone：画像を👆長押しして「“写真”に追加」を選んで保存してください。<br>Android：画像を👆長押しして「画像を保存」を選択してください。`;
        areaResult.scrollIntoView({ behavior: 'smooth' }); // 完成イメージエリアへスクロール
      };
      templateHighRes.src = templateSelector.value; // 選択された高解像度テンプレートを読み込む
    });

    // --- デコレーションオブジェクト追加機能 ---
    /**
     * 自由テキストをデコレーションとして追加します。
     */
    function addTextToOverlay() {
      const text = customText.value.trim();
      if (!text) return; // テキストが空なら何もしない
      const newText = {
        id: Date.now(), // 一意なID
        type: 'text',
        content: text,
        x: mainCanvas.width / 2, // キャンバス中央に配置
        y: mainCanvas.height / 2,
        scale: 1,
        rotation: 0,
        color: colorPicker.value,
        fontFamily: fontPicker.value,
        fontSize: 500 // 初期フォントサイズ
      };
      decorationObjects.push(newText); // 配列に追加
      selectedObject = newText; // 追加したものを選択状態にする
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    }

    // PNGステッカー画像を事前に読み込む
    const stampImages = {};
    const pngStickers = ['01loveu.png', '02ntwithFace.png', '03eyestome.png', '04getmyheart.png'];
    pngStickers.forEach(src => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        stampImages[src] = img; // 読み込み完了後、オブジェクトに格納
      };
    });

    /**
     * スタンプ（絵文字またはPNG画像）をデコレーションとして追加します。
     * @param {string} content - 絵文字文字列またはPNG画像ファイル名
     */
    function addStamp(content) {
      let newStamp;
      if (content.endsWith('.png')) {
        const img = stampImages[content];
        if (!img) {
          alert('画像をまだ読み込んでいません。数秒待ってからもう一度お試しください。');
          return; // 画像がまだロードされていなければ処理しない
        }
        newStamp = {
          id: Date.now(),
          type: 'image',
          img: img,
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
          scale: 1,
          rotation: 0,
          width: img.naturalWidth,
          height: img.naturalHeight
        };
        // スタンプの初期サイズを調整（大きすぎる場合を考慮）
        const maxDim = Math.max(newStamp.width, newStamp.height);
        const targetSize = 400; // PNGステッカーの初期サイズ目標
        if (maxDim > targetSize) {
            const scaleFactor = targetSize / maxDim;
            newStamp.width *= scaleFactor;
            newStamp.height *= scaleFactor;
        }
      } else {
        newStamp = {
          id: Date.now(),
          type: 'text', // 絵文字はテキストとして扱う
          content: content,
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
          scale: 1,
          rotation: 0,
          color: 'black', // 絵文字は基本黒色
          fontFamily: 'sans-serif', // 絵文字表示に適したフォント
          fontSize: 500 // 絵文字の初期フォントサイズ
        };
      }
      decorationObjects.push(newStamp); // 配列に追加
      selectedObject = newStamp; // 追加したものを選択状態にする
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    }

    // --- デコレーションオブジェクトの編集コントロール ---
    /**
     * デコレーションオブジェクトの選択を切り替えます。
     */
    document.getElementById('selectBtn').addEventListener('click', () => {
      if (decorationObjects.length === 0) return;
      const currentIndex = decorationObjects.indexOf(selectedObject);
      const nextIndex = (currentIndex + 1) % decorationObjects.length;
      selectedObject = decorationObjects[nextIndex]; // 次のオブジェクトを選択
      drawAll(); // 全体を再描画
    });
    document.getElementById('undoBtn').addEventListener('click', undo); // 戻るボタン
    document.getElementById('redoBtn').addEventListener('click', redo); // やり直しボタン

    /**
     * 選択中のデコレーションオブジェクトを削除します。
     */
    document.getElementById('deleteBtn').addEventListener('click', () => {
      if (!selectedObject) return;
      decorationObjects = decorationObjects.filter(obj => obj !== selectedObject); // 選択中のオブジェクトを除外
      selectedObject = null; // 選択状態を解除
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    });

    /**
     * 選択中のデコレーションオブジェクトを複製します。
     */
    document.getElementById('duplicateBtn').addEventListener('click', () => {
      if (!selectedObject) return;
      const newObj = { ...selectedObject }; // オブジェクトをシャローコピー
      newObj.id = Date.now(); // 新しいIDを割り当てる
      newObj.x += 20; // 少しずらして配置
      newObj.y += 20;
      decorationObjects.push(newObj); // 配列に追加
      selectedObject = newObj; // 複製したものを選択状態にする
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    });

    /**
     * 選択中のデコレーションオブジェクトを背面へ移動します。
     */
    document.getElementById('sendBackwardBtn').addEventListener('click', () => {
      const index = decorationObjects.indexOf(selectedObject);
      if (index > 0) { // 最前面でなければ
        const obj = decorationObjects.splice(index, 1)[0]; // 選択中のオブジェクトを配列から取り出す
        decorationObjects.splice(index - 1, 0, obj); // 一つ前の位置に挿入
        drawAll(); // 全体を再描画
        saveState(); // 状態を履歴に保存
      }
    });

    /**
     * 選択中のデコレーションオブジェクトを前面へ移動します。
     */
    document.getElementById('bringForwardBtn').addEventListener('click', () => {
      const index = decorationObjects.indexOf(selectedObject);
      if (index < decorationObjects.length - 1) { // 最背面でなければ
        const obj = decorationObjects.splice(index, 1)[0]; // 選択中のオブジェクトを配列から取り出す
        decorationObjects.splice(index + 1, 0, obj); // 一つ後の位置に挿入
        drawAll(); // 全体を再描画
        saveState(); // 状態を履歴に保存
      }
    });

    // --- テキストデコレーションのリアルタイム更新 ---
    customText.addEventListener('input', () => {
      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.content = customText.value; // テキスト内容を更新
        drawAll(); // 全体を再描画
      }
    });

    colorPicker.addEventListener('input', (e) => {
      // 自由テキスト用カラーピッカーの背景色を、選択された色にリアルタイムで更新
      e.target.style.backgroundColor = e.target.value;

      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.color = colorPicker.value; // 色を更新
        drawAll(); // 全体を再描画
      }
    });
    fontPicker.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.fontFamily = fontPicker.value; // フォントを更新
        drawAll(); // 全体を再描画
      }
    });

    // --- Hammer.js によるタッチ/マウスジェスチャーハンドリング ---
    const hammertime = new Hammer(mainCanvas);
    hammertime.get('pinch').set({ enable: true });
    hammertime.get('rotate').set({ enable: true });

    // 操作対象のオブジェクトを返すヘルパー関数
    function getActiveObject() {
        if (!isPhotoLocked) {
            return photoObject; // 写真編集中は写真がターゲット
        } else if (selectedObject) {
            return selectedObject; // デコレーション編集中は選択中のデコレーションがターゲット
        }
        return null; // 何も操作対象がない場合
    }

    // タップでデコレーションを選択
    hammertime.on('tap', function(e) {
      if (isPhotoLocked) { // 写真がロックされている場合のみデコレーションを選択
        const p = getCanvasCoords(e.srcEvent.clientX, e.srcEvent.clientY); // タッチ位置をキャンバス座標に変換
        let found = false;
        // Zオーダーを考慮し、配列の最後（最も手前）から逆順に判定
        for (let i = decorationObjects.length - 1; i >= 0; i--) {
          const obj = decorationObjects[i];
          if (isPointInObject(p, obj)) {
            selectedObject = obj; // オブジェクトを選択状態にする
            drawAll(); // 全体を再描画
            found = true;
            break;
          }
        }
        if (!found) { // どのオブジェクトも選択されなかった場合
          selectedObject = null; // 選択状態を解除
          drawAll(); // 全体を再描画
        }
      }
    });

    // パン（移動）ジェスチャー
    hammertime.on('panstart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            initialObjX = activeObj.x;
            initialObjY = activeObj.y;
            // ジェスチャー開始時のタッチ中心点をキャンバス座標で記録
            const touchCenter = getCanvasCoords(e.center.x, e.center.y);
            initialTouchCenterX = touchCenter.x;
            initialTouchCenterY = touchCenter.y;
        }
    });
    hammertime.on('pan', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            // 現在のタッチ中心点をキャンバス座標で取得
            const currentTouchCenter = getCanvasCoords(e.center.x, e.center.y);
            // オブジェクトの新しい位置は、開始時の位置にタッチ中心点の移動量を加算
            activeObj.x = initialObjX + (currentTouchCenter.x - initialTouchCenterX);
            activeObj.y = initialObjY + (currentTouchCenter.y - initialTouchCenterY);
            drawAll();
        }
    });
    hammertime.on('panend', function() {
        if(isPhotoLocked) saveState(); // デコレーション移動後に履歴保存
    });

    // ピンチ（拡大縮小）ジェスチャー
    hammertime.on('pinchstart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            initialObjX = activeObj.x;
            initialObjY = activeObj.y;
            initialObjScale = activeObj.scale;
            initialObjRotation = activeObj.rotation; // 回転も考慮
            const touchCenter = getCanvasCoords(e.center.x, e.center.y);
            initialTouchCenterX = touchCenter.x;
            initialTouchCenterY = touchCenter.y;

            // オブジェクトの中心からタッチ中心への初期ベクトル (キャンバス座標系)
            initialVecOffsetX = initialTouchCenterX - initialObjX;
            initialVecOffsetY = initialTouchCenterY - initialObjY;
        }
    });
    hammertime.on('pinch', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            const currentTouchCenter = getCanvasCoords(e.center.x, e.center.y);
            const newScale = initialObjScale * e.scale;
            // newRotationはpinchイベントにもe.rotationがある場合があるので、それを使うかinitialObjRotationを使用
            // Hammer.jsのe.rotationはジェスチャー開始時からの相対値なので、そのまま利用する
            const currentRotationDelta = e.rotation * Math.PI / 180; // Hammer.jsは度数法なのでラジアンに変換

            // 初期ベクトルを現在のスケール倍率でスケーリング
            const scaledOffsetX = initialVecOffsetX * (newScale / initialObjScale);
            const scaledOffsetY = initialVecOffsetY * (newScale / initialObjScale);

            // スケーリングされたベクトルを回転量の差分で回転
            const cos_rot_delta = Math.cos(currentRotationDelta);
            const sin_rot_delta = Math.sin(currentRotationDelta);

            const transformedOffsetX = scaledOffsetX * cos_rot_delta - scaledOffsetY * sin_rot_delta;
            const transformedOffsetY = scaledOffsetX * sin_rot_delta + scaledOffsetY * cos_rot_delta;

            // 新しいオブジェクトの中心 = 現在のタッチ中心 - (オブジェクトからタッチへの変換済みベクトル)
            activeObj.x = currentTouchCenter.x - transformedOffsetX;
            activeObj.y = currentTouchCenter.y - transformedOffsetY;
            
            activeObj.scale = newScale; // スケールを更新
            activeObj.rotation = initialObjRotation + currentRotationDelta; // 回転を更新 (初期回転 + デルタ)
            drawAll();
        }
    });
    hammertime.on('pinchend', function() {
        if(isPhotoLocked) saveState(); // デコレーション拡大縮小後に履歴保存
    });

    // 回転ジェスチャー
    hammertime.on('rotatestart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            initialObjX = activeObj.x;
            initialObjY = activeObj.y;
            initialObjScale = activeObj.scale; // スケールも考慮
            initialObjRotation = activeObj.rotation;
            const touchCenter = getCanvasCoords(e.center.x, e.center.y);
            initialTouchCenterX = touchCenter.x;
            initialTouchCenterY = touchCenter.y;

            // オブジェクトの中心からタッチ中心への初期ベクトル（キャンバス座標系）
            initialVecOffsetX = initialTouchCenterX - initialObjX;
            initialVecOffsetY = initialTouchCenterY - initialObjY;
        }
    });
    hammertime.on('rotate', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            const currentTouchCenter = getCanvasCoords(e.center.x, e.center.y);
            const newRotation = initialObjRotation + e.rotation * Math.PI / 180; // 新しい回転角度 (ラジアン)
            // scaleコンポーネントはrotateイベントにも含まれる場合があるため、それを使用するかinitialObjScaleを使用
            const currentScale = initialObjScale * (e.scale || 1); // Hammer.jsのe.scaleはジェスチャー開始時からの相対値

            // 初期ベクトルを現在のスケール倍率でスケーリング
            const scaledOffsetX = initialVecOffsetX * (currentScale / initialObjScale);
            const scaledOffsetY = initialVecOffsetY * (currentScale / initialObjScale);

            // スケーリングされたベクトルを回転量の差分で回転
            const rotationDelta = e.rotation * Math.PI / 180; // Hammer.jsのe.rotationはデルタ
            const cos_rot_delta = Math.cos(rotationDelta);
            const sin_rot_delta = Math.sin(rotationDelta);

            const transformedOffsetX = scaledOffsetX * cos_rot_delta - scaledOffsetY * sin_rot_delta;
            const transformedOffsetY = scaledOffsetX * sin_rot_delta + scaledOffsetY * cos_rot_delta;

            // 新しいオブジェクトの中心 = 現在のタッチ中心 - (オブジェクトからタッチへの変換済みベクトル)
            activeObj.x = currentTouchCenter.x - transformedOffsetX;
            activeObj.y = currentTouchCenter.y - transformedOffsetY;
            
            activeObj.rotation = newRotation; // 回転を更新
            activeObj.scale = currentScale; // スケールも更新
            drawAll();
        }
    });
    hammertime.on('rotateend', function() {
        if(isPhotoLocked) saveState(); // デコレーション回転後に履歴保存
    });


    // --- PC向けマウスイベントハンドリング ---
    let isDragging = false; // ドラッグ中かどうかのフラグ
    let lastPos = { x: 0, y: 0 }; // 前回のマウス位置 (クライアント座標)
    let dragTarget = null; // 'photo', 'decoration', 'rotate-photo', 'rotate-decoration'

    mainCanvas.addEventListener('mousedown', function(e) {
      const p = getCanvasCoords(e.clientX, e.clientY); // クリック位置をキャンバス座標に変換
      isDragging = true;
      lastPos = { x: e.clientX, y: e.clientY }; // クライアント座標を保存

      if (e.button === 0) { // 左クリック（移動）
        if (!isPhotoLocked) {
          dragTarget = 'photo';
        } else {
          selectedObject = null; // まず選択を解除
          // デコレーションを逆順で探し、一番手前のものを選択
          for (let i = decorationObjects.length - 1; i >= 0; i--) {
            const obj = decorationObjects[i];
            if (isPointInObject(p, obj)) {
              selectedObject = obj;
              dragTarget = 'decoration';
              break;
            }
          }
        }
      } else if (e.button === 2) { // 右クリック（回転）
        if (!isPhotoLocked) {
          dragTarget = 'rotate-photo';
        } else if (selectedObject) {
          dragTarget = 'rotate-decoration';
        }
      }
      drawAll();
    });

    mainCanvas.addEventListener('mousemove', function(e) {
      if (!isDragging || !dragTarget) return;

      // 移動量をキャンバスの論理ピクセルに変換
      const dx_canvas = (e.clientX - lastPos.x) * (mainCanvas.width / mainCanvas.getBoundingClientRect().width);
      const dy_canvas = (e.clientY - lastPos.y) * (mainCanvas.height / mainCanvas.getBoundingClientRect().height);

      if (dragTarget === 'photo') {
        photoObject.x += dx_canvas;
        photoObject.y += dy_canvas;
      } else if (dragTarget === 'decoration' && selectedObject) {
        selectedObject.x += dx_canvas;
        selectedObject.y += dy_canvas;
      } else if (dragTarget === 'rotate-photo') {
        photoObject.rotation += dx_canvas * 0.0005; // マウスの横移動量に応じて回転（調整済み）
      } else if (dragTarget === 'rotate-decoration' && selectedObject) {
        selectedObject.rotation += dx_canvas * 0.0005; // マウスの横移動量に応じて回転（調整済み）
      }

      lastPos = { x: e.clientX, y: e.clientY };
      drawAll();
    });

    mainCanvas.addEventListener('mouseup', function(e) {
      isDragging = false;
      dragTarget = null;
      if(isPhotoLocked) saveState(); // デコレーション操作後に履歴保存
    });

    mainCanvas.addEventListener('mouseleave', function() {
      isDragging = false;
      dragTarget = null;
    });

    // 右クリックメニューを無効化
    mainCanvas.addEventListener('contextmenu', e => e.preventDefault());

    // 初期描画
    drawAll();
  </script>
</body>
</html>