<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã†ã¡ã‚ãƒ‡ã‚³ã‚¢ãƒ—ãƒª</title>
    <!-- Tailwind CSS CDNã‚’èª­ã¿è¾¼ã¿ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fontsã‚’èª­ã¿è¾¼ã¿ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Mochiy+Pop+P+One&family=Yusei+Magic&family=BIZ+UDGothic:wght@400;700&family=Zen+Old+Mincho:wght@400;700&display=swap" rel="stylesheet">
    <!-- è¿½åŠ ãƒ•ã‚©ãƒ³ãƒˆã®CSSãƒ«ãƒ¼ãƒ«ï¼ˆGoogle Fontsã§æä¾›ã•ã‚Œã¦ã„ãªã„ã‚‚ã®ï¼‰ -->
    <style>
        /* åŸºæœ¬çš„ãªã‚¹ã‚¿ã‚¤ãƒ«ã¨ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* è–„ã„ã‚°ãƒ¬ãƒ¼ã®èƒŒæ™¯ */
            color: #333;
        }
        /* ã‚¢ãƒ—ãƒªå…¨ä½“ã®ã‚³ãƒ³ãƒ†ãƒŠã‚¹ã‚¿ã‚¤ãƒ« */
        .container {
            max-width: 90%;
            margin: 20px auto;
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        /* ãƒ“ãƒ‡ã‚ªã¨ã‚­ãƒ£ãƒ³ãƒã‚¹ã®å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        video, canvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            background-color: #e2e8f0; /* ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼ã‚°ãƒ¬ãƒ¼ */
        }
        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ç‚¹ç·šãƒœãƒ¼ãƒ€ãƒ¼ã‚’è¿½åŠ  */
        canvas {
            border: 2px dashed #94a3b8; /* ã‚¹ãƒ¬ãƒ¼ãƒˆã‚°ãƒ¬ãƒ¼ã®ç‚¹ç·š */
            cursor: grab; /* ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã‚«ãƒ¼ã‚½ãƒ« */
            touch-action: none; /* ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹•ä½œï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãªã©ï¼‰ã‚’ç„¡åŠ¹åŒ– */
        }
        /* ãƒ—ãƒ©ã‚¤ãƒãƒªãƒ¼ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¨å½±ï¼‰ */
        .btn {
            @apply px-6 py-3 rounded-full font-semibold text-white shadow-lg transition duration-300 ease-in-out;
            background-image: linear-gradient(to right, #6366f1, #8b5cf6); /* ç´«ç³»ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
        }
        .btn:hover {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed);
            transform: translateY(-2px); /* ãƒ›ãƒãƒ¼ã§å°‘ã—ä¸Šã«ç§»å‹• */
        }
        /* ã‚»ã‚«ãƒ³ãƒ€ãƒªãƒ¼ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ï¼‰ */
        .btn-secondary {
            @apply bg-gray-500 hover:bg-gray-600;
            background-image: none; /* ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä¸Šæ›¸ã */
        }
        /* å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .input-field {
            @apply w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500;
        }
        /* ã‚¹ã‚¿ãƒ³ãƒ—ãƒœã‚¿ãƒ³å†…ã®ç”»åƒã‚¹ã‚¿ã‚¤ãƒ« */
        .sticker-btn img {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            object-fit: contain;
            transition: transform 0.2s; /* ãƒ›ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        }
        .sticker-btn:hover img {
            transform: scale(1.1); /* ãƒ›ãƒãƒ¼ã§å°‘ã—æ‹¡å¤§ */
        }
        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7); /* åŠé€æ˜ã®é»’èƒŒæ™¯ */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 1.5rem;
            flex-direction: column;
        }
        /* ã‚¹ãƒ”ãƒŠãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4">
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-indigo-700">ã†ã¡ã‚ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ—ãƒª</h1>
        <p class="text-center text-gray-600 mb-6">ã‚«ãƒ¡ãƒ©ã§å†™çœŸã‚’æ’®ã£ã¦ã€è‡ªåˆ†ã ã‘ã®ã‚ªãƒªã‚¸ãƒŠãƒ«ã†ã¡ã‚ã‚’ä½œã‚ã†ï¼</p>

        <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
        <div id="loadingOverlay" class="loading-overlay hidden">
            <div class="spinner mb-4"></div>
            <p>å‡¦ç†ä¸­...</p>
        </div>

        <!-- ã‚«ãƒ¡ãƒ©ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div id="cameraSection" class="w-full flex flex-col items-center mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800">ğŸ“¸ ã‚«ãƒ¡ãƒ©æ’®å½±</h2>
            <video id="video" class="w-full h-80 object-cover" autoplay playsinline></video>
            <button id="captureButton" class="btn mt-4">å†™çœŸæ’®å½±</button>

            <!-- ã‚«ãƒ¡ãƒ©ãŒåˆ©ç”¨ã§ããªã„å ´åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ -->
            <div id="uploadOption" class="w-full mt-6 p-4 border border-dashed border-gray-300 rounded-lg text-center hidden">
                <p class="text-gray-600 mb-3">ã¾ãŸã¯ã€ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰:</p>
                <input type="file" id="imageUpload" accept="image/*" class="hidden">
                <label for="imageUpload" class="btn btn-secondary cursor-pointer inline-block">
                    ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç”»åƒã‚’é¸æŠ
                </label>
            </div>
        </div>

        <!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div id="canvasSection" class="w-full hidden flex flex-col items-center mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800">âœ¨ ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h2>
            <canvas id="photoCanvas" class="w-full" style="max-width: 100%;"></canvas>
            
            <!-- èƒŒæ™¯ç”»åƒã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®è¿½åŠ  -->
            <div class="w-full mt-6">
                <h3 class="text-xl font-medium mb-3 text-gray-700">ğŸ–¼ï¸ èƒŒæ™¯ç”»åƒã‚’è¿½åŠ /å¤‰æ›´</h3>
                <input type="file" id="backgroundImageUpload" accept="image/*" class="hidden">
                <label for="backgroundImageUpload" class="btn btn-secondary cursor-pointer inline-block">
                    èƒŒæ™¯ç”»åƒã‚’é¸æŠ/å¤‰æ›´
                </label>
                <button id="removeBackgroundImageButton" class="btn btn-secondary mt-2 w-full hidden">èƒŒæ™¯ç”»åƒã‚’å‰Šé™¤</button>
            </div>

            <div class="w-full mt-6">
                <h3 class="text-xl font-medium mb-3 text-gray-700">âœï¸ ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿½åŠ </h3>
                <input type="text" id="textInput" placeholder="ã“ã“ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›" class="input-field mb-2">
                <div class="flex items-center mb-2 flex-wrap"> <!-- Flex container for color picker, font size, and new font family select -->
                    <input type="color" id="textColorPicker" value="#000000" class="w-16 h-10 border-none rounded-md cursor-pointer mr-2 mb-2 md:mb-0">
                    <select id="fontSizeSelect" class="input-field w-24 mr-2 mb-2 md:mb-0">
                        <option value="48">å°</option>
                        <option value="72">ä¸­</option>
                        <option value="96" selected>å¤§</option>
                        <option value="120">ç‰¹å¤§</option>
                    </select>
                    <select id="fontFamilySelect" class="input-field flex-1 min-w-[150px]">
                        <option value="Inter, sans-serif" style="font-family: 'Inter', sans-serif;">æ¨™æº–</option>
                        <option value="'Mochiy Pop P One', cursive" style="font-family: 'Mochiy Pop P One', cursive;">ã‚‚ã¡ã‚‚ã¡ãƒãƒƒãƒ—</option>
                        <option value="'Yusei Magic', sans-serif" style="font-family: 'Yusei Magic', sans-serif;">éŠæ˜Ÿãƒã‚¸ãƒƒã‚¯</option>
                        <option value="'BIZ UD Gothic', sans-serif" style="font-family: 'BIZ UD Gothic', sans-serif;">BIZ UDã‚´ã‚·ãƒƒã‚¯</option>
                        <option value="'Zen Old Mincho', serif" style="font-family: 'Zen Old Mincho', serif;">Zen Old Mincho</option>
                        <!-- UD Digi Kyokasho NK-B, Soukou Mincho, Kouzan Brush Font ã¯ Google Fonts ã«ç›´æ¥URLãŒãªã„ãŸã‚ã€ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆURLã‚’åˆ¥é€”ç”¨æ„ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ -->
                    </select>
                </div>
                <!-- ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³è¨­å®šã®è¿½åŠ  -->
                <div class="flex items-center mb-2 flex-wrap mt-2">
                    <span class="text-gray-700 mr-2">ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³:</span>
                    <input type="color" id="outlineColorPicker" value="#ffffff" class="w-16 h-10 border-none rounded-md cursor-pointer mr-2 mb-2 md:mb-0">
                    <input type="number" id="outlineWidthInput" value="5" min="0" max="20" class="input-field w-24 mr-2 mb-2 md:mb-0">
                    <span class="text-gray-700">px</span>
                </div>
                <button id="addTextButton" class="btn btn-secondary mt-2 w-full">ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ </button>
            </div>

            <div class="w-full mt-6">
                <h3 class="text-xl font-medium mb-3 text-gray-700">ğŸ˜„ çµµæ–‡å­—ã‚’è¿½åŠ </h3>
                <div id="emojiContainer" class="flex flex-wrap gap-2 justify-center">
                    <!-- çµµæ–‡å­—ã¯JavaScriptã§å‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
                </div>
            </div>

            <div class="w-full mt-6">
                <h3 class="text-xl font-medium mb-3 text-gray-700">â­ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¿½åŠ </h3>
                <div id="stickerContainer" class="flex flex-wrap gap-2 justify-center">
                    <!-- ã‚¹ã‚¿ãƒ³ãƒ—ã¯JavaScriptã§å‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
                </div>
            </div>

            <div class="w-full flex justify-center gap-4 mt-8">
                <button id="undoButton" class="btn btn-secondary flex-1" disabled>å…ƒã«æˆ»ã™</button>
                <button id="redoButton" class="btn btn-secondary flex-1" disabled>ã‚„ã‚Šç›´ã™</button>
                <button id="duplicateButton" class="btn flex-1" disabled>è¤‡è£½</button>
                <button id="deleteButton" class="btn btn-secondary flex-1" disabled>å‰Šé™¤</button>
            </div>
            <!-- æ–°ã—ãè¿½åŠ ã™ã‚‹ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œãƒœã‚¿ãƒ³ -->
            <div class="w-full flex justify-center gap-4 mt-4">
                <button id="bringToFrontButton" class="btn flex-1" disabled>æœ€å‰é¢ã¸</button>
                <button id="sendToBackButton" class="btn btn-secondary flex-1" disabled>æœ€èƒŒé¢ã¸</button>
                <button id="bringForwardButton" class="btn flex-1" disabled>ä¸€ã¤å‰é¢ã¸</button>
                <button id="sendBackwardButton" class="btn btn-secondary flex-1" disabled>ä¸€ã¤èƒŒé¢ã¸</button>
            </div>

            <button id="saveButton" class="btn mt-4 w-full">ã†ã¡ã‚ç”»åƒã‚’ä¿å­˜</button>
            <p class="text-sm text-gray-500 mt-2 text-center">â€»ã‚¹ãƒãƒ›ã®å ´åˆã¯ç”»åƒã‚’é•·æŠ¼ã—ã§ä¿å­˜ã§ãã¾ã™ã€‚</p>
            
            <a id="googleFormLink" href="https://docs.google.com/forms/d/e/1FAIpQLSf1wV724Vnag4FCcjeU1z-3vaCcfhCjAvGyU8432bu8dyciow/viewform" target="_blank" class="btn bg-green-500 hover:bg-green-600 mt-4 w-full" style="background-image: none;">
                ğŸ“¤ Googleãƒ•ã‚©ãƒ¼ãƒ ã§é€ä¿¡
            </a>
            <p class="text-sm text-gray-500 mt-2 text-center">â€»ãƒ•ã‚©ãƒ¼ãƒ ã«ç§»å‹•å¾Œã€ä¿å­˜ã—ãŸç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚</p>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const captureButton = document.getElementById('captureButton');
        const photoCanvas = document.getElementById('photoCanvas');
        const ctx = photoCanvas.getContext('2d');
        const cameraSection = document.getElementById('cameraSection');
        const canvasSection = document.getElementById('canvasSection');
        const saveButton = document.getElementById('saveButton');
        const googleFormLink = document.getElementById('googleFormLink');
        const textInput = document.getElementById('textInput');
        const textColorPicker = document.getElementById('textColorPicker');
        const fontSizeSelect = document.getElementById('fontSizeSelect');
        const fontFamilySelect = document.getElementById('fontFamilySelect');
        const outlineColorPicker = document.getElementById('outlineColorPicker');
        const outlineWidthInput = document.getElementById('outlineWidthInput');
        const addTextButton = document.getElementById('addTextButton');
        const emojiContainer = document.getElementById('emojiContainer');
        const stickerContainer = document.getElementById('stickerContainer');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const imageUpload = document.getElementById('imageUpload');
        const uploadOption = document.getElementById('uploadOption');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton'); 
        const duplicateButton = document.getElementById('duplicateButton');
        const deleteButton = document.getElementById('deleteButton');
        const bringToFrontButton = document.getElementById('bringToFrontButton');
        const sendToBackButton = document.getElementById('sendToBackButton');
        const bringForwardButton = document.getElementById('bringForwardButton');
        const sendBackwardButton = document.getElementById('sendBackwardButton'); 

        // èƒŒæ™¯ç”»åƒé–¢é€£
        const backgroundImageUpload = document.getElementById('backgroundImageUpload');
        const removeBackgroundImageButton = document.getElementById('removeBackgroundImageButton');

        let stream;
        let uchiwaTemplateImage = new Image(); // ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒ
        let backgroundImage = null; // ã†ã¡ã‚ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®ä¸‹ã«ãã‚‹ç”»åƒ (ã‚«ãƒ¡ãƒ©æ’®å½± or ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰)
        let decorations = []; // ãƒ†ã‚­ã‚¹ãƒˆã€çµµæ–‡å­—ã€ã‚¹ã‚¿ãƒ³ãƒ—ãªã©ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        let selectedDecoration = null; // ç¾åœ¨é¸æŠä¸­ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¾ãŸã¯èƒŒæ™¯ç”»åƒ
        let interactionState = { type: 'none', handle: null }; // ãƒ‰ãƒ©ãƒƒã‚°ã€ãƒªã‚µã‚¤ã‚ºã€å›è»¢ã®çŠ¶æ…‹
        let startX, startY; // æ“ä½œé–‹å§‹æ™‚ã®åº§æ¨™ (ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹ç”¨)
        let dragOffsetX, dragOffsetY; // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ

        // ã‚¿ãƒƒãƒæ“ä½œç”¨ã®å¤‰æ•° (2æœ¬æŒ‡ç”¨)
        let startTouchDist = null; // 2æœ¬æŒ‡é–“ã®åˆæœŸè·é›¢ (ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼é–‹å§‹æ™‚ã®ã¿è¨­å®š)
        let initialTouchAngle = null; // 2æœ¬æŒ‡é–“ã®åˆæœŸè§’åº¦ (ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼é–‹å§‹æ™‚ã®ã¿è¨­å®š)
        let startTouchMidpoint = { x: 0, y: 0 }; // 2æœ¬æŒ‡ã®ä¸­é–“ç‚¹ã®åˆæœŸä½ç½® (Canvasåº§æ¨™)

        // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æ“ä½œé–‹å§‹æ™‚ã®çŠ¶æ…‹ (ç›¸å¯¾çš„ãªå¤‰åŒ–è¨ˆç®—ã®ãŸã‚)
        let currentDecoInitialRotation = 0; 
        let currentDecoInitialWidth = 0; 
        let currentDecoInitialHeight = 0; 
        let currentDecoInitialSize = 0; 

        // Canvaså…¨ä½“ã®ãƒ‘ãƒ³ã¨ã‚ºãƒ¼ãƒ ã®å¤‰æ•°
        let globalCanvasZoom = 1;
        let globalCanvasPanX = 0;
        let globalCanvasPanY = 0;

        // Canvaså…¨ä½“ã®ãƒ‘ãƒ³ã¨ã‚ºãƒ¼ãƒ ã®æ“ä½œé–‹å§‹æ™‚ã®çŠ¶æ…‹ (ç›¸å¯¾çš„ãªå¤‰åŒ–è¨ˆç®—ã®ãŸã‚)
        let initialGlobalPanX = 0;
        let initialGlobalPanY = 0;
        let initialGlobalZoom = 1;

        // å±¥æ­´ç®¡ç†
        let history = [];
        let historyPointer = -1;
        const MAX_HISTORY_SIZE = 50; // å±¥æ­´ã®æœ€å¤§ä¿æŒæ•°

        // A4æ¨ªã‚µã‚¤ã‚º (300DPI) ã«åˆã‚ã›ã¦ã‚«ãƒ³ãƒ´ã‚¡ã‚¹ã‚µã‚¤ã‚ºã‚’è¨­å®š
        const CANVAS_WIDTH = 3508; 
        const CANVAS_HEIGHT = 2480;
        
        // ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸfan.pngã‚’ä½¿ç”¨
        const UCHIWA_TEMPLATE_URL = 'fan.png'; 
        
        const STICKER_URLS = [
            '01loveu.png', // å¤§å¥½ãã ã‚ˆ
            '02ntwithFace.png', // é¡”ãŒå¤©æ‰
            '03eyestome.png', // ï¼“ç§’è¦‹ã¤ã‚ã¦
            '04getmyheart.png' // æ’ƒã£ã¦
        ];

        const EMOJIS = ['ğŸ˜Š', 'ğŸ˜„', 'ï¿½', 'ğŸ‘', 'â¤ï¸', 'ğŸŒŸ', 'ğŸ‰', 'ğŸ¶'];

        // ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«è¡¨ç¤ºã™ã‚‹ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³
        const FONT_SIZES = [48, 72, 96, 120];

        // æ“ä½œãƒãƒ³ãƒ‰ãƒ«ã®ã‚µã‚¤ã‚ºã‚’å…ƒã®ã‚µã‚¤ã‚ºã«è¿‘ãã€è¦‹ã‚„ã™ã„ã‚µã‚¤ã‚ºã«èª¿æ•´
        const HANDLE_SIZE_CANVAS_UNITS = 120; // Canvasåº§æ¨™ç³»ã§ã®ãƒãƒ³ãƒ‰ãƒ«ã®åŸºæœ¬ã‚µã‚¤ã‚º
        const ROTATE_HANDLE_OFFSET_CANVAS_UNITS = 150; // Canvasåº§æ¨™ç³»ã§ã®å›è»¢ãƒãƒ³ãƒ‰ãƒ«ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
        // é¸æŠå¯èƒ½é ˜åŸŸã«è¿½åŠ ã™ã‚‹ã‚¿ãƒƒãƒ—ãƒãƒƒãƒ•ã‚¡ (ç”»é¢ãƒ”ã‚¯ã‚»ãƒ«å˜ä½)
        const SELECTION_TAP_BUFFER_PX = 40; 

        // --- å±¥æ­´ã®çŠ¶æ…‹ã‚’ä¿å­˜ã™ã‚‹é–¢æ•° ---
        function saveState() {
            if (historyPointer < history.length - 1) {
                history = history.slice(0, historyPointer + 1); // ç¾åœ¨ã®ãƒã‚¤ãƒ³ã‚¿ä»¥é™ã®å±¥æ­´ã‚’å‰Šé™¤
            }

            // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜ç”¨ã«ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
            const currentState = {
                decorations: decorations.map(d => {
                    if (d.type === 'sticker') {
                        // Imageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã§ããªã„ãŸã‚ã€ãã®URLã‚’ä¿å­˜
                        return { ...d, imageSrc: d.image ? d.image.src : null };
                    }
                    return { ...d };
                }),
                backgroundImage: backgroundImage ? {
                    src: backgroundImage.image.src, // Imageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®srcã‚’ä¿å­˜
                    x: backgroundImage.x,
                    y: backgroundImage.y,
                    width: backgroundImage.width,
                    height: backgroundImage.height,
                    rotation: backgroundImage.rotation,
                    // èƒŒæ™¯ç”»åƒã®IDã‚’ä¿å­˜
                    id: backgroundImage.id 
                } : null,
                selectedDecorationId: selectedDecoration ? selectedDecoration.id : null,
                selectedDecorationType: selectedDecoration ? selectedDecoration.type : null, // é¸æŠã•ã‚ŒãŸè¦ç´ ã®ã‚¿ã‚¤ãƒ—ã‚‚ä¿å­˜
                globalCanvasZoom: globalCanvasZoom,
                globalCanvasPanX: globalCanvasPanX,
                globalCanvasPanY: globalCanvasPanY,
            };

            // ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã—ã¦å±¥æ­´ã«è¿½åŠ 
            history.push(JSON.parse(JSON.stringify(currentState)));
            historyPointer = history.length - 1;

            // å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™ã‚’è¶…ãˆãŸå ´åˆã€æœ€ã‚‚å¤ã„çŠ¶æ…‹ã‚’å‰Šé™¤
            if (history.length > MAX_HISTORY_SIZE) {
                history.shift();
                historyPointer--;
            }
            updateButtonStates(); // ãƒœã‚¿ãƒ³ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°
        }

        // --- å±¥æ­´ã®çŠ¶æ…‹ã‚’é©ç”¨ã™ã‚‹é–¢æ•° ---
        async function applyState(state) {
            decorations = []; // ç¾åœ¨ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªã‚¢
            selectedDecoration = null; // é¸æŠä¸­ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚‚ã‚¯ãƒªã‚¢

            const loadedDecorations = JSON.parse(JSON.stringify(state.decorations));
            const newSelectedDecorationId = state.selectedDecorationId;
            const newSelectedDecorationType = state.selectedDecorationType;
            let foundSelected = null;

            // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å¾©å…ƒ
            for (const d of loadedDecorations) {
                if (d.type === 'sticker' && d.imageSrc) {
                    const img = new Image();
                    img.src = d.imageSrc;
                    d.image = img;
                    await new Promise(resolve => {
                        img.onload = () => {
                            decorations.push(d);
                            if (d.id === newSelectedDecorationId && d.type === newSelectedDecorationType) {
                                foundSelected = d;
                            }
                            resolve();
                        };
                        img.onerror = () => {
                            console.error('Failed to load image for sticker during undo/redo:', d.imageSrc);
                            decorations.push(d);
                            if (d.id === newSelectedDecorationId && d.type === newSelectedDecorationType) {
                                foundSelected = d;
                            }
                            resolve();
                        };
                    });
                } else {
                    decorations.push(d);
                    if (d.id === newSelectedDecorationId && d.type === newSelectedDecorationType) {
                        foundSelected = d;
                    }
                }
            }
            
            // èƒŒæ™¯ç”»åƒã®å¾©å…ƒ
            if (state.backgroundImage) {
                const img = new Image();
                img.src = state.backgroundImage.src;
                backgroundImage = {
                    ...state.backgroundImage,
                    image: img
                };
                await new Promise(resolve => {
                    img.onload = () => {
                        if (state.backgroundImage.id === newSelectedDecorationId && state.backgroundImage.type === newSelectedDecorationType) {
                            foundSelected = backgroundImage;
                        }
                        resolve();
                    };
                    img.onerror = () => {
                        console.error('Failed to load background image during undo/redo:', state.backgroundImage.src);
                        backgroundImage = null;
                        resolve();
                    };
                });
            } else {
                backgroundImage = null;
            }

            selectedDecoration = foundSelected; // é¸æŠä¸­ã®è¦ç´ ã‚’å¾©å…ƒ
            globalCanvasZoom = state.globalCanvasZoom || 1;
            globalCanvasPanX = state.globalCanvasPanX || 0;
            globalCanvasPanY = state.globalCanvasPanY || 0;

            drawCanvas();
            updateButtonStates(); // ãƒœã‚¿ãƒ³ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°
        }

        // --- å„ãƒœã‚¿ãƒ³ã¨å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•° ---
        function updateButtonStates() {
            undoButton.disabled = historyPointer <= 0;
            redoButton.disabled = historyPointer >= history.length - 1;
            
            // è¤‡è£½ã€å‰Šé™¤ãƒœã‚¿ãƒ³ã¯é¸æŠä¸­ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¾ãŸã¯èƒŒæ™¯ç”»åƒãŒã‚ã‚‹å ´åˆã®ã¿æœ‰åŠ¹
            // èƒŒæ™¯ç”»åƒã¯è¤‡è£½ä¸å¯
            duplicateButton.disabled = !selectedDecoration || selectedDecoration.type === 'background'; 
            deleteButton.disabled = !selectedDecoration;

            // ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹åŒ–
            if (selectedDecoration) {
                if (selectedDecoration.type === 'background') {
                    // èƒŒæ™¯ç”»åƒã¯å¸¸ã«æœ€èƒŒé¢æ‰±ã„ãªã®ã§ã€ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œãƒœã‚¿ãƒ³ã¯å…¨ã¦ç„¡åŠ¹
                    bringToFrontButton.disabled = true;
                    sendToBackButton.disabled = true;
                    bringForwardButton.disabled = true;
                    sendBackwardButton.disabled = true;
                } else {
                    // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å ´åˆ
                    const selectedIndex = decorations.indexOf(selectedDecoration);
                    bringToFrontButton.disabled = (selectedIndex === decorations.length - 1);
                    sendToBackButton.disabled = (selectedIndex === 0);
                    bringForwardButton.disabled = (selectedIndex === decorations.length - 1);
                    sendBackwardButton.disabled = (selectedIndex === 0);
                }
            } else {
                // ä½•ã‚‚é¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆ
                bringToFrontButton.disabled = true;
                sendToBackButton.disabled = true;
                bringForwardButton.disabled = true;
                sendBackwardButton.disabled = true;
            }

            // èƒŒæ™¯ç”»åƒå‰Šé™¤ãƒœã‚¿ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤º
            removeBackgroundImageButton.classList.toggle('hidden', !backgroundImage);
            
            // ãƒ†ã‚­ã‚¹ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®æœ‰åŠ¹/ç„¡åŠ¹åŒ–ã¨å€¤ã®åæ˜ 
            if (selectedDecoration && selectedDecoration.type === 'text') {
                textColorPicker.disabled = false;
                fontSizeSelect.disabled = false;
                fontFamilySelect.disabled = false;
                outlineColorPicker.disabled = false;
                outlineWidthInput.disabled = false;

                textColorPicker.value = selectedDecoration.color;
                
                const currentFontSize = selectedDecoration.size;
                let closestFontSize = FONT_SIZES[0];
                let minDiff = Math.abs(currentFontSize - closestFontSize);

                for (let i = 1; i < FONT_SIZES.length; i++) {
                    const diff = Math.abs(currentFontSize - FONT_SIZES[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestFontSize = FONT_SIZES[i];
                    }
                }
                fontSizeSelect.value = closestFontSize;

                fontFamilySelect.value = selectedDecoration.fontFamily || 'Inter, sans-serif';
                outlineColorPicker.value = selectedDecoration.outlineColor || '#ffffff';
                outlineWidthInput.value = selectedDecoration.outlineWidth !== undefined ? selectedDecoration.outlineWidth : 5;

            } else {
                textColorPicker.disabled = true;
                fontSizeSelect.disabled = true;
                fontFamilySelect.disabled = true;
                outlineColorPicker.disabled = true;
                outlineWidthInput.disabled = true;

                // é¸æŠãŒå¤–ã‚ŒãŸã‚‰ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«æˆ»ã™
                textColorPicker.value = '#000000';
                fontSizeSelect.value = '96';
                fontFamilySelect.value = 'Inter, sans-serif';
                outlineColorPicker.value = '#ffffff';
                outlineWidthInput.value = 5;
            }
        }

        // --- åˆæœŸåŒ–å‡¦ç† ---
        window.onload = function() {
            photoCanvas.width = CANVAS_WIDTH;
            photoCanvas.height = CANVAS_HEIGHT;

            // ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã®ãƒ­ãƒ¼ãƒ‰
            uchiwaTemplateImage.src = UCHIWA_TEMPLATE_URL;
            uchiwaTemplateImage.onload = () => {
                drawCanvas(); // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚‰ã¾ãšæç”»
            };
            uchiwaTemplateImage.onerror = () => {
                console.error('ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚URL:', UCHIWA_TEMPLATE_URL);
                showMessageBox('ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            };

            // çµµæ–‡å­—ãƒœã‚¿ãƒ³ã®ç”Ÿæˆ
            EMOJIS.forEach(emoji => {
                const button = document.createElement('button');
                button.textContent = emoji;
                button.className = 'text-4xl px-3 py-2 rounded-full bg-blue-100 hover:bg-blue-200 transition duration-150';
                button.onclick = () => addEmoji(emoji);
                emojiContainer.appendChild(button);
            });

            // ã‚¹ã‚¿ãƒ³ãƒ—ãƒœã‚¿ãƒ³ã®ç”Ÿæˆ
            STICKER_URLS.forEach(url => {
                const button = document.createElement('button');
                button.className = 'sticker-btn p-1 bg-gray-100 rounded-lg hover:bg-gray-200 transition duration-150';
                const img = document.createElement('img');
                img.src = url;
                img.alt = 'Sticker';
                button.appendChild(img);
                button.onclick = () => addSticker(url);
                stickerContainer.appendChild(button);
            });

            startCamera(); // ã‚«ãƒ¡ãƒ©ã®èµ·å‹•
            saveState(); // ã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ã®åˆæœŸçŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
        };

        // --- ã‚«ãƒ¡ãƒ©æ“ä½œ ---
        async function startCamera() {
            try {
                loadingOverlay.classList.remove('hidden');
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment', // ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§ã‚¢ã‚¦ãƒˆã‚«ãƒ¡ãƒ©å„ªå…ˆ
                        width: { ideal: 1920 },    // é«˜è§£åƒåº¦è¨­å®š
                        height: { ideal: 1080 }
                    }
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    loadingOverlay.classList.add('hidden');
                };
            } catch (err) {
                loadingOverlay.classList.add('hidden');
                console.error('ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ:', err);
                captureButton.disabled = true;
                video.classList.add('hidden');

                // ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹å¤±æ•—æ™‚ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                if (err.name === 'NotAllowedError') {
                    showMessageBox('ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã‚’ç¢ºèªã—ã€ã‚«ãƒ¡ãƒ©ã®ä½¿ç”¨ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚');
                } else if (err.name === 'NotFoundError') {
                    showMessageBox('ã‚«ãƒ¡ãƒ©ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚«ãƒ¡ãƒ©ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                } else {
                    showMessageBox('ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
                }
                uploadOption.classList.remove('hidden'); // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
            }
        }

        // ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹é–¢æ•° (alertã®ä»£æ›¿)
        function showMessageBox(message) {
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: #333;
                color: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                z-index: 2000;
                text-align: center;
                max-width: 80%;
            `;
            messageBox.textContent = message;
            document.body.appendChild(messageBox);

            setTimeout(() => {
                document.body.removeChild(messageBox);
            }, 3000); // 3ç§’å¾Œã«è‡ªå‹•çš„ã«æ¶ˆãˆã‚‹
        }


        captureButton.addEventListener('click', () => {
            if (!video.srcObject) {
                showMessageBox('ã‚«ãƒ¡ãƒ©ãŒèµ·å‹•ã—ã¦ã„ã¾ã›ã‚“ã€‚ã¾ãŸã¯ã€ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
                return;
            }

            loadingOverlay.classList.remove('hidden');
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

            const capturedImg = new Image();
            capturedImg.src = tempCanvas.toDataURL('image/png');
            capturedImg.onload = () => {
                // èƒŒæ™¯ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦åˆæœŸåŒ– (capturedImageã®ä»£ã‚ã‚Šã«ç›´æ¥backgroundImageã‚’è¨­å®š)
                backgroundImage = {
                    id: crypto.randomUUID(),
                    type: 'background',
                    image: capturedImg, // æ’®å½±ã—ãŸç”»åƒã‚’backgroundImageã«è¨­å®š
                    x: CANVAS_WIDTH / 2,
                    y: CANVAS_HEIGHT / 2,
                    width: capturedImg.naturalWidth,
                    height: capturedImg.naturalHeight,
                    rotation: 0
                };
                selectedDecoration = backgroundImage; // èƒŒæ™¯ç”»åƒã‚’è‡ªå‹•é¸æŠ

                drawCanvas();
                cameraSection.classList.add('hidden');
                canvasSection.classList.remove('hidden');
                loadingOverlay.classList.add('hidden');
                if (stream) {
                    stream.getTracks().forEach(track => track.stop()); // ã‚«ãƒ¡ãƒ©ã‚’åœæ­¢
                }
                saveState(); // æ’®å½±å¾Œã€çŠ¶æ…‹ã‚’ä¿å­˜
            };
            capturedImg.onerror = () => {
                loadingOverlay.classList.add('hidden');
                showMessageBox('å†™çœŸã®ã‚­ãƒ£ãƒ—ãƒãƒ£ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
            };
        });

        // --- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆåˆæœŸç”»åƒã¨ã—ã¦ï¼‰ ---
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                loadingOverlay.classList.remove('hidden');
                const reader = new FileReader();
                reader.onload = (e) => {
                    const uploadedImg = new Image();
                    uploadedImg.src = e.target.result;
                    uploadedImg.onload = () => {
                        // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”»åƒã‚’backgroundImageã®åˆæœŸå€¤ã¨ã™ã‚‹
                        backgroundImage = {
                            id: crypto.randomUUID(),
                            type: 'background',
                            image: uploadedImg,
                            x: CANVAS_WIDTH / 2,
                            y: CANVAS_HEIGHT / 2,
                            width: uploadedImg.naturalWidth,
                            height: uploadedImg.naturalHeight,
                            rotation: 0
                        };
                        selectedDecoration = backgroundImage; // èƒŒæ™¯ç”»åƒã‚’è‡ªå‹•é¸æŠ

                        drawCanvas();
                        cameraSection.classList.add('hidden');
                        canvasSection.classList.remove('hidden');
                        loadingOverlay.classList.add('hidden');
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        saveState(); // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¾Œã€çŠ¶æ…‹ã‚’ä¿å­˜
                    };
                    uploadedImg.onerror = () => {
                        loadingOverlay.classList.add('hidden');
                        showMessageBox('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                    };
                };
                reader.readAsDataURL(file);
            }
        });

        // --- èƒŒæ™¯ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆbackgroundImageã‚’ä¸Šæ›¸ãã¾ãŸã¯è¿½åŠ ï¼‰ ---
        backgroundImageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                loadingOverlay.classList.remove('hidden');
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        // æ–°ã—ã„èƒŒæ™¯ç”»åƒã‚’ç”Ÿæˆã¾ãŸã¯æ—¢å­˜ã®ã‚‚ã®ã‚’æ›´æ–°
                        backgroundImage = {
                            id: crypto.randomUUID(), // æ–°ã—ã„ID
                            type: 'background',
                            image: img,
                            x: CANVAS_WIDTH / 2,
                            y: CANVAS_HEIGHT / 2,
                            width: img.naturalWidth,
                            height: img.naturalHeight,
                            rotation: 0
                        };
                        selectedDecoration = backgroundImage; // æ–°ã—ãè¿½åŠ ã—ãŸç”»åƒã‚’è‡ªå‹•é¸æŠ
                        drawCanvas();
                        saveState();
                        loadingOverlay.classList.add('hidden');
                    };
                    img.onerror = () => {
                        loadingOverlay.classList.add('hidden');
                        showMessageBox('èƒŒæ™¯ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                    };
                };
                reader.readAsDataURL(file);
            }
        });

        // --- èƒŒæ™¯ç”»åƒå‰Šé™¤ãƒœã‚¿ãƒ³ ---
        removeBackgroundImageButton.addEventListener('click', () => {
            if (backgroundImage) {
                backgroundImage = null;
                if (selectedDecoration && selectedDecoration.type === 'background') {
                    selectedDecoration = null; // é¸æŠè§£é™¤
                }
                drawCanvas();
                saveState();
            }
        });

        // --- ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ç¾åœ¨ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
        function getDecorationBounds(deco) {
            let width = deco.width;
            let height = deco.height;

            if (deco.type === 'text' || deco.type === 'emoji') {
                ctx.font = `${deco.size}px ${deco.fontFamily || 'Inter, sans-serif'}`;
                // ãƒ†ã‚­ã‚¹ãƒˆã®æ­£ç¢ºãªå¹…ã‚’å–å¾—ã—ã€ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®å¹…ã‚‚è€ƒæ…®ã«å…¥ã‚Œã‚‹
                width = ctx.measureText(deco.content).width + (deco.outlineWidth || 0) * 2;
                // ãƒ†ã‚­ã‚¹ãƒˆã®é«˜ã•ã¯fontSizeã‚’åŸºæº–ã«ã™ã‚‹ãŒã€ä¸Šä¸‹ã®ä½™ç™½ã‚‚è€ƒæ…®ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯fontSizeã‚’ãã®ã¾ã¾ä½¿ç”¨
                height = deco.size + (deco.outlineWidth || 0) * 2; 
            }
            return { width: width, height: height };
        }

        // --- ã‚­ãƒ£ãƒ³ãƒã‚¹æç”»ã¨ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ ---
        function drawCanvas() {
            ctx.clearRect(0, 0, photoCanvas.width, photoCanvas.height);

            // Canvaså…¨ä½“ã®å¤‰å½¢ã‚’é©ç”¨
            ctx.save();
            ctx.translate(globalCanvasPanX, globalCanvasPanY);
            ctx.scale(globalCanvasZoom, globalCanvasZoom);

            // 1. èƒŒæ™¯ç”»åƒã‚’æç”» (ã†ã¡ã‚ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®**ä¸‹**ã«æ¥ã‚‹)
            if (backgroundImage && backgroundImage.image && backgroundImage.image.complete) {
                ctx.save();
                ctx.translate(backgroundImage.x, backgroundImage.y);
                if (backgroundImage.rotation) {
                    ctx.rotate(backgroundImage.rotation);
                }
                ctx.drawImage(backgroundImage.image, -backgroundImage.width / 2, -backgroundImage.height / 2, backgroundImage.width, backgroundImage.height);
                ctx.restore();
            } else {
                // èƒŒæ™¯ç”»åƒãŒãªã„å ´åˆã€ç™½ã„èƒŒæ™¯ã‚’æç”»ã—ã¦é€æ˜ã†ã¡ã‚ã®ä¸‹ã®è¦ç´ ãŒè¦‹ãˆãªã„ã‚ˆã†ã«ã™ã‚‹
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, photoCanvas.width, photoCanvas.height);
            }
            
            // 2. ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æç”» (ãƒ†ã‚­ã‚¹ãƒˆã€çµµæ–‡å­—ã€ã‚¹ã‚¿ãƒ³ãƒ—)
            // ã“ã‚Œã¯ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã€Œä¸Šã€ã«æç”»ã•ã‚Œã¾ã™
            decorations.forEach(deco => {
                ctx.save();
                ctx.translate(deco.x, deco.y);
                if (deco.rotation) {
                    ctx.rotate(deco.rotation);
                }

                if (deco.type === 'text') {
                    ctx.font = `${deco.size}px ${deco.fontFamily || 'Inter, sans-serif'}`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    if (deco.outlineWidth > 0) {
                        ctx.strokeStyle = deco.outlineColor || '#ffffff';
                        ctx.lineWidth = deco.outlineWidth;
                        ctx.strokeText(deco.content, 0, 0);
                    }
                    ctx.fillStyle = deco.color;
                    ctx.fillText(deco.content, 0, 0);

                } else if (deco.type === 'emoji') {
                    ctx.font = `${deco.size}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(deco.content, 0, 0);
                } else if (deco.type === 'sticker' && deco.image && deco.image.complete) {
                    ctx.drawImage(deco.image, -deco.width / 2, -deco.height / 2, deco.width, deco.height);
                }
                ctx.restore();
            });

            // ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ›ã®å½±éŸ¿ã‚’å—ã‘ãªã„ã‚ˆã†ã«ã€ã“ã“ã§restoreã—ã¦ã‹ã‚‰æç”»
            ctx.restore(); 

            // 3. ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æç”» (æœ€å‰é¢ã«ã€ä»–ã®è¦ç´ ã®ä¸Šã«æç”»)
            // ã“ã‚Œã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ›ã®é©ç”¨å¾Œã ãŒã€ã†ã¡ã‚ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãŒå¸¸ã«å›ºå®šã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
            if (uchiwaTemplateImage.complete && uchiwaTemplateImage.naturalWidth !== 0) {
                 ctx.drawImage(uchiwaTemplateImage, 0, 0, photoCanvas.width, photoCanvas.height);
            } else {
                // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒãŒèª­ã¿è¾¼ã‚ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆé€æ˜ãªå††å½¢ã®ã‚¬ã‚¤ãƒ‰ï¼‰
                // ã“ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã§ã¯ãªãã€ã‚ãã¾ã§ã†ã¡ã‚ã®å½¢çŠ¶ã‚’æ¨æ¸¬ã™ã‚‹ãŸã‚ã®ã‚¬ã‚¤ãƒ‰ã¨ã—ã¦æç”»ã•ã‚Œã¾ã™ã€‚
                ctx.beginPath();
                ctx.arc(photoCanvas.width / 2, photoCanvas.height / 2, Math.min(photoCanvas.width, photoCanvas.height) / 3, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)'; // åŠé€æ˜ã®ç·š
                ctx.lineWidth = 5;
                ctx.stroke();
            }

            // 4. é¸æŠä¸­ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¾ãŸã¯èƒŒæ™¯ç”»åƒã«æ“ä½œãƒãƒ³ãƒ‰ãƒ«ã‚’æç”» (æœ€å‰é¢)
            if (selectedDecoration) {
                // ãƒãƒ³ãƒ‰ãƒ«ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ›ã‚’è€ƒæ…®ã—ã¦æç”»ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€å†åº¦save/translate/scale
                ctx.save();
                ctx.translate(globalCanvasPanX, globalCanvasPanY);
                ctx.scale(globalCanvasZoom, globalCanvasZoom);

                ctx.translate(selectedDecoration.x, selectedDecoration.y);
                if (selectedDecoration.rotation) {
                    ctx.rotate(selectedDecoration.rotation);
                }

                let targetBounds = getDecorationBounds(selectedDecoration);
                let targetWidth = targetBounds.width;
                let targetHeight = targetBounds.height;
                
                // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã®æç”»
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 6 / globalCanvasZoom; // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ç·šã®å¤ªã•ã‚’èª¿æ•´
                ctx.setLineDash([]);
                ctx.strokeRect(-targetWidth / 2, -targetHeight / 2, targetWidth, targetHeight);

                // ãƒãƒ³ãƒ‰ãƒ«ã®æç”»
                ctx.fillStyle = '#facc15';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2 / globalCanvasZoom; // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ç·šã®å¤ªã•ã‚’èª¿æ•´

                // ãƒãƒ³ãƒ‰ãƒ«ã®ã‚µã‚¤ã‚ºã‚’ç”»é¢ä¸Šã§ä¸€å®šã«ä¿ã¤
                const visibleHandleSize = HANDLE_SIZE_CANVAS_UNITS / globalCanvasZoom;
                const visibleHandleRadius = visibleHandleSize / 2;
                const visibleRotateHandleOffset = ROTATE_HANDLE_OFFSET_CANVAS_UNITS / globalCanvasZoom;

                // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ« (4éš…ã®å››è§’å½¢ã¨çŸ¢å°)
                const resizeHandlesData = [
                    { x: -targetWidth / 2, y: -targetHeight / 2, type: 'nw', cursor: 'nwse-resize' },
                    { x: targetWidth / 2, y: -targetHeight / 2, type: 'ne', cursor: 'nesw-resize' },
                    { x: -targetWidth / 2, y: targetHeight / 2, type: 'sw', cursor: 'nesw-resize' },
                    { x: targetWidth / 2, y: targetHeight / 2, type: 'se', cursor: 'nwse-resize' }
                ];

                resizeHandlesData.forEach(handle => {
                    ctx.fillRect(handle.x - visibleHandleRadius, handle.y - visibleHandleRadius, visibleHandleSize, visibleHandleSize);
                    ctx.strokeRect(handle.x - visibleHandleRadius, handle.y - visibleHandleRadius, visibleHandleSize, visibleHandleSize);

                    ctx.fillStyle = '#333';
                    const arrowSize = visibleHandleSize * 0.4;
                    const arrowOffset = visibleHandleSize * 0.3;

                    ctx.beginPath();
                    if (handle.type === 'nw') {
                        ctx.moveTo(handle.x - arrowOffset, handle.y - arrowOffset);
                        ctx.lineTo(handle.x - arrowOffset + arrowSize, handle.y - arrowOffset);
                        ctx.lineTo(handle.x - arrowOffset, handle.y - arrowOffset + arrowSize);
                    } else if (handle.type === 'ne') {
                        ctx.moveTo(handle.x + arrowOffset, handle.y - arrowOffset);
                        ctx.lineTo(handle.x + arrowOffset - arrowSize, handle.y - arrowOffset);
                        ctx.lineTo(handle.x + arrowOffset, handle.y - arrowOffset + arrowSize);
                    } else if (handle.type === 'sw') {
                        ctx.moveTo(handle.x - arrowOffset, handle.y + arrowOffset);
                        ctx.lineTo(handle.x - arrowOffset + arrowSize, handle.y + arrowOffset);
                        ctx.lineTo(handle.x - arrowOffset, handle.y + arrowOffset - arrowSize);
                    } else if (handle.type === 'se') {
                        ctx.moveTo(handle.x + arrowOffset, handle.y + arrowOffset);
                        ctx.lineTo(handle.x + arrowOffset - arrowSize, handle.y + arrowOffset);
                        ctx.lineTo(handle.x + arrowOffset, handle.y + arrowOffset - arrowSize);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#facc15';
                });

                // å›è»¢ãƒãƒ³ãƒ‰ãƒ« (ä¸Šä¸­å¤®ã®å††å½¢ãƒãƒ³ãƒ‰ãƒ«ã¨å›è»¢ã‚¢ã‚¤ã‚³ãƒ³)
                const rotateHandleCenterX = 0;
                const rotateHandleCenterY = -targetHeight / 2 - visibleRotateHandleOffset;

                // å›è»¢ãƒãƒ³ãƒ‰ãƒ«ã®ã¿è‰²ã‚’å¤‰æ›´
                ctx.fillStyle = '#ef4444'; // èµ¤è‰²
                ctx.beginPath();
                ctx.arc(rotateHandleCenterX, rotateHandleCenterY, visibleHandleRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.strokeStyle = '#fff'; // ç™½ã„ã‚¢ã‚¤ã‚³ãƒ³
                ctx.lineWidth = 3 / globalCanvasZoom; // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ç·šã®å¤ªã•ã‚’èª¿æ•´
                ctx.lineCap = 'round';

                const iconRadius = visibleHandleRadius * 0.5;

                ctx.beginPath();
                ctx.arc(rotateHandleCenterX, rotateHandleCenterY, iconRadius, Math.PI * 0.9, Math.PI * -0.1, true);
                ctx.stroke();
                const endAngle1 = Math.PI * -0.1;
                const endX1 = rotateHandleCenterX + iconRadius * Math.cos(endAngle1);
                const endY1 = rotateHandleCenterY + iconRadius * Math.sin(endAngle1);
                const tangentAngle1 = endAngle1 + Math.PI / 2;
                drawArrowhead(ctx, endX1, endY1, tangentAngle1, 10 / globalCanvasZoom, 6 / globalCanvasZoom);

                ctx.beginPath();
                ctx.arc(rotateHandleCenterX, rotateHandleCenterY, iconRadius, Math.PI * -0.1, Math.PI * 0.9, true);
                ctx.stroke();
                const endAngle2 = Math.PI * 0.9;
                const endX2 = rotateHandleCenterX + iconRadius * Math.cos(endAngle2);
                const endY2 = rotateHandleCenterY + iconRadius * Math.sin(endAngle2);
                const tangentAngle2 = endAngle2 + Math.PI / 2;
                drawArrowhead(ctx, endX2, endY2, tangentAngle2, 10 / globalCanvasZoom, 6 / globalCanvasZoom);

                ctx.lineCap = 'butt';

                ctx.restore(); // é¸æŠä¸­ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å¤‰æ›ã‚’è§£é™¤
            }
        }

        // çŸ¢å°ã®å…ˆç«¯ã‚’æç”»ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function drawArrowhead(context, x, y, angle, headLength, headWidth) {
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x - headLength * Math.cos(angle - Math.PI / 6), y - headLength * Math.sin(angle - Math.PI / 6));
            context.lineTo(x - headLength * Math.cos(angle + Math.PI / 6), y - headLength * Math.sin(angle + Math.PI / 6));
            context.closePath();
            context.fill();
        }

        // --- ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¿½åŠ é–¢æ•° ---
        addTextButton.addEventListener('click', () => {
            const text = textInput.value.trim();
            if (text) {
                const color = textColorPicker.value;
                const fontSize = parseInt(fontSizeSelect.value, 10);
                const fontFamily = fontFamilySelect.value;
                const outlineColor = outlineColorPicker.value;
                const outlineWidth = parseInt(outlineWidthInput.value, 10);

                decorations.push({
                    id: crypto.randomUUID(),
                    type: 'text',
                    content: text,
                    color: color,
                    size: fontSize,
                    fontFamily: fontFamily,
                    outlineColor: outlineColor,
                    outlineWidth: outlineWidth,
                    x: photoCanvas.width / 2,
                    y: photoCanvas.height / 2,
                    rotation: 0,
                });
                textInput.value = '';
                selectedDecoration = decorations[decorations.length - 1]; // è¿½åŠ ã—ãŸãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠçŠ¶æ…‹ã«
                drawCanvas();
                saveState();
            }
        });

        function addEmoji(emoji) {
            decorations.push({
                id: crypto.randomUUID(),
                type: 'emoji',
                content: emoji,
                size: 100,
                x: photoCanvas.width / 2 + (Math.random() - 0.5) * 200,
                y: photoCanvas.height / 2 + (Math.random() - 0.5) * 200,
                rotation: 0,
            });
            selectedDecoration = decorations[decorations.length - 1]; // è¿½åŠ ã—ãŸçµµæ–‡å­—ã‚’é¸æŠçŠ¶æ…‹ã«
            drawCanvas();
            saveState();
        }

        function addSticker(url) {
            const img = new Image();
            img.src = url;
            img.onload = () => {
                const stickerWidth = 200;
                const stickerHeight = (img.naturalHeight / img.naturalWidth) * stickerWidth;
                decorations.push({
                    id: crypto.randomUUID(),
                    type: 'sticker',
                    image: img,
                    x: photoCanvas.width / 2 + (Math.random() - 0.5) * 200,
                    y: photoCanvas.height / 2 + (Math.random() - 0.5) * 200,
                    width: stickerWidth,
                    height: stickerHeight,
                    rotation: 0,
                });
                selectedDecoration = decorations[decorations.length - 1]; // è¿½åŠ ã—ãŸã‚¹ã‚¿ãƒ³ãƒ—ã‚’é¸æŠçŠ¶æ…‹ã«
                drawCanvas();
                saveState();
            };
            img.onerror = () => console.error(`ã‚¹ã‚¿ãƒ³ãƒ—ç”»åƒ ${url} ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`);
        }

        // --- ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æ“ä½œæ©Ÿèƒ½ (ãƒ‰ãƒ©ãƒƒã‚°ã€ãƒªã‚µã‚¤ã‚ºã€å›è»¢) ---
        // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã‚’Canvaså†…éƒ¨åº§æ¨™ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ›è€ƒæ…®æ¸ˆã¿ï¼‰ã«å¤‰æ›ã™ã‚‹
        function getCanvasCoords(clientX, clientY) {
            const rect = photoCanvas.getBoundingClientRect();
            const scaleX_DOM = photoCanvas.width / rect.width;
            const scaleY_DOM = photoCanvas.height / rect.height;

            // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã‚’HTMLè¦ç´ å†…ã®ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã«å¤‰æ›
            const elementX = (clientX - rect.left) * scaleX_DOM;
            const elementY = (clientY - rect.top) * scaleY_DOM;

            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒ‘ãƒ³ã¨ã‚ºãƒ¼ãƒ ã‚’è€ƒæ…®ã—ã¦ã€ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒé…ç½®ã•ã‚Œã¦ã„ã‚‹åº§æ¨™ç³»ã«å¤‰æ›
            const canvasX = (elementX - globalCanvasPanX) / globalCanvasZoom;
            const canvasY = (elementY - globalCanvasPanY) / globalCanvasZoom;
            return { x: canvasX, y: canvasY };
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰Canvaså†…éƒ¨åº§æ¨™ã‚’å–å¾—
        function getEventCanvasPos(event) {
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            return getCanvasCoords(clientX, clientY);
        }

        // 2æœ¬æŒ‡ã®ä¸­é–“ç‚¹ã‚’Canvaså†…éƒ¨åº§æ¨™ã§å–å¾—
        function getTwoFingerMidpoint(touches) {
            if (touches.length < 2) return null;
            const touch1 = getCanvasCoords(touches[0].clientX, touches[0].clientY);
            const touch2 = getCanvasCoords(touches[1].clientX, touches[1].clientY);
            return {
                x: (touch1.x + touch2.x) / 2,
                y: (touch1.y + touch2.y) / 2
            };
        }

        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function getAngle(center, p) {
            return Math.atan2(p.y - center.y, p.x - center.x);
        }

        photoCanvas.addEventListener('mousedown', startInteraction);
        photoCanvas.addEventListener('touchstart', startInteraction, { passive: false });

        function startInteraction(e) {
            e.preventDefault();
            const currentCanvasPos = getEventCanvasPos(e); 
            startX = currentCanvasPos.x; 
            startY = currentCanvasPos.y;

            let clickedElement = null; 

            // ** é¸æŠå¯èƒ½é ˜åŸŸã«è¿½åŠ ã™ã‚‹ã‚¿ãƒƒãƒ—ãƒãƒƒãƒ•ã‚¡ (Canvaså˜ä½) **
            const effectiveSelectionPaddingCanvasUnits = SELECTION_TAP_BUFFER_PX / globalCanvasZoom;

            // 1. ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ (æ‰‹å‰ã‹ã‚‰å¥¥ã¸)
            for (let i = decorations.length - 1; i >= 0; i--) { 
                const deco = decorations[i];
                let decoBounds = getDecorationBounds(deco);

                // ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã‚’ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã«å¤‰æ› (å›è»¢ã‚’è€ƒæ…®)
                const inverseRotation = -(deco.rotation || 0);
                const localClickX = Math.cos(inverseRotation) * (currentCanvasPos.x - deco.x) - Math.sin(inverseRotation) * (currentCanvasPos.y - deco.y);
                const localClickY = Math.sin(inverseRotation) * (currentCanvasPos.x - deco.x) + Math.cos(inverseRotation) * (currentCanvasPos.y - deco.y);

                // ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã§ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ + ã‚¿ãƒƒãƒ—ãƒãƒƒãƒ•ã‚¡å†…ã«ã‚ã‚‹ã‹åˆ¤å®š
                if (localClickX >= -decoBounds.width / 2 - effectiveSelectionPaddingCanvasUnits && localClickX <= decoBounds.width / 2 + effectiveSelectionPaddingCanvasUnits &&
                    localClickY >= -decoBounds.height / 2 - effectiveSelectionPaddingCanvasUnits && localClickY <= decoBounds.height / 2 + effectiveSelectionPaddingCanvasUnits) {
                    clickedElement = deco;
                    break; 
                }
            }

            // 2. ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒ’ãƒƒãƒˆã—ãªã‹ã£ãŸå ´åˆã€èƒŒæ™¯ç”»åƒã‚’ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
            if (!clickedElement && backgroundImage) {
                let bgBounds = getDecorationBounds(backgroundImage);
                const inverseRotation = -(backgroundImage.rotation || 0);
                const localClickX = Math.cos(inverseRotation) * (currentCanvasPos.x - backgroundImage.x) - Math.sin(inverseRotation) * (currentCanvasPos.y - backgroundImage.y);
                const localClickY = Math.sin(inverseRotation) * (currentCanvasPos.x - backgroundImage.x) + Math.cos(inverseRotation) * (currentCanvasPos.y - backgroundImage.y);

                // èƒŒæ™¯ç”»åƒã‚‚ã‚¿ãƒƒãƒ—ãƒãƒƒãƒ•ã‚¡ã‚’è€ƒæ…®
                if (localClickX >= -bgBounds.width / 2 - effectiveSelectionPaddingCanvasUnits && localClickX <= bgBounds.width / 2 + effectiveSelectionPaddingCanvasUnits &&
                    localClickY >= -bgBounds.height / 2 - effectiveSelectionPaddingCanvasUnits && localClickY <= bgBounds.height / 2 + effectiveSelectionPaddingCanvasUnits) {
                    clickedElement = backgroundImage;
                }
            }

            // ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸè¦ç´ ãŒã‚ã‚Œã°ã€ãã‚Œã‚’é¸æŠçŠ¶æ…‹ã«ã™ã‚‹
            if (clickedElement) {
                selectedDecoration = clickedElement;
                if (selectedDecoration.type !== 'background') { // èƒŒæ™¯ç”»åƒã¯ãƒ¬ã‚¤ãƒ¤ãƒ¼é †ã‚’å¤‰ãˆãªã„
                    decorations = decorations.filter(d => d.id !== selectedDecoration.id);
                    decorations.push(selectedDecoration);
                }
                drawCanvas(); 
            } else {
                // ä½•ã‚‚ãƒ’ãƒƒãƒˆã—ãªã‹ã£ãŸå ´åˆã¯ã€é¸æŠè§£é™¤
                selectedDecoration = null;
                drawCanvas(); 
            }
            updateButtonStates();


            // ã“ã“ã‹ã‚‰ã€é¸æŠã•ã‚ŒãŸè¦ç´ ã«å¯¾ã™ã‚‹æ“ä½œã€ã¾ãŸã¯Canvaså…¨ä½“ã®æ“ä½œã‚’åˆ¤å®š
            // å„ªå…ˆé †ä½: ãƒãƒ³ãƒ‰ãƒ«æ“ä½œ > ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒãƒ«ãƒã‚¿ãƒƒãƒ > ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ‰ãƒ©ãƒƒã‚° > Canvasã®ãƒãƒ«ãƒã‚¿ãƒƒãƒ > Canvasã®ãƒ‘ãƒ³
            
            if (selectedDecoration) {
                let targetBounds = getDecorationBounds(selectedDecoration);
                // ** ãƒãƒ³ãƒ‰ãƒ«ã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆåŠå¾„ã‚‚ã‚ºãƒ¼ãƒ ã‚’è€ƒæ…®ã—ã¦èª¿æ•´ **
                const handleRadiusForHitTest = (HANDLE_SIZE_CANVAS_UNITS / 2) / globalCanvasZoom; 

                // ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã‚’é¸æŠã•ã‚ŒãŸè¦ç´ ã®ãƒ­ãƒ¼ã‚«ãƒ«ï¼ˆæœªå›è»¢ï¼‰åº§æ¨™ç³»ã«å¤‰æ›
                const inverseRotationOfSelected = -(selectedDecoration.rotation || 0);
                const localClickX = Math.cos(inverseRotationOfSelected) * (currentCanvasPos.x - selectedDecoration.x) - Math.sin(inverseRotationOfSelected) * (currentCanvasPos.y - selectedDecoration.y);
                const localClickY = Math.sin(inverseRotationOfSelected) * (currentCanvasPos.x - selectedDecoration.x) + Math.cos(inverseRotationOfSelected) * (currentCanvasPos.y - selectedDecoration.y);

                // 3.1 å›è»¢ãƒãƒ³ãƒ‰ãƒ«ã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
                const rotateHandleLocalX = 0;
                const rotateHandleLocalY = -targetBounds.height / 2 - ROTATE_HANDLE_OFFSET_CANVAS_UNITS;
                const distToRotateHandle = getDistance({x: localClickX, y: localClickY}, {x: rotateHandleLocalX, y: rotateHandleLocalY});

                if (distToRotateHandle < handleRadiusForHitTest) {
                    interactionState = { type: 'rotate' };
                    currentDecoInitialRotation = selectedDecoration.rotation || 0; // å›è»¢é–‹å§‹æ™‚ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å›è»¢è§’åº¦ã‚’ä¿å­˜
                    startAngle = getAngle({ x: selectedDecoration.x, y: selectedDecoration.y }, currentCanvasPos); 
                    photoCanvas.style.cursor = 'crosshair';
                    setupInteractionListeners();
                    return;
                }
                
                // 3.2 ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
                const resizeHandlesData = [
                    { x: -targetBounds.width / 2, y: -targetBounds.height / 2, type: 'nw', cursor: 'nwse-resize' },
                    { x: targetBounds.width / 2, y: -targetBounds.height / 2, type: 'ne', cursor: 'nesw-resize' },
                    { x: -targetBounds.width / 2, y: targetBounds.height / 2, type: 'sw', cursor: 'nesw-resize' },
                    { x: targetBounds.width / 2, y: targetBounds.height / 2, type: 'se', cursor: 'nwse-resize' }
                ];
                for (let handleData of resizeHandlesData) {
                    const dist = getDistance({x: localClickX, y: localClickY}, {x: handleData.x, y: handleData.y});
                    if (dist < handleRadiusForHitTest) {
                        interactionState = { type: 'resize', handle: handleData.type };
                        // ãƒªã‚µã‚¤ã‚ºé–‹å§‹æ™‚ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸçŠ¶æ…‹ã‚’ä¿å­˜
                        if (selectedDecoration.type === 'text' || selectedDecoration.type === 'emoji') {
                            currentDecoInitialSize = selectedDecoration.size;
                        } else {
                            currentDecoInitialWidth = selectedDecoration.width;
                            currentDecoInitialHeight = selectedDecoration.height;
                        }
                        photoCanvas.style.cursor = handleData.cursor;
                        setupInteractionListeners();
                        return;
                    }
                }
                
                // 3.3 ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒ’ãƒƒãƒˆã—ã¦ãŠã‚Šã€2æœ¬æŒ‡ã‚¿ãƒƒãƒã®å ´åˆã€ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒãƒ«ãƒã‚¿ãƒƒãƒæ“ä½œ
                if (e.touches && e.touches.length === 2) {
                    const touch1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
                    const touch2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
                    startTouchDist = getDistance(touch1, touch2); 
                    initialTouchAngle = getAngle(touch1, touch2); 
                    
                    // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸçŠ¶æ…‹ã‚’ä¿å­˜ (ç›¸å¯¾çš„ãªå¤‰åŒ–è¨ˆç®—ã®ãŸã‚)
                    currentDecoInitialRotation = selectedDecoration.rotation || 0;
                    if (selectedDecoration.type === 'text' || selectedDecoration.type === 'emoji') {
                        currentDecoInitialSize = selectedDecoration.size;
                    } else {
                        currentDecoInitialWidth = selectedDecoration.width;
                        currentDecoInitialHeight = selectedDecoration.height;
                    }

                    interactionState = { type: 'multi-touch-decoration' }; 
                    setupInteractionListeners();
                    return;
                }
                
                // 3.4 ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒãƒ’ãƒƒãƒˆã—ã¦ãŠã‚Šã€1æœ¬æŒ‡ã‚¿ãƒƒãƒã¾ãŸã¯ãƒã‚¦ã‚¹ã®å ´åˆã€ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œ
                if (clickedElement) { // clickedElementãŒselectedDecorationã¨åŒã˜ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªæ¸ˆã¿
                    interactionState = { type: 'drag' };
                    dragOffsetX = currentCanvasPos.x - selectedDecoration.x;
                    dragOffsetY = currentCanvasPos.y - selectedDecoration.y;
                    photoCanvas.style.cursor = 'grabbing';
                    setupInteractionListeners();
                    return;
                }

            } else { // selectedDecorationãŒnullã®å ´åˆï¼ˆèƒŒæ™¯ãŒã‚¿ãƒƒãƒ—ã•ã‚ŒãŸï¼‰
                // 3.5 2æœ¬æŒ‡ã‚¿ãƒƒãƒã®å ´åˆã€Canvaså…¨ä½“ã®ãƒãƒ«ãƒã‚¿ãƒƒãƒæ“ä½œ
                if (e.touches && e.touches.length === 2) {
                    const touch1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
                    const touch2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
                    startTouchDist = getDistance(touch1, touch2); 
                    initialTouchAngle = getAngle(touch1, touch2); 
                    startTouchMidpoint = getTwoFingerMidpoint(e.touches); // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã§ä¸­é–“ç‚¹ã‚‚ä¿å­˜

                    initialGlobalPanX = globalCanvasPanX;
                    initialGlobalPanY = globalCanvasPanY;
                    initialGlobalZoom = globalCanvasZoom;

                    interactionState = { type: 'global-multi-touch' };
                    setupInteractionListeners();
                    return;
                }
                // 3.6 1æœ¬æŒ‡ã‚¿ãƒƒãƒã¾ãŸã¯ãƒã‚¦ã‚¹ã®å ´åˆã€Canvaså…¨ä½“ã®ãƒ‘ãƒ³æ“ä½œ
                if (e.buttons === 1 || (e.touches && e.touches.length === 1)) {
                    interactionState = { type: 'global-pan' };
                    initialGlobalPanX = globalCanvasPanX; 
                    initialGlobalPanY = globalCanvasPanY;
                    photoCanvas.style.cursor = 'grabbing';
                    setupInteractionListeners();
                    return;
                }
            }
            // ã©ã®æ“ä½œã«ã‚‚å½“ã¦ã¯ã¾ã‚‰ãªã„å ´åˆ
            interactionState = { type: 'none', handle: null };
            photoCanvas.style.cursor = 'grab'; 
        }

        function setupInteractionListeners() {
            photoCanvas.addEventListener('mousemove', handleInteraction);
            photoCanvas.addEventListener('touchmove', handleInteraction, { passive: false });
            photoCanvas.addEventListener('mouseup', endInteraction);
            photoCanvas.addEventListener('touchend', endInteraction);
            photoCanvas.addEventListener('mouseleave', endInteraction);
        }

        function removeInteractionListeners() {
            photoCanvas.removeEventListener('mousemove', handleInteraction);
            photoCanvas.removeEventListener('touchmove', handleInteraction);
            photoCanvas.removeEventListener('mouseup', endInteraction);
            photoCanvas.removeEventListener('touchend', endInteraction);
            photoCanvas.removeEventListener('mouseleave', endInteraction);
        }

        function handleInteraction(e) {
            e.preventDefault();
            const currentCanvasPos = getEventCanvasPos(e); 
            
            let target = selectedDecoration; 

            if (interactionState.type === 'drag') {
                if (!target) return; 
                target.x = currentCanvasPos.x - dragOffsetX;
                target.y = currentCanvasPos.y - dragOffsetY;
            } else if (interactionState.type === 'resize') {
                if (!target) return; 
                const centerX = target.x;
                const centerY = target.y;
                const currentDist = getDistance({x: centerX, y: centerY}, {x: currentCanvasPos.x, y: currentCanvasPos.y});
                const initialDist = getDistance({x: centerX, y: centerY}, {x: startX, y: startY});

                if (initialDist === 0) return;

                const scaleFactor = currentDist / initialDist; 
                
                if (target.type === 'text' || target.type === 'emoji') {
                    target.size = currentDecoInitialSize * scaleFactor;
                } else {
                    target.width = currentDecoInitialWidth * scaleFactor;
                    target.height = currentDecoInitialHeight * scaleFactor;
                }

            } else if (interactionState.type === 'rotate') {
                if (!target) return;
                const currentAngle = getAngle({ x: target.x, y: target.y }, currentCanvasPos);
                const deltaAngle = currentAngle - startAngle; 
                target.rotation = currentDecoInitialRotation + deltaAngle; 
            } else if (interactionState.type === 'multi-touch-decoration' && e.touches && e.touches.length === 2) {
                if (!target) return;
                const touch1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
                const touch2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
                const newDist = getDistance(touch1, touch2);
                const currentAngle = getAngle(touch1, touch2);

                // ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚° (ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼é–‹å§‹æ™‚ã®è·é›¢ã‚’åŸºæº–ã«è¨ˆç®—)
                if (startTouchDist !== null && startTouchDist !== 0) { 
                    const scaleFactor = newDist / startTouchDist;
                    if (target.type === 'text' || target.type === 'emoji') {
                        target.size = currentDecoInitialSize * scaleFactor;
                    } else {
                        target.width = currentDecoInitialWidth * scaleFactor;
                        target.height = currentDecoInitialHeight * scaleFactor;
                    }
                }

                // å›è»¢ (ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼é–‹å§‹æ™‚ã®è§’åº¦ã‚’åŸºæº–ã«è¨ˆç®—)
                if (initialTouchAngle !== null) {
                    const angleChange = currentAngle - initialTouchAngle;
                    target.rotation = currentDecoInitialRotation + angleChange;
                }
            } else if (interactionState.type === 'global-pan') {
                // Canvaså…¨ä½“ã®ãƒ‘ãƒ³
                // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ç³»ã®ç§»å‹•é‡ã§è¨ˆç®—ã—ã€æœ€å¾Œã«ç¾åœ¨ã®ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã§å‰²ã£ã¦Canvasåº§æ¨™ã«å¤‰æ›
                const rect = photoCanvas.getBoundingClientRect();
                const scaleX_DOM = photoCanvas.width / rect.width;
                const scaleY_DOM = photoCanvas.height / rect.height;

                const currentClientX = e.touches && e.touches.length > 0 ? e.touches[0].clientX : e.clientX;
                const currentClientY = e.touches && e.touches.length > 0 ? e.touches[0].clientY : e.clientY;

                const deltaX_screen = (currentClientX - e.screenX_at_start) * scaleX_DOM; // e.screenX_at_startã¯mousedown/touchstartæ™‚ã«è¨­å®šã™ã‚‹
                const deltaY_screen = (currentClientY - e.screenY_at_start) * scaleY_DOM;

                globalCanvasPanX = initialGlobalPanX + deltaX_screen;
                globalCanvasPanY = initialGlobalPanY + deltaY_screen;

            } else if (interactionState.type === 'global-multi-touch' && e.touches && e.touches.length === 2) {
                // Canvaså…¨ä½“ã®ã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³
                const touch1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
                const touch2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
                const newDist = getDistance(touch1, touch2);
                const currentMidpoint = getTwoFingerMidpoint(e.touches); 

                // ã‚ºãƒ¼ãƒ 
                if (startTouchDist !== null && startTouchDist !== 0) {
                    const scaleFactor = newDist / startTouchDist;
                    globalCanvasZoom = initialGlobalZoom * scaleFactor;
                    globalCanvasZoom = Math.max(0.1, Math.min(5, globalCanvasZoom)); 
                }

                // ãƒ‘ãƒ³ (ä¸­é–“ç‚¹ã®ç§»å‹•é‡ã¨ç¾åœ¨ã®ã‚ºãƒ¼ãƒ ã‚’è€ƒæ…®)
                if (currentMidpoint && startTouchMidpoint) {
                    // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã§ã®ç§»å‹•é‡
                    const rect = photoCanvas.getBoundingClientRect();
                    const scaleX_DOM = photoCanvas.width / rect.width;
                    const scaleY_DOM = photoCanvas.height / rect.height;

                    const clientMidX_current = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const clientMidY_current = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    const clientMidX_start = (e.touches_start[0].clientX + e.touches_start[1].clientX) / 2; // ã‚¿ãƒƒãƒé–‹å§‹æ™‚ã®ä¸­é–“ç‚¹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåº§æ¨™
                    const clientMidY_start = (e.touches_start[0].clientY + e.touches_start[1].clientY) / 2;

                    const deltaX_screen = (clientMidX_current - clientMidX_start) * scaleX_DOM;
                    const deltaY_screen = (clientMidY_current - clientMidY_start) * scaleY_DOM;
                    
                    globalCanvasPanX = initialGlobalPanX + deltaX_screen;
                    globalCanvasPanY = initialGlobalPanY + deltaY_screen;
                }
            }
            drawCanvas();
            updateButtonStates();
        }

        function endInteraction(e) {
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ‘ãƒ³ã®é–‹å§‹ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ
            if (interactionState.type === 'global-pan' || interactionState.type === 'global-multi-touch') {
                initialGlobalPanX = globalCanvasPanX;
                initialGlobalPanY = globalCanvasPanY;
                initialGlobalZoom = globalCanvasZoom;
            }

            // ã‚¿ãƒƒãƒã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã®å¤‰æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ
            startTouchDist = null; 
            initialTouchAngle = null;
            startTouchMidpoint = { x: 0, y: 0 };
            
            // e.touches_start ã‚’ã‚¯ãƒªã‚¢
            delete e.touches_start;

            currentDecoInitialRotation = 0;
            currentDecoInitialWidth = 0;
            currentDecoInitialHeight = 0;
            currentDecoInitialSize = 0;

            interactionState = { type: 'none', handle: null };
            photoCanvas.style.cursor = 'grab';
            removeInteractionListeners();
            drawCanvas();
            saveState(); // æ“ä½œçµ‚äº†æ™‚ã«çŠ¶æ…‹ã‚’ä¿å­˜
        }

        // --- Undo/Redoãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        undoButton.addEventListener('click', async () => {
            if (historyPointer > 0) {
                historyPointer--;
                await applyState(history[historyPointer]);
            }
        });

        redoButton.addEventListener('click', async () => {
            if (historyPointer < history.length - 1) {
                historyPointer++;
                await applyState(history[historyPointer]);
            }
        });

        // --- è¤‡è£½ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        duplicateButton.addEventListener('click', () => {
            if (selectedDecoration && selectedDecoration.type !== 'background') { // èƒŒæ™¯ç”»åƒã¯è¤‡è£½ä¸å¯
                const original = selectedDecoration;
                let newCopy;

                const offsetX = 50 / globalCanvasZoom; // ã‚ºãƒ¼ãƒ ã‚’è€ƒæ…®ã—ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´
                const offsetY = 50 / globalCanvasZoom;

                if (original.type === 'sticker') {
                    const newImage = new Image();
                    newImage.src = original.image.src;
                    newCopy = {
                        id: crypto.randomUUID(),
                        type: 'sticker',
                        image: newImage,
                        x: original.x + offsetX,
                        y: original.y + offsetY,
                        width: original.width,
                        height: original.height,
                        rotation: original.rotation,
                    };
                    newImage.onload = () => {
                        decorations.push(newCopy);
                        selectedDecoration = newCopy;
                        drawCanvas();
                        saveState();
                    };
                    newImage.onerror = () => {
                        console.error('Failed to load duplicated sticker image:', newImage.src);
                        showMessageBox('ã‚¹ã‚¿ãƒ³ãƒ—ç”»åƒã®è¤‡è£½ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                    };
                } else if (original.type === 'text') {
                    newCopy = {
                        id: crypto.randomUUID(),
                        type: original.type,
                        content: original.content,
                        color: original.color,
                        size: original.size,
                        fontFamily: original.fontFamily,
                        outlineColor: original.outlineColor,
                        outlineWidth: original.outlineWidth,
                        x: original.x + offsetX,
                        y: original.y + offsetY,
                        rotation: original.rotation,
                    };
                    decorations.push(newCopy);
                    selectedDecoration = newCopy;
                    drawCanvas();
                    saveState();
                } else if (original.type === 'emoji') {
                    newCopy = {
                        id: crypto.randomUUID(),
                        type: original.type,
                        content: original.content,
                        size: original.size,
                        x: original.x + offsetX,
                        y: original.y + offsetY,
                        rotation: original.rotation,
                    };
                    decorations.push(newCopy);
                    selectedDecoration = newCopy;
                    drawCanvas();
                    saveState();
                }
            } else {
                showMessageBox('è¤‡è£½ã™ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚èƒŒæ™¯ç”»åƒã¯è¤‡è£½ã§ãã¾ã›ã‚“ã€‚');
            }
        });

        // --- å‰Šé™¤ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        deleteButton.addEventListener('click', () => {
            if (selectedDecoration) {
                if (selectedDecoration.type === 'background') {
                    backgroundImage = null;
                } else {
                    decorations = decorations.filter(deco => deco.id !== selectedDecoration.id);
                }
                selectedDecoration = null;
                drawCanvas();
                saveState();
            } else {
                showMessageBox('å‰Šé™¤ã™ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
            }
        });

        // --- æœ€å‰é¢ã¸ç§»å‹•ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        bringToFrontButton.addEventListener('click', () => {
            if (selectedDecoration && selectedDecoration.type !== 'background') {
                decorations = decorations.filter(deco => deco.id !== selectedDecoration.id);
                decorations.push(selectedDecoration);
                drawCanvas();
                saveState();
            } else {
                showMessageBox('æœ€å‰é¢ã¸ç§»å‹•ã™ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚èƒŒæ™¯ç”»åƒã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚');
            }
        });

        // --- æœ€èƒŒé¢ã¸ç§»å‹•ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        sendToBackButton.addEventListener('click', () => {
            if (selectedDecoration && selectedDecoration.type !== 'background') {
                decorations = decorations.filter(deco => deco.id !== selectedDecoration.id);
                decorations.unshift(selectedDecoration);
                drawCanvas();
                saveState();
            } else {
                showMessageBox('æœ€èƒŒé¢ã¸ç§»å‹•ã™ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚èƒŒæ™¯ç”»åƒã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚');
            }
        });

        // --- ä¸€ã¤å‰é¢ã¸ç§»å‹•ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        bringForwardButton.addEventListener('click', () => {
            if (selectedDecoration && selectedDecoration.type !== 'background') {
                const index = decorations.indexOf(selectedDecoration);
                if (index !== -1 && index < decorations.length - 1) {
                    [decorations[index], decorations[index + 1]] = [decorations[index + 1], decorations[index]];
                    drawCanvas();
                    saveState();
                }
            } else {
                showMessageBox('ä¸€ã¤å‰é¢ã¸ç§»å‹•ã™ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚èƒŒæ™¯ç”»åƒã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚');
            }
        });

        // --- ä¸€ã¤èƒŒé¢ã¸ç§»å‹•ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        sendBackwardButton.addEventListener('click', () => {
            if (selectedDecoration && selectedDecoration.type !== 'background') {
                const index = decorations.indexOf(selectedDecoration);
                if (index !== -1 && index > 0) {
                    [decorations[index], decorations[index - 1]] = [decorations[index - 1], decorations[index]];
                    drawCanvas();
                    saveState();
                }
            } else {
                showMessageBox('ä¸€ã¤èƒŒé¢ã¸ç§»å‹•ã™ã‚‹ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚èƒŒæ™¯ç”»åƒã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚');
            }
        });

        // --- é¸æŠä¸­ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        textColorPicker.addEventListener('input', () => {
            if (selectedDecoration && selectedDecoration.type === 'text') {
                selectedDecoration.color = textColorPicker.value;
                drawCanvas();
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¤‰æ›´ã¯å±¥æ­´ã‚’å¤§é‡ã«ç”Ÿæˆã™ã‚‹ãŸã‚ã€endInteractionã§ã®ã¿saveState()ã‚’å‘¼ã¶
            }
        });

        fontSizeSelect.addEventListener('change', () => {
            if (selectedDecoration && selectedDecoration.type === 'text') {
                selectedDecoration.size = parseInt(fontSizeSelect.value, 10);
                drawCanvas();
                saveState(); // ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã‹ã‚‰ã®å¤‰æ›´ã¯ä¸€å›ã®æ“ä½œã¨ã¿ãªã—ã¦ä¿å­˜
            }
        });

        fontFamilySelect.addEventListener('change', () => {
            if (selectedDecoration && selectedDecoration.type === 'text') {
                selectedDecoration.fontFamily = fontFamilySelect.value;
                drawCanvas();
                saveState(); // ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ã‹ã‚‰ã®å¤‰æ›´ã¯ä¸€å›ã®æ“ä½œã¨ã¿ãªã—ã¦ä¿å­˜
            }
        });

        outlineColorPicker.addEventListener('input', () => {
            if (selectedDecoration && selectedDecoration.type === 'text') {
                selectedDecoration.outlineColor = outlineColorPicker.value;
                drawCanvas();
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¤‰æ›´ã¯å±¥æ­´ã‚’å¤§é‡ã«ç”Ÿæˆã™ã‚‹ãŸã‚ã€endInteractionã§ã®ã¿saveState()ã‚’å‘¼ã¶
            }
        });

        outlineWidthInput.addEventListener('input', () => {
            if (selectedDecoration && selectedDecoration.type === 'text') {
                selectedDecoration.outlineWidth = parseInt(outlineWidthInput.value, 10);
                drawCanvas();
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¤‰æ›´ã¯å±¥æ­´ã‚’å¤§é‡ã«ç”Ÿæˆã™ã‚‹ãŸã‚ã€endInteractionã§ã®ã¿saveState()ã‚’å‘¼ã¶
            }
        });


        // --- ä¿å­˜ã¨Googleãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ ---
        saveButton.addEventListener('click', () => {
            // ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚‚ã†ä¸€åº¦ä½œæˆã—ã€æœ€çµ‚çš„ãªç”»åƒã‚’ç”Ÿæˆã™ã‚‹
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = photoCanvas.width;
            finalCanvas.height = photoCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // æœ€çµ‚ç”»åƒã®ç”Ÿæˆã§ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªãƒ‘ãƒ³ã¨ã‚ºãƒ¼ãƒ ã¯é©ç”¨ã—ãªã„
            // èƒŒæ™¯ç”»åƒã‚’æç”»
            if (backgroundImage && backgroundImage.image && backgroundImage.image.complete) {
                finalCtx.save();
                finalCtx.translate(backgroundImage.x, backgroundImage.y);
                if (backgroundImage.rotation) {
                    finalCtx.rotate(backgroundImage.rotation);
                }
                finalCtx.drawImage(backgroundImage.image, -backgroundImage.width / 2, -backgroundImage.height / 2, backgroundImage.width, backgroundImage.height);
                finalCtx.restore();
            } else {
                finalCtx.fillStyle = '#ffffff';
                finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            }

            // ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æç”»
            decorations.forEach(deco => {
                finalCtx.save();
                finalCtx.translate(deco.x, deco.y);
                if (deco.rotation) {
                    finalCtx.rotate(deco.rotation);
                }

                if (deco.type === 'text') {
                    finalCtx.font = `${deco.size}px ${deco.fontFamily || 'Inter, sans-serif'}`;
                    finalCtx.textAlign = 'center';
                    finalCtx.textBaseline = 'middle';

                    if (deco.outlineWidth > 0) {
                        finalCtx.strokeStyle = deco.outlineColor || '#ffffff';
                        finalCtx.lineWidth = deco.outlineWidth;
                        finalCtx.strokeText(deco.content, 0, 0);
                    }
                    finalCtx.fillStyle = deco.color;
                    finalCtx.fillText(deco.content, 0, 0);

                } else if (deco.type === 'emoji') {
                    finalCtx.font = `${deco.size}px sans-serif`;
                    finalCtx.textAlign = 'center';
                    finalCtx.textBaseline = 'middle';
                    finalCtx.fillText(deco.content, 0, 0);
                } else if (deco.type === 'sticker' && deco.image && deco.image.complete) {
                    finalCtx.drawImage(deco.image, -deco.width / 2, -deco.height / 2, deco.width, deco.height);
                }
                finalCtx.restore();
            });

            // ã†ã¡ã‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æç”»
            if (uchiwaTemplateImage.complete && uchiwaTemplateImage.naturalWidth !== 0) {
                 finalCtx.drawImage(uchiwaTemplateImage, 0, 0, finalCanvas.width, finalCanvas.height);
            }


            const imageDataURL = finalCanvas.toDataURL('image/png');

            const link = document.createElement('a');
            link.download = 'uchiwa_decorated.png';
            link.href = imageDataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showMessageBox('ç”»åƒã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã®å ´åˆã¯ã€è¡¨ç¤ºã•ã‚ŒãŸç”»åƒã‚’é•·æŠ¼ã—ã—ã¦ä¿å­˜ã—ã¦ãã ã•ã„ã€‚');
        });

        googleFormLink.href = 'https://docs.google.com/forms/d/e/1FAIpQLSf1wV724Vnag4FCcjeU1z-3vaCcfhCjAvGyU8432bu8dyciow/viewform';
    </script>
</body>
</html>
ï¿½