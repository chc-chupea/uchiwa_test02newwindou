<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Myうちわ - デコレーション</title>
  <!-- 推し活にぴったりなフォントを読み込み -->
  <link href="https://fonts.googleapis.com/css2?family=Cherry+Bomb+One&family=DotGothic16&family=Kaisei+Tokumin&family=Train+One&family=M+PLUS+Rounded+1c:wght@800&family=Kosugi+Maru&family=M+PLUS+1p:wght@800&family=Reggae+One&family=RocknRoll+One&family=Yomogi&family=Hachi+Maru+Pop&display=swap" rel="stylesheet">

  <style>
    /* 全体的なスタイル */
    body {
      font-family: 'Arial', sans-serif; /* 基本フォント設定 */
      text-align: center;
      background: linear-gradient(135deg, #f0f7ff, #eaf6ff); /* 背景グラデーション */
      margin: 0;
      padding: 10px;
      color: #333;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 20px;
      color: #1565c0;
    }
    .area {
      background: #fff; /* 白い背景のカード */
      border-radius: 20px; /* 角丸 */
      padding: 16px;
      margin-bottom: 16px; /* 間隔を少し詰める */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* 影 */
    }
    .area h2 {
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 12px;
      color: #1565c0;
    }

    /* エディタ（キャンバス）のラッパー */
    #editorWrapper {
      position: relative;
      width: 100%;
      max-width: 900px; /* 最大幅 */
      aspect-ratio: 4 / 3; /* アスペクト比を固定 */
      margin: 0 auto;
      background-color: #f9f9f9;
      overflow: hidden;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    /* メインキャンバスとオーバーレイキャンバス */
    #mainCanvas, #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none; /* タッチイベントのデフォルト動作を無効化 */
    }
    /* うちわテンプレート画像（低解像度版） */
    #templateOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* クリックイベントを透過 */
      object-fit: contain; /* アスペクト比を保ちつつ要素内に収める */
    }

    /* フォーム要素の共通スタイル */
    select, input[type="text"], input[type="color"], button, label {
      display: block;
      width: 100%;
      margin: 10px 0;
      padding: 12px;
      border-radius: 12px;
      font-size: 16px;
      border: 1px solid #ccc;
      background: #fff;
      box-sizing: border-box;
    }
    /* ボタンの共通スタイル */
    button {
      background: #4cafef;
      color: white;
      font-size: 16px;
      padding: 12px 24px;
      border-radius: 30px;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s, background 0.3s; /* ホバー時のアニメーション */
    }
    button:hover {
      background: #2196f3;
      transform: translateY(-2px);
    }
    /* ファイル選択ボタンのカスタムスタイル */
    #customFileLabel {
      background: linear-gradient(135deg, #4cafef, #2196f3);
      color: #fff;
      border-radius: 30px;
      padding: 14px 26px;
      cursor: pointer;
      font-size: 16px;
      transition: 0.3s;
      display: inline-block; /* ボタンのように表示 */
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
    }
    #customFileLabel:hover {
      background: linear-gradient(135deg, #42a5f5, #1e88e5);
      transform: scale(1.05);
    }
    /* フォームへ進むボタンのスタイル */
    .form-button {
      background: linear-gradient(135deg, #2196f3, #1976d2);
      color: white;
      padding: 12px 24px;
      margin-top: 20px;
      text-decoration: none;
      font-weight: bold;
      font-size: 18px;
      border-radius: 30px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      display: block;
      width: auto; /* コンテンツに合わせて幅を調整 */
      margin-left: auto;
      margin-right: auto;
    }
    .form-button:hover {
      background: linear-gradient(135deg, #1976d2, #0d47a1);
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
    }
    /* プレビュー画像のスタイル */
    #previewWrapper img {
      max-width: 100%;
      border: 6px solid #fff;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      margin-top: 12px;
    }
    /* 選択中のオブジェクトの枠線 */
    .active-object-outline {
      outline: 2px dashed #42a5f5; /* 点線で表示 */
      outline-offset: 5px; /* 要素からのオフセット */
    }
    /* エディタの初期背景（うちわの形状）*/
    #editorWrapper::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url(fan1-lowres.png) no-repeat center center / contain; /* デフォルトうちわの形 */
      pointer-events: none;
      opacity: 0.5; /* 半透明 */
    }

    /* スタンプボタン専用スタイル */
    .stamp-buttons-container {
      display: flex;
      flex-wrap: wrap;
      gap: 5px; /* ボタン間の隙間を均一に */
      justify-content: center;
      margin-top: 8px; /* スタンプエリアの上マージンを調整 */
      margin-bottom: 8px; /* スタンプエリアの下マージンを調整 */
    }
    .stamp-buttons-container .stamp-button {
      width: auto; /* コンテンツに合わせて幅を調整 */
      min-width: 45px; /* 最低幅を確保し、タッチしやすくする */
      padding: 8px 12px; /* パディングを調整 */
      font-size: 24px; /* 絵文字のサイズを大きく */
      display: inline-flex; /* flexアイテムとして表示し、中央揃え */
      align-items: center;
      justify-content: center;
      height: 45px; /* ボタンの高さを固定 */
      margin: 0; /* flex containerでgapを指定するため、個別のmarginをリセット */
      box-shadow: 0 2px 4px rgba(0,0,0,0.15); /* 影を少し控えめに */
    }

    .stamp-buttons-container .stamp-button img {
        height: 30px; /* 画像スタンプのサイズを調整 */
        vertical-align: middle; /* 垂直方向中央揃え */
    }

    /* メンバーカラー用カラーピッカーの背景色 */
    #backgroundColorPicker {
        background-color: #ffe6f2; /* 薄いピンク色 */
    }

    /* 自由テキスト用カラーピッカーの背景色 */
    #colorPicker {
        background-color: #ffe6f2; /* 薄いピンク色 */
    }

    /* 編集ツールボタンのレイアウト調整 */
    .edit-tools-container {
      display: flex;
      flex-wrap: wrap;
      gap: 3px; /* ボタン間の隙間をさらに詰める */
      justify-content: center;
      margin-top: 8px; /* 編集ツールエリアの上マージンを維持 */
    }
    .edit-tools-container button {
        flex: 0 0 auto; /* 固定幅にせず、内容に合わせて伸縮 */
        padding: 6px 10px; /* パディングをさらに小さく */
        font-size: 13px; /* フォントサイズをさらに小さく */
        margin: 0; /* flex containerでgapを指定するため、個別のmarginをリセット */
        min-width: 60px; /* 最低幅を調整 */
    }

    /* 自由テキスト入力エリア内の要素の間隔調整 */
    #customText {
      margin-bottom: 8px; /* 自由テキスト入力の下マージン */
      padding: 10px; /* パディングも少し小さく */
    }
    #area-decorations > h3:nth-of-type(1) + input[type="text"] + div { /* 自由テキストのカラーピッカーとフォントピッカーを含むdiv */
      margin-top: 8px;
      margin-bottom: 8px;
    }
    #area-decorations button[onclick="addTextToOverlay()"] {
      margin-top: 8px; /* テキスト追加ボタンの上マージン */
      margin-bottom: 16px; /* 次のセクションへのマージン */
    }

    /* うちわのデザイン選択ラベルから縁の線をなくす */
    #templateLabel {
        border: none;
        outline: none;
    }

    /* --- フォント選択ボタン用の見た目 --- */
    .font-picker-wrap { position: relative; flex: 1; }

    #fontPickerBtn {
      width: 100%;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 12px;
      background: #fff;
      font-size: 16px;
      cursor: pointer;
      text-align: left;
      color: #000;  /* ← これを追加 */
    }

    #fontDropdown {
      position: absolute;
      z-index: 9999;
      left: 0;
      right: 0;
      top: calc(100% + 6px);
      border: 1px solid #ddd;
      border-radius: 12px;
      background: #fff;
      box-shadow: 0 8px 20px rgba(0,0,0,0.08);
      max-height: 260px;
      overflow: auto;
      padding: 6px;
    }

    .font-option {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #f0f0f0;
      margin-bottom: 6px;
      cursor: pointer;
    }

    .font-option:hover { background: #f7fbff; }

    .font-sample { font-size: 20px; line-height: 1.2; }
    .font-name   { font-size: 12px; color: #666; margin-top: 2px; }

    .native-font-select {
      position: absolute !important;
      left: -9999px !important; /* 画面からよける（フォーム値は残す） */
    }

    /* === CapCut風：横スクロールツールバー === */
    .cc-toolbar {
      display: flex;
      gap: 12px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding: 8px 6px;
      margin: 8px -6px 10px;   /* 端まで広くドラッグできるように少しはみ出させる */
      border-top: 1px solid #eee;
      border-bottom: 1px solid #eee;
      scroll-snap-type: x proximity;
    }
    .cc-toolbar::-webkit-scrollbar { display: none; } /* スクロールバーを隠す（スマホ向け） */

    .cc-item {
      flex: 0 0 auto;          /* 横に並ぶ（折り返さない） */
      width: 84px;             /* 指で押しやすい幅 */
      scroll-snap-align: center;
      border: 1px solid #ddd;
      border-radius: 14px;
      background: #fff;
      padding: 8px 6px;
      text-align: center;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,.06);
    }
    .cc-item .icon { font-size: 20px; display: block; line-height: 1.2; }
    .cc-item .label { font-size: 12px; color: #333; display: block; margin-top: 4px; }

    .cc-item.active {
      background: linear-gradient(135deg, #e3f2fd, #ffffff);
      border-color: #90caf9;
      box-shadow: 0 3px 10px rgba(33,150,243,.15);
    }

    /* パネル（ツールの中身） */
    .cc-panels { margin-top: 8px; }
    .cc-panel[hidden] { display: none; }

    /* 既存のボタン群がぎゅうぎゅうにならないように少し調整 */
    .cc-panel button { margin: 4px 2px; }

  </style>
</head>
<body>

  <h1 id="title">Myうちわ</h1>

  <div class="area" id="area-select">
    <h2 id="section1-title">1) 背景を決める</h2>
    <label id="templateLabel">うちわのデザインフィルターを選んでね👇</label>
    <select id="templateSelector">
      <option value="fan1-highres.png" data-lowres="fan1-lowres.png">無地</option>
      <option value="fan2-highres.png" data-lowres="fan2-lowres.png">夏祭り①</option>
      <option value="fan3-highres.png" data-lowres="fan3-lowres.png">夏祭り②</option>
    </select>
    <label for="imageLoader" id="customFileLabel">写真で背景を作る</label>
    <input type="file" id="imageLoader" accept="image/*" style="display:none;" />
    <p id="reuploadNotice" style="font-size: 12px; color: #666;">※ 画像は何度でも選び直せます。</p>

    <h3 style="margin-top: 20px;">メンバーカラーで背景を作る</h3>
    <input type="color" id="backgroundColorPicker" value="#ff8fff" title="背景色選択" />
  </div>

  <div class="area" id="area-canvas">
    <h2 id="section2-title">2) デザイン編集スペース</h2>
    <div id="editorWrapper">
      <canvas id="mainCanvas" width="3508" height="2480"></canvas>
      <img id="templateOverlay" src="fan1-lowres.png" alt="うちわテンプレート">
    </div>
    <p id="editNotice" style="font-size: 12px; color: #666; margin-top: 10px;">
      ※ 画像は1本の指で位置を動かせます。2本の指で大きさや向きを変えることができます。
    </p>
    <button id="confirmPhotoBtn" style="margin-top: 10px;">写真の配置を確定</button>
    <button id="reEditPhotoBtn" style="margin-top: 10px; display: none;">写真の再編集</button>
  </div>

  <div class="area" id="area-decorations" style="display: none;">
    <h2 id="section3-title">3) デコレーション</h2>
    <!-- <p id="decorationNotice" style="font-size: 12px; color: #666;">
      ※ オブジェクトをタップすると選択され、移動・サイズ変更・回転できます。
    </p> -->

    <!-- ▼▼ ここから “横スライド メニュー” を追加 ▼▼ -->
    <div class="cc-toolbar" role="tablist">
      <button class="cc-item active" data-target="panel-text">
        <!-- <span class="icon">T</span> --><span class="label">テキスト</span>
      </button>
      <button class="cc-item" data-target="panel-stamp">
        <!-- <span class="icon">🌟</span> --><span class="label">スタンプ</span>
      </button>
      <button class="cc-item" data-target="panel-arrange">
        <!-- <span class="icon">📋</span> --><span class="label">複製／削除</span>
      </button>
      <button class="cc-item" data-target="panel-history">
        <!-- <span class="icon">↩ ↪</span> --><span class="label">↩ ↪</span>
      </button>
      <button class="cc-item" data-target="panel-layer">
        <!-- <span class="icon">⬆︎⬇︎</span> --><span class="label">レイヤー</span>
      </button>
    </div>

    <div class="cc-panels">
      <!-- テキスト -->
      <section id="panel-text" class="cc-panel">
        <input type="text" id="customText" placeholder="推しへのメッセージ♡" />
        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
          <input type="color" id="colorPicker" value="#ff69b4" title="文字色選択" style="width: 50px;" />
          <select id="fontPicker" class="native-font-select">
            <option value="Arial, sans-serif">Arial</option>
            <option value="'DotGothic16', sans-serif">ドットゴシック</option>
            <option value="'Train One', cursive">Train One</option>
            <option value="'Cherry Bomb One', cursive">手書き風</option>
            <option value="'Kaisei Tokumin', serif">丸文字</option>
            <option value="'M PLUS Rounded 1c', sans-serif">M PLUS Rounded 太字</option>
            <option value="'M PLUS 1p', sans-serif">M PLUS 1p 太字</option>
            <option value="'Kosugi Maru', sans-serif">Kosugi Maru</option>
            <option value="'Reggae One', cursive">Reggae One</option>
            <option value="'RocknRoll One', sans-serif">RocknRoll One</option>
            <option value="'Yomogi', cursive">Yomogi</option>
            <option value="'Hachi Maru Pop', cursive">Hachi Maru Pop</option>
          </select>
          <div class="font-picker-wrap">
            <button id="fontPickerBtn" type="button">フォントを選ぶ</button>
            <div id="fontDropdown" hidden></div>
          </div>
        </div>

        <!-- ▼ 縁取り設定（ここから追加） -->
          <div id="outlineControls" class="control-row" style="margin-bottom: 10px;">
            <label>
              <input type="checkbox" id="outlineToggle" checked>
              縁取りON/OFF
            </label>

            <label style="margin-left:8px;">
              色：
              <input type="color" id="outlineColorPicker" value="#ffffff" title="縁取り色" style="width: 50px;" />
            </label>

            <label style="margin-left:8px;">
              太さ：
              <input type="range" id="outlineWidthPercent" min="0" max="30" value="12" step="1">
              <span id="outlineWidthValue">12%</span>
            </label>
          </div>
          <!-- ▲ 縁取り設定（ここまで追加） -->


        <button onclick="addTextToOverlay()">テキスト追加</button>
      </section>

      <!-- スタンプ -->
      <section id="panel-stamp" class="cc-panel" hidden>
        <h3 style="margin:6px 0 8px;">スタンプ</h3>
        <div class="stamp-buttons-container">
          <button class="stamp-button" onclick="addStamp('❤️')">❤️</button>
          <button class="stamp-button" onclick="addStamp('⭐')">⭐</button>
          <button class="stamp-button" onclick="addStamp('🎶')">🎶</button>
          <button class="stamp-button" onclick="addStamp('01loveu.png')"><img src="01loveu.png" alt="Love You"></button>
          <button class="stamp-button" onclick="addStamp('02ntwithFace.png')"><img src="02ntwithFace.png" alt="NT with Face"></button>
          <button class="stamp-button" onclick="addStamp('03eyestome.png')"><img src="03eyestome.png" alt="Eyes to me"></button>
          <button class="stamp-button" onclick="addStamp('04getmyheart.png')"><img src="04getmyheart.png" alt="Get my heart"></button>
          <button class="stamp-button" onclick="addStamp('05angel.png')"><img src="05angel.png" alt="Angel"></button>
          <button class="stamp-button" onclick="addStamp('06god.png')"><img src="06god.png" alt="God"></button>
          <button class="stamp-button" onclick="addStamp('07precious.png')"><img src="07precious.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('08osi_pink.png')"><img src="08osi_pink.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('09osi_yellow.png')"><img src="09osi_yellow.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('10osi_lightblue.png')"><img src="10osi_lightblue.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('11osi_green.png')"><img src="11osi_green.png" alt="Precious"></button>
        </div>
      </section>

      <!-- 並べ替え（複製・削除） -->
      <section id="panel-arrange" class="cc-panel" hidden>
        <button id="duplicateBtn">複製</button>
        <button id="deleteBtn" style="background:#f44336;">削除</button>
      </section>

      <!-- 履歴（戻る・やり直し） -->
      <section id="panel-history" class="cc-panel" hidden>
        <button id="undoBtn">戻る</button>
        <button id="redoBtn">やり直し</button>
      </section>

      <!-- レイヤー（前面/背面） -->
      <section id="panel-layer" class="cc-panel" hidden>
        <button id="sendBackwardBtn">背面へ</button>
        <button id="bringForwardBtn">前面へ</button>
      </section>
    </div>
    <!-- ▲▲ ここまで “横スライド メニュー” ▲▲ -->

    <!-- 「決定 → プレビュー」ボタンをデコレーションエリア内に移動 -->
    <button id="generateBtn" class="form-button" style="margin-top: 20px;">決定 → プレビュー</button>
  </div>

  <div class="area" id="area-result" style="display: none;">
    <h2 id="section4-title">4) 完成イメージ</h2>
    <div id="previewWrapper">
      <img id="previewImage" alt="合成画像プレビュー" />
    </div>
    <div id="previewNotice" style="font-size:14px; color:black; margin-top:10px;"></div>
    <!-- 「注文フォームへ進む」ボタンはここに残し、JavaScriptで表示制御 -->
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSf1wV724Vnag4FCcjeU1z-3vaCcfhCjAvGyU8432bu8dyciow/viewform?usp=dialog"
       target="_blank"
       class="form-button"
       id="goToOrderFormBtn"
       style="display: none;">📝 注文フォームへ進む</a>
  </div>

  <footer style="font-size: 6px; color: #888; margin-top: 20px;">
    © 2025 Chugoku Shimbun Hanbai Center. Web application developed by Hitomi Sasaki. All rights reserved.<br />
    このウェブアプリケーションは、株式会社中国新聞販売センターの従業員による地域イベント向けの自主開発プロジェクトです。<br />
    ※本アプリは公式サービスではありませんが、業務との親和性を考慮して使用されています。
  </footer>

  <!-- Hammer.jsを読み込み：タッチジェスチャーをよりスムーズにするため -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script>

    // ← ここに追加！
      window.addEventListener('DOMContentLoaded', () => {
        // 初期値をピンクに統一
        colorPicker.value = "#ff69b4";
        outlineColorPicker.value = "#ffc9d2";

        // 見た目（背景色）も更新
        colorPicker.style.backgroundColor = "#ff69b4";
        outlineColorPicker.style.backgroundColor = "#ffc9d2";
      });

    // DOM要素の取得
    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d');
    const templateOverlay = document.getElementById('templateOverlay');
    const imageLoader = document.getElementById('imageLoader');
    const templateSelector = document.getElementById('templateSelector');
    const confirmPhotoBtn = document.getElementById('confirmPhotoBtn');
    const reEditPhotoBtn = document.getElementById('reEditPhotoBtn');
    const generateBtn = document.getElementById('generateBtn');
    const goToOrderFormBtn = document.getElementById('goToOrderFormBtn');
    const customText = document.getElementById('customText');
    const colorPicker = document.getElementById('colorPicker');

    // --- 縁取りコントロールを参照する ---
    const outlineToggle = document.getElementById('outlineToggle');
    const outlineColorPicker = document.getElementById('outlineColorPicker');
    const outlineWidthPercent = document.getElementById('outlineWidthPercent');
    const outlineWidthValue = document.getElementById('outlineWidthValue');

    // スライダーの数字を表示に反映
    outlineWidthPercent.addEventListener('input', () => {
      outlineWidthValue.textContent = outlineWidthPercent.value + '%';
    });
    const fontPicker = document.getElementById('fontPicker');

    const fontPickerBtn = document.getElementById('fontPickerBtn');
    const fontDropdown  = document.getElementById('fontDropdown');


    // === CapCut風ツールバーの表示切替 ===
    const ccToolbar = document.querySelector('.cc-toolbar');
    const ccItems   = document.querySelectorAll('.cc-item');
    const ccPanels  = document.querySelectorAll('.cc-panel');

    function showPanel(id) {
      // パネルの表示/非表示
      ccPanels.forEach(p => p.hidden = (p.id !== id));
      // アクティブ表示
      ccItems.forEach(b => b.classList.toggle('active', b.dataset.target === id));
      // 押したボタンを中央へ寄せる（横スクロールがスッと動く）
      const btn = document.querySelector(`.cc-item[data-target="${id}"]`);
      if (btn) btn.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
    }

    ccToolbar.addEventListener('click', (e) => {
      const btn = e.target.closest('.cc-item');
      if (!btn) return;
      showPanel(btn.dataset.target);
    });

    // 初期表示は「テキスト」パネル
    showPanel('panel-text');





    // この配列の順序／内容は <select id="fontPicker"> と揃えています
    const FONT_CANDIDATES = [
      { name: 'Arial',          value: 'Arial, sans-serif' },
      { name: 'ドットゴシック',   value: "'DotGothic16', sans-serif" },
      { name: 'Train One',      value: "'Train One', cursive" },
      { name: '手書き風',        value: "'Cherry Bomb One', cursive" },
      { name: '丸文字',          value: "'Kaisei Tokumin', serif" },
      { name: 'M PLUS Rounded', value: "'M PLUS Rounded 1c', sans-serif" },
      { name: 'M PLUS 1p', value: "'M PLUS 1p', sans-serif" },
      { name: 'Kosugi Maru', value: "'Kosugi Maru', sans-serif" },
      { name: 'Reggae One', value: "'Reggae One', cursive" },
      { name: 'RocknRoll One', value: "'RocknRoll One', sans-serif" },
      { name: 'Yomogi', value: "'Yomogi', cursive" },
      { name: 'Hachi Maru Pop', value: "'Hachi Maru Pop', cursive" },
    ];

    // ドロップダウンの中身を作る
    function buildFontDropdown() {
      fontDropdown.innerHTML = '';
      FONT_CANDIDATES.forEach(f => {
        const item = document.createElement('div');
        item.className = 'font-option';

        const sample = document.createElement('div');
        sample.className = 'font-sample';
        sample.textContent = 'Aaあア愛';
        sample.style.fontFamily = f.value;

        const name = document.createElement('div');
        name.className = 'font-name';
        name.textContent = f.name;

        item.appendChild(sample);
        item.appendChild(name);

        item.addEventListener('click', () => {
          setFont(f.value, f.name);
          fontDropdown.hidden = true;
        });

        fontDropdown.appendChild(item);
      });
    }

    // 実際にフォントを選んだときの処理
    function setFont(value, label) {
      // 1) 元の<select>に値をセット
      fontPicker.value = value;

      // 2) 既存の「change」処理をそのまま動かす
      fontPicker.dispatchEvent(new Event('change', { bubbles: true }));

      // 3) ボタン自体も選んだフォントで表示
      fontPickerBtn.style.fontFamily = value;
      fontPickerBtn.textContent = 'Aa あア愛 – ' + label;
    }

    // ボタンをタップ／クリックでメニュー開閉
    fontPickerBtn.addEventListener('click', () => {
      fontDropdown.hidden = !fontDropdown.hidden;
    });

    // 外側をクリックしたら閉じる
    document.addEventListener('click', (e) => {
      const wrap = document.querySelector('.font-picker-wrap');
      if (wrap && !wrap.contains(e.target)) fontDropdown.hidden = true;
    });

    // 初期化：リストを組み立てて、最初は「フォントを選ぶ」と表示だけする
    buildFontDropdown();
    (() => {
      fontPickerBtn.textContent = 'フォントを選ぶ';
      fontPickerBtn.style.fontFamily = 'Arial, sans-serif'; // ← フォントを指定しておくと見やすい！
    })();




    const previewWrapper = document.getElementById('previewWrapper');
    const previewImage = document.getElementById('previewImage');
    const previewNotice = document.getElementById('previewNotice');
    const areaDecorations = document.getElementById('area-decorations');
    const areaResult = document.getElementById('area-result');
    // 追加: 背景色ピッカーの取得
    const backgroundColorPicker = document.getElementById('backgroundColorPicker');

    // 状態変数
    let uploadedImg = null;
    let photoObject = null;
    let isPhotoLocked = false;
    let decorationObjects = [];
    let selectedObject = null;
    let history = [];
    let historyIndex = -1;
    // 追加: 背景色を保持する変数
    let backgroundColor = '#ffffff'; // デフォルトは白

    // ジェスチャー開始時のオブジェクトの状態とタッチ中心
    var initialObjX, initialObjY, initialObjScale, initialObjRotation;
    var initialTouchCenterX, initialTouchCenterY;
    // オブジェクトの中心からタッチ中心への初期ベクトル（キャンバス座標系）
    var initialVecOffsetX, initialVecOffsetY; 

    // --- 履歴管理機能 ---
    /**
     * 現在のデコレーションオブジェクトの状態を履歴に保存します。
     */
    function saveState() {
      // 現在のインデックス以降の履歴を削除し、新しい状態を追加
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }

      // decorationObjects を「JSONにできる形」に変換する（img は src に置き換える）
      const snapshot = decorationObjects.map(obj => {
        if (obj.type === 'image') {
          return {
            id: obj.id,
            type: 'image',
            src: obj.src || (obj.img && obj.img.src) || '',
            x: obj.x,
            y: obj.y,
            scale: obj.scale,
            rotation: obj.rotation,
            width: obj.width,
            height: obj.height
          };
        } else {
          // text 等
          return {
            id: obj.id,
            type: obj.type,
            content: obj.content,
            x: obj.x,
            y: obj.y,
            scale: obj.scale,
            rotation: obj.rotation,
            color: obj.color,
            fontFamily: obj.fontFamily,
            fontSize: obj.fontSize
          };
        }
      });

      history.push(JSON.stringify(snapshot));
      historyIndex++;
    }


    function restoreDecorationsFromSnapshot(snapshotStr) {
      if (!snapshotStr) {
        decorationObjects = [];
        selectedObject = null;
        drawAll();
        return;
      }
      const arr = JSON.parse(snapshotStr);
      decorationObjects = arr.map(item => {
        if (item.type === 'image') {
          // 事前読み込み済みの stampImages があれば使い、なければ新しい Image を作る
          let img = (typeof stampImages !== 'undefined' && stampImages[item.src]) ? stampImages[item.src] : new Image();
          // stampImages にない場合は src をセットして読み込み開始
          if (!stampImages || !stampImages[item.src]) {
            img.src = item.src;
          }
          // 画像がまだ読み込み中でも、読み込み完了時に再描画するようにする
          if (!img.complete) {
            img.onload = () => { drawAll(); };
          }
          return {
            id: item.id,
            type: 'image',
            src: item.src,
            img: img,
            x: item.x,
            y: item.y,
            scale: item.scale,
            rotation: item.rotation,
            width: item.width,
            height: item.height
          };
        } else {
          // text 等はそのまま戻す
          return {
            id: item.id,
            type: item.type,
            content: item.content,
            x: item.x,
            y: item.y,
            scale: item.scale,
            rotation: item.rotation,
            color: item.color,
            fontFamily: item.fontFamily,
            fontSize: item.fontSize
          };
        }
      });

      selectedObject = null;
      drawAll();
    }

    /**
     * 一つ前の編集状態に戻します（アンドゥ）。
     */
    function undo() {
      if (historyIndex > 0) {
    historyIndex--;
        restoreDecorationsFromSnapshot(history[historyIndex]);
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreDecorationsFromSnapshot(history[historyIndex]);
      }
    }

    // --- 描画機能 ---
    /**
     * 写真をキャンバスに描画します。
     */
    function drawImage() {
      if (!photoObject || !uploadedImg) return;

      ctx.save(); // 現在のキャンバスの状態を保存
      // 写真の中心を基準に移動、回転、拡大縮小
      ctx.translate(photoObject.x, photoObject.y);
      ctx.rotate(photoObject.rotation);
      ctx.scale(photoObject.scale, photoObject.scale);
      // 画像を描画（中心座標が0,0になるようにオフセット）
      ctx.drawImage(uploadedImg, -uploadedImg.width / 2, -uploadedImg.height / 2);
      ctx.restore(); // 保存した状態に戻す
    }

    /**
     * デコレーションオブジェクト（テキスト、スタンプ）をキャンバスに描画します。
     */
    function drawDecorations() {
      decorationObjects.forEach(obj => {
        ctx.save();
        // オブジェクトの中心を基準に移動、回転、拡大縮小
        ctx.translate(obj.x, obj.y);
        ctx.rotate(obj.rotation);
        ctx.scale(obj.scale, obj.scale);

        if (obj.type === 'text') {
          ctx.fillStyle = obj.color;

          // ← 相殺をやめる：そのままのフォントサイズで描く
          ctx.font = `${obj.fontSize}px ${obj.fontFamily}`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // --- 縁取り（アウトライン） ---
          if (obj.outlineEnabled) {
            const ratio = obj.outlineWidthRatio || 0.12;
            ctx.lineWidth = Math.max(1, obj.fontSize * ratio);
            ctx.strokeStyle = obj.outlineColor || '#ffffff';
            ctx.lineJoin = 'round';   // 角を丸くする
            ctx.miterLimit = 2;
            ctx.strokeText(obj.content, 0, 0);
          }

          // --- 本体（塗りつぶし） ---
          ctx.fillStyle = obj.color;
          ctx.fillText(obj.content, 0, 0);


        } else if (obj.type === 'image') {
          // 画像を描画（中心座標が0,0になるようにオフセット）
          ctx.drawImage(obj.img, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
        }

        // 選択中のオブジェクトに枠線を表示
        if (obj === selectedObject) {
          ctx.strokeStyle = '#42a5f5';
          ctx.lineWidth = 10 / obj.scale; // スケーリングに合わせて線幅を調整
          ctx.setLineDash([20 / obj.scale, 10 / obj.scale]); // スケーリングに合わせて点線の間隔を調整
          // オブジェクトの描画サイズを計算し、枠線を描画
          const rectWidth  = obj.type === 'text' ? ctx.measureText(obj.content).width : obj.width;
          const rectHeight = obj.type === 'text' ? obj.fontSize * 1.2 : obj.height;
          ctx.strokeRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight);
          ctx.setLineDash([]); // 点線モードをリセット
        }

        ctx.restore();
      });
    }

    /**
     * キャンバス全体をクリアし、写真とデコレーションを再描画します。
     */
    function drawAll() {
      // 1. まず背景色で全体を塗りつぶす
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
      // 2. 写真を描画
      drawImage();
      // 3. デコレーションを描画
      drawDecorations();
    }

    /**
     * マウス/タッチイベントのクライアント座標をキャンバス内の論理座標に変換します。
     * @param {number} clientX - イベントのclientX座標
     * @param {number} clientY - イベントのclientY座標
     * @returns {{x: number, y: number}} キャンバス内の座標
     */
    function getCanvasCoords(clientX, clientY) {
      const rect = mainCanvas.getBoundingClientRect(); // キャンバスの画面上での位置とサイズ
      const x = (clientX - rect.left) * (mainCanvas.width / rect.width);
      const y = (clientY - rect.top) * (mainCanvas.height / rect.height);
      return { x, y };
    }

    /**
     * 指定された点がオブジェクトの境界内にあるか判定します。
     * @param {{x: number, y: number}} p - 判定したい点（キャンバス座標）
     * @param {object} obj - 判定対象のオブジェクト
     * @returns {boolean} 点がオブジェクト内にあるか
     */
    function isPointInObject(p, obj) {
      // 1. 点をオブジェクトのローカル座標系に変換する (逆変換)
      // まずオブジェクトの中心を原点に移動
      const translatedX = p.x - obj.x;
      const translatedY = p.y - obj.y;

      // 回転を元に戻す
      const cos = Math.cos(-obj.rotation);
      const sin = Math.sin(-obj.rotation);
      const rotatedX = translatedX * cos - translatedY * sin;
      const rotatedY = translatedX * sin + translatedY * cos;

      // スケールを元に戻す
      const scaledX = rotatedX / obj.scale;
      const scaledY = rotatedY / obj.scale;

      // 2. オブジェクトのローカル座標系での幅と高さを計算
      let objWidth, objHeight;
      if (obj.type === 'text') {
        // テキストの場合、現在のフォント設定でテキストの実際の幅を測定
        ctx.save();
        ctx.font = `${obj.fontSize}px ${obj.fontFamily}`; // オリジナルのフォントサイズで測定
        objWidth = ctx.measureText(obj.content).width;
        objHeight = obj.fontSize * 1.2; // テキストの高さは行高を考慮
        ctx.restore();
      } else if (obj.type === 'image') {
        objWidth = obj.width;
        objHeight = obj.height;
      } else {
          return false; // 未知のタイプ
      }

      const halfObjWidth = objWidth / 2;
      const halfObjHeight = objHeight / 2;

      // 3. 変換された点が、オブジェクトのローカル境界ボックス内にあるか判定
      return scaledX >= -halfObjWidth && scaledX <= halfObjWidth &&
             scaledY >= -halfObjHeight && scaledY <= halfObjHeight;
    }

    // --- イベントリスナー ---
    /**
     * 画像ファイルの読み込み処理
     */
    imageLoader.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        uploadedImg = new Image();
        uploadedImg.onload = () => {
          // 写真オブジェクトの初期位置、スケール、回転を設定
          photoObject = {
            x: mainCanvas.width / 2, // キャンバス中央
            y: mainCanvas.height / 2, // キャンバス中央
            scale: 1,
            rotation: 0
          };

          // ====> ここに以下のコードを追加します <====
      
          // 写真がアップロードされたら背景色を白にリセット
                backgroundColor = '#ffffff'; 
                
          // ====> ここまで <====


          isPhotoLocked = false; // 写真編集を可能にする
          reEditPhotoBtn.style.display = 'none'; // 再編集ボタンは非表示
          confirmPhotoBtn.style.display = 'block'; // 確定ボタンを表示
          areaDecorations.style.display = 'none'; // デコレーションエリアを非表示
          areaResult.style.display = 'none'; // 完成イメージエリアも非表示にリセット
          drawAll(); // 全体を再描画
        };
        uploadedImg.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    /**
     * うちわテンプレートの選択変更処理
     */
    templateSelector.addEventListener('change', e => {
      // 低解像度テンプレートに切り替えて表示
      templateOverlay.src = e.target.selectedOptions[0].dataset.lowres;
    });
    
    // ====> この行の直後に追加 <====

    // 新規追加: 背景色ピッカーの変更イベント
    backgroundColorPicker.addEventListener('input', (e) => {
        backgroundColor = e.target.value; 
        // メンバーカラーピッカーの背景色を、選択された色にリアルタイムで更新
        e.target.style.backgroundColor = e.target.value; 
        uploadedImg = null; 
        photoObject = null;
        isPhotoLocked = true;
        areaDecorations.style.display = 'block'; 
        reEditPhotoBtn.style.display = 'none';
        confirmPhotoBtn.style.display = 'none';
        drawAll(); 
    });

    // ====> ここまで <====



    /**
     * 写真の配置確定ボタンの処理
     */
    confirmPhotoBtn.addEventListener('click', () => {
      if (!uploadedImg) return; // 写真がアップロードされていなければ何もしない
      isPhotoLocked = true; // 写真をロック
      confirmPhotoBtn.style.display = 'none'; // 確定ボタンを非表示
      reEditPhotoBtn.style.display = 'block'; // 再編集ボタンを表示
      areaDecorations.style.display = 'block'; // デコレーションエリアを表示
      document.getElementById('area-decorations').scrollIntoView({ behavior: 'smooth' }); // デコレーションエリアへスクロール
      saveState(); // 最初のデコレーション状態を保存
    });

    /**
     * 写真の再編集ボタンの処理
     */
    reEditPhotoBtn.addEventListener('click', () => {
      isPhotoLocked = false; // 写真のロックを解除
      reEditPhotoBtn.style.display = 'none'; // 再編集ボタンを非表示
      confirmPhotoBtn.style.display = 'block'; // 確定ボタンを表示
      areaDecorations.style.display = 'none'; // デコレーションエリアを非表示
      selectedObject = null; // 選択中のデコレーションオブジェクトを解除
      areaResult.style.display = 'none'; // 完成イメージエリアも非表示にリセット
      drawAll(); // 全体を再描画
    });

    /**
     * 決定 → プレビューボタンの処理
     */
    generateBtn.addEventListener('click', () => {
      // ... 既存のチェックロジック ...

      // 高解像度での最終画像を生成するためのオフスクリーンキャンバス
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = mainCanvas.width;
      tempCanvas.height = mainCanvas.height;
      const tempCtx = tempCanvas.getContext('2d');

      // 1. まず背景色で全体を塗りつぶす
      tempCtx.fillStyle = backgroundColor;
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

      // 2. 写真を描画（存在する場合）
      if (uploadedImg) {
        tempCtx.save();
        tempCtx.translate(photoObject.x, photoObject.y);
        tempCtx.rotate(photoObject.rotation);
        tempCtx.scale(photoObject.scale, photoObject.scale);
        tempCtx.drawImage(uploadedImg, -uploadedImg.width / 2, -uploadedImg.height / 2);
        tempCtx.restore();
      }

      // 3. デコレーションを描画
      decorationObjects.forEach(obj => {
        tempCtx.save();
        tempCtx.translate(obj.x, obj.y);
        tempCtx.rotate(obj.rotation);
        tempCtx.scale(obj.scale, obj.scale);

        if (obj.type === 'text') {
          tempCtx.font = `${obj.fontSize}px ${obj.fontFamily}`;
          tempCtx.textAlign = 'center';
          tempCtx.textBaseline = 'middle';

          // --- 縁取り（アウトライン） ---
          if (obj.outlineEnabled) {
            const ratio = obj.outlineWidthRatio || 0.12;
            tempCtx.lineWidth = Math.max(1, obj.fontSize * ratio);
            tempCtx.strokeStyle = obj.outlineColor || '#ffffff';
            tempCtx.lineJoin = 'round'; // 角を丸くする
            tempCtx.miterLimit = 2;
            tempCtx.strokeText(obj.content, 0, 0);
          }

          // --- 本体（塗りつぶし） ---
          tempCtx.fillStyle = obj.color;
          tempCtx.fillText(obj.content, 0, 0);

        } else if (obj.type === 'image') {
          tempCtx.drawImage(obj.img, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
        }

        tempCtx.restore();
      });

      // 4. 高解像度うちわテンプレートを重ねる
      const templateHighRes = new Image();
      templateHighRes.onload = () => {
        tempCtx.drawImage(templateHighRes, 0, 0, tempCanvas.width, tempCanvas.height);
        previewImage.src = tempCanvas.toDataURL('image/png'); // 完成イメージをDataURLとして設定

        areaResult.style.display = 'block'; // ★ 完成イメージエリア全体を表示
        previewWrapper.style.display = 'block'; // プレビュー表示エリアを表示
        goToOrderFormBtn.style.display = 'block'; // 注文フォームボタンを表示

        // 保存案内メッセージ
        previewNotice.innerHTML = `iPhone：画像を👆長押しして「“写真”に追加」を選んで保存してください。<br>Android：画像を👆長押しして「画像を保存」を選択してください。`;
        areaResult.scrollIntoView({ behavior: 'smooth' }); // 完成イメージエリアへスクロール
      };
      templateHighRes.src = templateSelector.value; // 選択された高解像度テンプレートを読み込む
    });

    // --- デコレーションオブジェクト追加機能 ---
    /**
     * 自由テキストをデコレーションとして追加します。
     */
    function addTextToOverlay() {
      const text = customText.value.trim();
      if (!text) return; // テキストが空なら何もしない
      const newText = {
        id: Date.now(), // 一意なID
        type: 'text',
        content: text,
        x: mainCanvas.width / 2, // キャンバス中央に配置
        y: mainCanvas.height / 2,
        scale: 1,
        rotation: 0,
        color: colorPicker.value,
        fontFamily: fontPicker.value,
        fontSize: 500, // 初期フォントサイズ

        outlineEnabled: outlineToggle.checked,
        outlineColor: outlineColorPicker.value,
        outlineWidthRatio: parseInt(outlineWidthPercent.value, 10) / 100,
      };

      decorationObjects.push(newText); // 配列に追加
      selectedObject = newText; // 追加したものを選択状態にする
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    }

    // PNGステッカー画像を事前に読み込む
    const stampImages = {};
    const pngStickers = ['01loveu.png', '02ntwithFace.png', '03eyestome.png', '04getmyheart.png',  '05angel.png', '06god.png', '07precious.png'];
    pngStickers.forEach(src => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        stampImages[src] = img; // 読み込み完了後、オブジェクトに格納
      };
    });

    /**
     * スタンプ（絵文字またはPNG画像）をデコレーションとして追加します。
     * @param {string} content - 絵文字文字列またはPNG画像ファイル名
     */
    function addStamp(content) { 
      if (content.endsWith('.png')) {
        // 画像ステッカーの場合
        const img = new Image();
        img.src = content;

        const newStamp = {
          id: Date.now(),
          type: 'image',
          src: content,
          img: img,
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
          scale: 1,
          rotation: 0,
          width: 200,  // 仮のサイズ（読み込み前）
          height: 200
        };

        img.onload = () => {
          // 本当のサイズをセット
          newStamp.width = img.naturalWidth;
          newStamp.height = img.naturalHeight;

          // 大きすぎる場合はリサイズ
          const maxDim = Math.max(newStamp.width, newStamp.height);
          const targetSize = 400; // 初期表示サイズの目標
          if (maxDim > targetSize) {
            const scaleFactor = targetSize / maxDim;
            newStamp.width *= scaleFactor;
            newStamp.height *= scaleFactor;
          }

          // 配列に追加・選択・描画
          decorationObjects.push(newStamp);
          selectedObject = newStamp;
          drawAll();
          saveState();
        };

      } else {
        // テキストや絵文字の場合
        const newStamp = {
          id: Date.now(),
          type: 'text',
          content: content,
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
          scale: 1,
          rotation: 0,
          color: 'black',
          fontFamily: 'sans-serif',
          fontSize: 500
        };

        decorationObjects.push(newStamp);
        selectedObject = newStamp;
        drawAll();
        saveState();
      }
    }


    // --- デコレーションオブジェクトの編集コントロール ---
    /**
     * デコレーションオブジェクトの選択を切り替えます。
     */
    const _selectBtn = document.getElementById('selectBtn'); // ★追加①：ボタンを変数に入れる
    if (_selectBtn) {                                        // ★追加②：ボタンがある時だけ中を実行
      _selectBtn.addEventListener('click', () => {           // ← 元の行を _selectBtn に差し替えて中へ移動
        if (decorationObjects.length === 0) return;
        const currentIndex = decorationObjects.indexOf(selectedObject);
        const nextIndex = (currentIndex + 1) % decorationObjects.length;
        selectedObject = decorationObjects[nextIndex];
        drawAll();
      });
    } // ← if の閉じカッコ（新規ではないけど、②を開いたのでここで閉じます）

    document.getElementById('undoBtn').addEventListener('click', undo); // 戻るボタン
    document.getElementById('redoBtn').addEventListener('click', redo); // やり直しボタン

    /**
     * 選択中のデコレーションオブジェクトを削除します。
     */
    document.getElementById('deleteBtn').addEventListener('click', () => {
      if (!selectedObject) return;
      decorationObjects = decorationObjects.filter(obj => obj !== selectedObject); // 選択中のオブジェクトを除外
      selectedObject = null; // 選択状態を解除
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    });

    /**
     * 選択中のデコレーションオブジェクトを複製します。
     */
    document.getElementById('duplicateBtn').addEventListener('click', () => {
      if (!selectedObject) return;
      // 選択オブジェクトを一度シリアライズしてから戻す（img は消えるが、後で src から再作成）
      const plain = JSON.parse(JSON.stringify(selectedObject));
      const newObj = Object.assign({}, plain);
      newObj.id = Date.now();
      newObj.x += 20;
      newObj.y += 20;

      if (newObj.type === 'image') {
        // 画像の場合は src から Image を作る/使う
        const img = (typeof stampImages !== 'undefined' && stampImages[newObj.src]) ? stampImages[newObj.src] : new Image();
        img.src = newObj.src;
        newObj.img = img;
      }

      decorationObjects.push(newObj);
      selectedObject = newObj;
      drawAll();
      saveState();
    });

    /**
     * 選択中のデコレーションオブジェクトを背面へ移動します。
     */
    document.getElementById('sendBackwardBtn').addEventListener('click', () => {
      const index = decorationObjects.indexOf(selectedObject);
      if (index > 0) { // 最前面でなければ
        const obj = decorationObjects.splice(index, 1)[0]; // 選択中のオブジェクトを配列から取り出す
        decorationObjects.splice(index - 1, 0, obj); // 一つ前の位置に挿入
        drawAll(); // 全体を再描画
        saveState(); // 状態を履歴に保存
      }
    });

    /**
     * 選択中のデコレーションオブジェクトを前面へ移動します。
     */
    document.getElementById('bringForwardBtn').addEventListener('click', () => {
      const index = decorationObjects.indexOf(selectedObject);
      if (index < decorationObjects.length - 1) { // 最背面でなければ
        const obj = decorationObjects.splice(index, 1)[0]; // 選択中のオブジェクトを配列から取り出す
        decorationObjects.splice(index + 1, 0, obj); // 一つ後の位置に挿入
        drawAll(); // 全体を再描画
        saveState(); // 状態を履歴に保存
      }
    });

    // --- テキストデコレーションのリアルタイム更新 ---
    customText.addEventListener('input', () => {
      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.content = customText.value; // テキスト内容を更新
        drawAll(); // 全体を再描画
      }
    });

    colorPicker.addEventListener('input', (e) => {
      // 自由テキスト用カラーピッカーの背景色を、選択された色にリアルタイムで更新
      e.target.style.backgroundColor = e.target.value;

      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.color = colorPicker.value; // 色を更新
        drawAll(); // 全体を再描画
      }
    });

    fontPicker.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.fontFamily = fontPicker.value; // フォントを更新
        drawAll(); // 全体を再描画
      }
    });

    // ← この下に追加！
    outlineColorPicker.addEventListener('input', (e) => {
      // 縁取りカラーピッカーの見た目をリアルタイムで更新
      e.target.style.backgroundColor = e.target.value;

      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.outlineColor = outlineColorPicker.value;
        drawAll();
      }
    });

    function updateSelectedTextOutline(updater) {
      if (selectedObject && selectedObject.type === 'text') {
        updater(selectedObject);
        drawAll(); // 再描画（あなたのコードでは drawDecorations() かもしれません）
      }
    }

    outlineToggle.addEventListener('change', () => {
      updateSelectedTextOutline(obj => obj.outlineEnabled = outlineToggle.checked);
    });
    outlineColorPicker.addEventListener('input', () => {
      updateSelectedTextOutline(obj => obj.outlineColor = outlineColorPicker.value);
    });
    outlineWidthPercent.addEventListener('input', () => {
      outlineWidthValue.textContent = outlineWidthPercent.value + '%';
      updateSelectedTextOutline(obj => obj.outlineWidthRatio = parseInt(outlineWidthPercent.value, 10) / 100);
    });


    // --- Hammer.js によるタッチ/マウスジェスチャーハンドリング ---
    const hammertime = new Hammer(mainCanvas);
    hammertime.get('pinch').set({ enable: true });
    hammertime.get('rotate').set({ enable: true });

    // 操作対象のオブジェクトを返すヘルパー関数
    function getActiveObject() {
        if (!isPhotoLocked) {
            return photoObject; // 写真編集中は写真がターゲット
        } else if (selectedObject) {
            return selectedObject; // デコレーション編集中は選択中のデコレーションがターゲット
        }
        return null; // 何も操作対象がない場合
    }

    // タップでデコレーションを選択
    hammertime.on('tap', function(e) {
      if (isPhotoLocked) { // 写真がロックされている場合のみデコレーションを選択
        const p = getCanvasCoords(e.srcEvent.clientX, e.srcEvent.clientY); // タッチ位置をキャンバス座標に変換
        let found = false;
        // Zオーダーを考慮し、配列の最後（最も手前）から逆順に判定
        for (let i = decorationObjects.length - 1; i >= 0; i--) {
          const obj = decorationObjects[i];
          if (isPointInObject(p, obj)) {
            selectedObject = obj; // オブジェクトを選択状態にする
            drawAll(); // 全体を再描画
            found = true;
            break;
          }
        }
        if (!found) { // どのオブジェクトも選択されなかった場合
          selectedObject = null; // 選択状態を解除
          drawAll(); // 全体を再描画
        }
      }
    });

    // パン（移動）ジェスチャー
    hammertime.on('panstart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            initialObjX = activeObj.x;
            initialObjY = activeObj.y;
            // ジェスチャー開始時のタッチ中心点をキャンバス座標で記録
            const touchCenter = getCanvasCoords(e.center.x, e.center.y);
            initialTouchCenterX = touchCenter.x;
            initialTouchCenterY = touchCenter.y;
        }
    });
    hammertime.on('pan', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            // 現在のタッチ中心点をキャンバス座標で取得
            const currentTouchCenter = getCanvasCoords(e.center.x, e.center.y);
            // オブジェクトの新しい位置は、開始時の位置にタッチ中心点の移動量を加算
            activeObj.x = initialObjX + (currentTouchCenter.x - initialTouchCenterX);
            activeObj.y = initialObjY + (currentTouchCenter.y - initialTouchCenterY);
            drawAll();
        }
    });
    hammertime.on('panend', function() {
        if(isPhotoLocked) saveState(); // デコレーション移動後に履歴保存
    });

    // ピンチ（拡大縮小）ジェスチャー
    hammertime.on('pinchstart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            initialObjX = activeObj.x;
            initialObjY = activeObj.y;
            initialObjScale = activeObj.scale;
            initialObjRotation = activeObj.rotation; // 回転も考慮
            const touchCenter = getCanvasCoords(e.center.x, e.center.y);
            initialTouchCenterX = touchCenter.x;
            initialTouchCenterY = touchCenter.y;

            // オブジェクトの中心からタッチ中心への初期ベクトル (キャンバス座標系)
            initialVecOffsetX = initialTouchCenterX - initialObjX;
            initialVecOffsetY = initialTouchCenterY - initialObjY;
        }
    });
    
    // --- ここに追加する ---
    // スケールの範囲を制限する関数
    function clampScale(s) {
      const MIN = 0.1;   // 最小 10%
      const MAX = 10;    // 最大 10倍
      return Math.min(MAX, Math.max(MIN, s));
    }
    // --- ここまで追加 ---

    hammertime.on('pinch', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            const currentTouchCenter = getCanvasCoords(e.center.x, e.center.y);
            const newScale = initialObjScale * e.scale;
            // newRotationはpinchイベントにもe.rotationがある場合があるので、それを使うかinitialObjRotationを使用
            // Hammer.jsのe.rotationはジェスチャー開始時からの相対値なので、そのまま利用する
            const currentRotationDelta = e.rotation * Math.PI / 180; // Hammer.jsは度数法なのでラジアンに変換

            // 初期ベクトルを現在のスケール倍率でスケーリング
            const scaledOffsetX = initialVecOffsetX * (newScale / initialObjScale);
            const scaledOffsetY = initialVecOffsetY * (newScale / initialObjScale);

            // スケーリングされたベクトルを回転量の差分で回転
            const cos_rot_delta = Math.cos(currentRotationDelta);
            const sin_rot_delta = Math.sin(currentRotationDelta);

            const transformedOffsetX = scaledOffsetX * cos_rot_delta - scaledOffsetY * sin_rot_delta;
            const transformedOffsetY = scaledOffsetX * sin_rot_delta + scaledOffsetY * cos_rot_delta;

            // 新しいオブジェクトの中心 = 現在のタッチ中心 - (オブジェクトからタッチへの変換済みベクトル)
            activeObj.x = currentTouchCenter.x - transformedOffsetX;
            activeObj.y = currentTouchCenter.y - transformedOffsetY;
            
            activeObj.scale = newScale; // スケールを更新
            activeObj.rotation = initialObjRotation + currentRotationDelta; // 回転を更新 (初期回転 + デルタ)
            drawAll();
        }
    });
    hammertime.on('pinchend', function() {
        if(isPhotoLocked) saveState(); // デコレーション拡大縮小後に履歴保存
    });

    // 回転ジェスチャー
    hammertime.on('rotatestart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            initialObjX = activeObj.x;
            initialObjY = activeObj.y;
            initialObjScale = activeObj.scale; // スケールも考慮
            initialObjRotation = activeObj.rotation;
            const touchCenter = getCanvasCoords(e.center.x, e.center.y);
            initialTouchCenterX = touchCenter.x;
            initialTouchCenterY = touchCenter.y;

            // オブジェクトの中心からタッチ中心への初期ベクトル（キャンバス座標系）
            initialVecOffsetX = initialTouchCenterX - initialObjX;
            initialVecOffsetY = initialTouchCenterY - initialObjY;
        }
    });
    hammertime.on('rotate', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            const currentTouchCenter = getCanvasCoords(e.center.x, e.center.y);
            const newRotation = initialObjRotation + e.rotation * Math.PI / 180; // 新しい回転角度 (ラジアン)
            // scaleコンポーネントはrotateイベントにも含まれる場合があるため、それを使用するかinitialObjScaleを使用
            const currentScale = initialObjScale * (e.scale || 1); // Hammer.jsのe.scaleはジェスチャー開始時からの相対値

            // 初期ベクトルを現在のスケール倍率でスケーリング
            const scaledOffsetX = initialVecOffsetX * (currentScale / initialObjScale);
            const scaledOffsetY = initialVecOffsetY * (currentScale / initialObjScale);

            // スケーリングされたベクトルを回転量の差分で回転
            const rotationDelta = e.rotation * Math.PI / 180; // Hammer.jsのe.rotationはデルタ
            const cos_rot_delta = Math.cos(rotationDelta);
            const sin_rot_delta = Math.sin(rotationDelta);

            const transformedOffsetX = scaledOffsetX * cos_rot_delta - scaledOffsetY * sin_rot_delta;
            const transformedOffsetY = scaledOffsetX * sin_rot_delta + scaledOffsetY * cos_rot_delta;

            // 新しいオブジェクトの中心 = 現在のタッチ中心 - (オブジェクトからタッチへの変換済みベクトル)
            activeObj.x = currentTouchCenter.x - transformedOffsetX;
            activeObj.y = currentTouchCenter.y - transformedOffsetY;
            
            activeObj.rotation = newRotation; // 回転を更新
            activeObj.scale = currentScale; // スケールも更新
            drawAll();
        }
    });
    hammertime.on('rotateend', function() {
        if(isPhotoLocked) saveState(); // デコレーション回転後に履歴保存
    });


    // --- PC向けマウスイベントハンドリング ---
    let isDragging = false; // ドラッグ中かどうかのフラグ
    let lastPos = { x: 0, y: 0 }; // 前回のマウス位置 (クライアント座標)
    let dragTarget = null; // 'photo', 'decoration', 'rotate-photo', 'rotate-decoration'

    mainCanvas.addEventListener('mousedown', function(e) {
      const p = getCanvasCoords(e.clientX, e.clientY); // クリック位置をキャンバス座標に変換
      isDragging = true;
      lastPos = { x: e.clientX, y: e.clientY }; // クライアント座標を保存

      if (e.button === 0) { // 左クリック（移動）
        if (!isPhotoLocked) {
          dragTarget = 'photo';
        } else {
          selectedObject = null; // まず選択を解除
          // デコレーションを逆順で探し、一番手前のものを選択
          for (let i = decorationObjects.length - 1; i >= 0; i--) {
            const obj = decorationObjects[i];
            if (isPointInObject(p, obj)) {
              selectedObject = obj;
              dragTarget = 'decoration';
              break;
            }
          }
        }
      } else if (e.button === 2) { // 右クリック（回転）
        if (!isPhotoLocked) {
          dragTarget = 'rotate-photo';
        } else if (selectedObject) {
          dragTarget = 'rotate-decoration';
        }
      }
      drawAll();
    });

    mainCanvas.addEventListener('mousemove', function(e) {
      if (!isDragging || !dragTarget) return;

      // 移動量をキャンバスの論理ピクセルに変換
      const dx_canvas = (e.clientX - lastPos.x) * (mainCanvas.width / mainCanvas.getBoundingClientRect().width);
      const dy_canvas = (e.clientY - lastPos.y) * (mainCanvas.height / mainCanvas.getBoundingClientRect().height);

      if (dragTarget === 'photo') {
        photoObject.x += dx_canvas;
        photoObject.y += dy_canvas;
      } else if (dragTarget === 'decoration' && selectedObject) {
        selectedObject.x += dx_canvas;
        selectedObject.y += dy_canvas;
      } else if (dragTarget === 'rotate-photo') {
        photoObject.rotation += dx_canvas * 0.0005; // マウスの横移動量に応じて回転（調整済み）
      } else if (dragTarget === 'rotate-decoration' && selectedObject) {
        selectedObject.rotation += dx_canvas * 0.0005; // マウスの横移動量に応じて回転（調整済み）
      }

      lastPos = { x: e.clientX, y: e.clientY };
      drawAll();
    });

    mainCanvas.addEventListener('mouseup', function(e) {
      isDragging = false;
      dragTarget = null;
      if(isPhotoLocked) saveState(); // デコレーション操作後に履歴保存
    });

    mainCanvas.addEventListener('mouseleave', function() {
      isDragging = false;
      dragTarget = null;
    });

    // 右クリックメニューを無効化
    mainCanvas.addEventListener('contextmenu', e => e.preventDefault());

    // 初期描画
    drawAll();
  </script>
</body>
</html>