<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Myうちわ - デコレーション</title>
  <!-- 推し活にぴったりなフォントを読み込み -->
  <link href="https://fonts.googleapis.com/css2?family=Cherry+Bomb+One&family=DotGothic16&family=Kaisei+Tokumin&family=Train+One&family=M+PLUS+Rounded+1c:wght@800&family=Kosugi+Maru&family=M+PLUS+1p:wght@800&family=Reggae+One&family=RocknRoll+One&family=Yomogi&family=Hachi+Maru+Pop&display=swap" rel="stylesheet">

  <style>
    /* 全体的なスタイル */
    body {
      font-family: 'Arial', sans-serif; /* 基本フォント設定 */
      text-align: center;
      background: linear-gradient(135deg, #f0f7ff, #eaf6ff); /* 背景グラデーション */
      margin: 0;
      padding: 10px;
      color: #333;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 20px;
      color: #1565c0;
    }
    .area {
      background: #fff; /* 白い背景のカード */
      border-radius: 20px; /* 角丸 */
      padding: 16px;
      margin-bottom: 16px; /* 間隔を少し詰める */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* 影 */
    }
    .area h2 {
      font-size: 16px;
      margin-top: 0;
      margin-bottom: 12px;
      color: #1565c0;
    }

    /* エディタ（キャンバス）のラッパー */
    #editorWrapper {
      position: relative;
      width: 100%;
      max-width: 900px; /* 最大幅 */
      /* 見た目比率を A3 に合わせる（実際の論理サイズは mainCanvas の width/height で決まる）*/
      aspect-ratio: 4961 / 3508; /* A3 比率（幅:x 高さ） */
      margin: 0 auto;
      background-color: #f9f9f9;


      overflow: hidden;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    /* メインキャンバスとオーバーレイキャンバス */
    #mainCanvas, #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      touch-action: none; /* タッチイベントのデフォルト動作を無効化 */
    }
    /* うちわテンプレート画像（低解像度版） */
    #templateOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* クリックイベントを透過 */
      object-fit: contain; /* アスペクト比を保ちつつ要素内に収める */
    }

    /* フォーム要素の共通スタイル */
    select, input[type="text"], input[type="color"], button, label {
      display: block;
      width: 100%;
      margin: 10px 0;
      padding: 12px;
      border-radius: 12px;
      font-size: 16px;
      border: 1px solid #ccc;
      background: #fff;
      box-sizing: border-box;
    }
    /* ボタンの共通スタイル */
    button {
      background: #4cafef;
      color: white;
      font-size: 16px;
      padding: 12px 24px;
      border-radius: 30px;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s, background 0.3s; /* ホバー時のアニメーション */
    }
    button:hover {
      background: #2196f3;
      transform: translateY(-2px);
    }
    /* ファイル選択ボタンのカスタムスタイル */
    #customFileLabel {
      background: linear-gradient(135deg, #4cafef, #2196f3);
      color: #fff;
      border-radius: 30px;
      padding: 14px 26px;
      cursor: pointer;
      font-size: 16px;
      transition: 0.3s;
      display: inline-block; /* ボタンのように表示 */
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
    }
    #customFileLabel:hover {
      background: linear-gradient(135deg, #42a5f5, #1e88e5);
      transform: scale(1.05);
    }
    /* フォームへ進むボタンのスタイル */
    .form-button {
      background: linear-gradient(135deg, #2196f3, #1976d2);
      color: white;
      padding: 12px 24px;
      margin-top: 20px;
      text-decoration: none;
      font-weight: bold;
      font-size: 18px;
      border-radius: 30px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      display: block;
      width: auto; /* コンテンツに合わせて幅を調整 */
      margin-left: auto;
      margin-right: auto;
    }
    .form-button:hover {
      background: linear-gradient(135deg, #1976d2, #0d47a1);
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
    }
    /* プレビュー画像のスタイル */
    #previewWrapper img {
      max-width: 100%;
      border: 6px solid #fff;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      margin-top: 12px;
    }
    /* 選択中のオブジェクトの枠線 */
    .active-object-outline {
      outline: 2px dashed #42a5f5; /* 点線で表示 */
      outline-offset: 5px; /* 要素からのオフセット */
    }
    /* エディタの初期背景（うちわの形状）*/
    #editorWrapper::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url(fan1-lowres.png) no-repeat center center / contain; /* デフォルトうちわの形 */
      pointer-events: none;
      opacity: 0.5; /* 半透明 */
    }

    /* スタンプボタン専用スタイル */
    .stamp-buttons-container {
      display: flex;
      flex-wrap: wrap;
      gap: 5px; /* ボタン間の隙間を均一に */
      justify-content: center;
      margin-top: 8px; /* スタンプエリアの上マージンを調整 */
      margin-bottom: 8px; /* スタンプエリアの下マージンを調整 */
    }
    .stamp-buttons-container .stamp-button {
      width: auto; /* コンテンツに合わせて幅を調整 */
      min-width: 45px; /* 最低幅を確保し、タッチしやすくする */
      padding: 8px 12px; /* パディングを調整 */
      font-size: 24px; /* 絵文字のサイズを大きく */
      display: inline-flex; /* flexアイテムとして表示し、中央揃え */
      align-items: center;
      justify-content: center;
      height: 45px; /* ボタンの高さを固定 */
      margin: 0; /* flex containerでgapを指定するため、個別のmarginをリセット */
      box-shadow: 0 2px 4px rgba(0,0,0,0.15); /* 影を少し控えめに */
    }

    .stamp-buttons-container .stamp-button img {
        height: 30px; /* 画像スタンプのサイズを調整 */
        vertical-align: middle; /* 垂直方向中央揃え */
    }

    /* メンバーカラー用カラーピッカーの背景色 */
    #backgroundColorPicker {
        background-color: #ffe6f2; /* 薄いピンク色 */
    }

    /* 自由テキスト用カラーピッカーの背景色 */
    #colorPicker {
        background-color: #ffe6f2; /* 薄いピンク色 */
    }

    /* 編集ツールボタンのレイアウト調整 */
    .edit-tools-container {
      display: flex;
      flex-wrap: wrap;
      gap: 3px; /* ボタン間の隙間をさらに詰める */
      justify-content: center;
      margin-top: 8px; /* 編集ツールエリアの上マージンを維持 */
    }
    .edit-tools-container button {
        flex: 0 0 auto; /* 固定幅にせず、内容に合わせて伸縮 */
        padding: 6px 10px; /* パディングをさらに小さく */
        font-size: 13px; /* フォントサイズをさらに小さく */
        margin: 0; /* flex containerでgapを指定するため、個別のmarginをリセット */
        min-width: 60px; /* 最低幅を調整 */
    }

    /* 自由テキスト入力エリア内の要素の間隔調整 */
    #customText {
      margin-bottom: 8px; /* 自由テキスト入力の下マージン */
      padding: 10px; /* パディングも少し小さく */
    }
    #area-decorations > h3:nth-of-type(1) + input[type="text"] + div { /* 自由テキストのカラーピッカーとフォントピッカーを含むdiv */
      margin-top: 8px;
      margin-bottom: 8px;
    }
    #area-decorations button[onclick="addTextToOverlay()"] {
      margin-top: 8px; /* テキスト追加ボタンの上マージン */
      margin-bottom: 16px; /* 次のセクションへのマージン */
    }

    /* うちわのデザイン選択ラベルから縁の線をなくす */
    #templateLabel {
        border: none;
        outline: none;
    }

    /* --- フォント選択ボタン用の見た目 --- */
    .font-picker-wrap { position: relative; flex: 1; }

    #fontPickerBtn {
      width: 100%;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 12px;
      background: #fff;
      font-size: 16px;
      cursor: pointer;
      text-align: left;
      color: #000;  /* ← これを追加 */
    }

    #fontDropdown {
      position: absolute;
      z-index: 9999;
      left: 0;
      right: 0;
      top: calc(100% + 6px);
      border: 1px solid #ddd;
      border-radius: 12px;
      background: #fff;
      box-shadow: 0 8px 20px rgba(0,0,0,0.08);
      max-height: 260px;
      overflow: auto;
      padding: 6px;
    }

    .font-option {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #f0f0f0;
      margin-bottom: 6px;
      cursor: pointer;
    }

    .font-option:hover { background: #f7fbff; }

    .font-sample { font-size: 20px; line-height: 1.2; }
    .font-name   { font-size: 12px; color: #666; margin-top: 2px; }

    .native-font-select {
      position: absolute !important;
      left: -9999px !important; /* 画面からよける（フォーム値は残す） */
    }

    /* === CapCut風：横スクロールツールバー === */
    .cc-toolbar {
      display: flex;
      gap: 12px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding: 8px 6px;
      margin: 8px -6px 10px;   /* 端まで広くドラッグできるように少しはみ出させる */
      border-top: 1px solid #eee;
      border-bottom: 1px solid #eee;
      scroll-snap-type: x proximity;
    }
    .cc-toolbar::-webkit-scrollbar { display: none; } /* スクロールバーを隠す（スマホ向け） */

    .cc-item {
      flex: 0 0 auto;          /* 横に並ぶ（折り返さない） */
      width: 84px;             /* 指で押しやすい幅 */
      scroll-snap-align: center;
      border: 1px solid #ddd;
      border-radius: 14px;
      background: #fff;
      padding: 8px 6px;
      text-align: center;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,.06);
    }
    .cc-item .icon { font-size: 20px; display: block; line-height: 1.2; }
    .cc-item .label { font-size: 12px; color: #333; display: block; margin-top: 4px; }

    .cc-item.active {
      background: linear-gradient(135deg, #e3f2fd, #ffffff);
      border-color: #90caf9;
      box-shadow: 0 3px 10px rgba(33,150,243,.15);
    }

    /* パネル（ツールの中身） */
    .cc-panels { margin-top: 8px; }
    .cc-panel[hidden] { display: none; }

    /* 既存のボタン群がぎゅうぎゅうにならないように少し調整 */
    .cc-panel button { margin: 4px 2px; }
    /* -------- 小型「決定」アイコンのスタイル -------- */
    .generate-icon {
      /* 基本の見た目 */
      width: 56px;
      min-width: 56px;
      height: 44px;
      padding: 6px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 2px;
      background: linear-gradient(135deg,#4cafef,#1976d2);
      color: white;
      border: none;
      box-shadow: 0 4px 10px rgba(33,150,243,0.18);
      font-size: 12px;
    }
    .generate-icon .icon { font-size: 18px; line-height: 1; }
    .generate-icon .label { font-size: 10px; opacity: 0.95; }

    /* 押下フィードバック */
    .generate-icon.pressed {
      transform: translateY(2px) scale(0.98);
      box-shadow: 0 2px 6px rgba(33,150,243,0.12) !important;
      transition: transform .08s, box-shadow .08s;
    }

    /* モバイル時：既存の大きなボタンを隠し、小アイコンは表示する */
    @media (max-width: 1024px) {
      #generateBtn {
        display: none !important;
      }
      /* ラベルを小さくしてボタン内で見映えを調整（必要なら非表示も可） */
      .generate-icon .label { display: none; } /* ラベルを消したければこの行をそのまま */
    }

    /* デスクトップでは小アイコンを補助的に表示（必要なら非表示に） */
    @media (min-width: 1025px) {
      /* 任意：PCで小アイコンを非表示にしたければ以下をアンコメント */
      /* #generateIconBtn { display: none; } */
    }
    /* ツールバー内で generate-icon を右端に寄せる（flex の空間を利用） */
    .cc-toolbar .generate-icon {
      margin-left: auto; /* これで行の最後に寄ります */
    }


    /* === 画面下固定（CapCut風） === */
    /* ツールバー本体を下固定 */
    .cc-toolbar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: env(safe-area-inset-bottom, 0);
      z-index: 1000;
      margin: 0;                 /* 既存の margin を打ち消す */
      border-top: 1px solid #eee;
      border-bottom: 0;
      background: #fff;
      padding: 8px 6px;
      display: flex;
      gap: 12px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: x proximity;
    }
    .cc-toolbar::-webkit-scrollbar { display: none; }

    /* パネル（ツールの中身）も下固定：ツールバーの“すぐ上”に出す */
    .cc-panels {
      position: fixed;
      left: 0;
      right: 0;
      /* ツールバー高さ（約64px） + セーフエリアぶんだけ持ち上げる */
      bottom: calc(64px + env(safe-area-inset-bottom, 0));
      z-index: 999;
      max-height: 42vh;          /* 片手操作で見切れない程度 */
      overflow-y: auto;
      margin: 0;                 /* 既存の margin を打ち消す */
      padding: 8px 10px 12px;
      background: #fff;
      box-shadow: 0 -4px 12px rgba(0,0,0,.08);
      border-top: 1px solid #eee;
    }
    .cc-panel[hidden] { display: none; }

    /* キャンバスが下固定UIに隠れないようボディ下に余白をつける */
    body {
      padding-bottom: calc(220px + env(safe-area-inset-bottom, 0));
    }
  </style>
</head>
<body>

  <h1 id="title">Myうちわ</h1>

  <div class="area" id="area-select">
    <h2 id="section1-title">1) 背景を決める</h2>
    <label id="templateLabel">うちわのサイズ・型を選んでね👇</label>
    <select id="templateSelector">
      <option value="fan1-highres.png" data-lowres="fan1-lowres.png">A4サイズレギュラー型</option>
      <option value="fan2-highres.png" data-lowres="fan2-lowres.png">A3サイズ♡型</option>
      <option value="fan3-highres.png" data-lowres="fan3-lowres.png">A3サイズ大型</option>
    </select>
    <label for="imageLoader" id="customFileLabel">写真で背景を作る</label>
    <input type="file" id="imageLoader" accept="image/*" style="display:none;" />
    <p id="reuploadNotice" style="font-size: 12px; color: #666;">※ 画像は何度でも選び直せます。</p>

    <h3 style="margin-top: 20px;">メンバーカラーで背景を作る</h3>
    <input type="color" id="backgroundColorPicker" value="#ff8fff" title="背景色選択" />
  </div>

  <div class="area" id="area-canvas">
    <h2 id="section2-title">2) デザイン編集スペース</h2>
    <div id="editorWrapper">
      <!-- 編集は軽量キャンバス（例：1240x877）で行う -->
      <canvas id="mainCanvas" width="1240" height="877"></canvas>
      <img id="templateOverlay" src="fan1-lowres.png" alt="うちわテンプレート">
    </div>
    <p id="editNotice" style="font-size: 12px; color: #666; margin-top: 10px;">
      ※ 画像は1本の指で位置を動かせます。2本の指で大きさや向きを変えることができます。
    </p>
    <button id="confirmPhotoBtn" style="margin-top: 10px;">写真の配置を確定</button>
    <button id="reEditPhotoBtn" style="margin-top: 10px; display: none;">写真の再編集</button>
    <!-- 追加：配置完了後の分岐コントロール（保存→プレビュー / 編集） -->
    <div id="arrangeControls" style="display:none; position: fixed; bottom: calc(78px + env(safe-area-inset-bottom, 0)); left: 50%; transform: translateX(-50%); z-index: 1100; gap:8px;">
      <button id="toPreviewBtn" class="form-button" style="display:inline-block; padding:10px 16px; margin-right:8px;">保存 → プレビュー</button>
      <button id="toEditBtn" class="form-button" style="display:inline-block; padding:10px 16px; background:#fff; color:#1976d2; border:1px solid #1976d2;">編集</button>
    </div>
  </div>

  <div class="area" id="area-decorations" style="display: none;">
    <h2 id="section3-title">3) デコレーション</h2>
    <style>
      @media (max-width: 768px) {
        #section3-title { display: none; }
      }
    </style>
    <!-- <p id="decorationNotice" style="font-size: 12px; color: #666;">
      ※ オブジェクトをタップすると選択され、移動・サイズ変更・回転できます。
    </p> -->

    <!-- ▼▼ ここから “横スライド メニュー” を追加 ▼▼ -->
    <div class="cc-toolbar" role="tablist">
      <button class="cc-item active" data-target="panel-text">
        <!-- <span class="icon">T</span> --><span class="label">テキスト</span>
      </button>
      <button class="cc-item" data-target="panel-stamp">
        <!-- <span class="icon">🌟</span> --><span class="label">スタンプ</span>
      </button>
      <button class="cc-item" data-target="panel-arrange">
        <!-- <span class="icon">📋</span> --><span class="label">複製／削除</span>
      </button>
      <button class="cc-item" data-target="panel-history">
        <!-- <span class="icon">↩ ↪</span> --><span class="label">↩ ↪</span>
      </button>
      <button class="cc-item" data-target="panel-layer">
        <!-- <span class="icon">⬆︎⬇︎</span> --><span class="label">レイヤー</span>
      </button>
      <!-- 追加：ツールバー右端の小さな「決定」ボタン（モバイル向け） -->
      <button class="cc-item generate-icon" id="generateIconBtn" title="決定・プレビュー">
         <span class=""label"">決定→プレビュー</span>
      </button>


    </div>

    <div class="cc-panels">
      <!-- テキスト -->
      <section id="panel-text" class="cc-panel">
                <input type="text" id="customText" placeholder="推しへのメッセージ♡" />
        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
          <input type="color" id="colorPicker" value="#ff69b4" title="文字色選択" style="width: 50px;" />
          <select id="fontPicker" class="native-font-select">
            <option value="Arial, sans-serif">Arial</option>
            <option value="'DotGothic16', sans-serif">ドットゴシック</option>
            <option value="'Train One', cursive">Train One</option>
            <option value="'Cherry Bomb One', cursive">手書き風</option>
            <option value="'Kaisei Tokumin', serif">丸文字</option>
            <option value="'M PLUS Rounded 1c', sans-serif">M PLUS Rounded 太字</option>
            <option value="'M PLUS 1p', sans-serif">M PLUS 1p 太字</option>
            <option value="'Kosugi Maru', sans-serif">Kosugi Maru</option>
            <option value="'Reggae One', cursive">Reggae One</option>
            <option value="'RocknRoll One', sans-serif">RocknRoll One</option>
            <option value="'Yomogi', cursive">Yomogi</option>
            <option value="'Hachi Maru Pop', cursive">Hachi Maru Pop</option>
          </select>
          <div class="font-picker-wrap">
            <button id="fontPickerBtn" type="button">フォントを選ぶ</button>
            <button onclick="addTextToOverlay()">テキスト追加</button>
            <div id="fontDropdown" hidden></div>
          </div>
        </div>

        <!-- ▼ 縁取り設定（ここから追加） -->
          <div id="outlineControls" class="control-row" style="margin-bottom: 10px;">
            <label>
              <input type="checkbox" id="outlineToggle" checked>
              縁取りON/OFF
            </label>

            <label style="margin-left:8px;">
              外側の縁の色：
              <input type="color" id="outlineColorPicker" value="#ffffff" title="縁取り色" style="width: 50px;" />
            </label>

            <label style="margin-left:8px;">
              外側の縁の太さ：
              <input type="range" id="outlineWidthPercent" min="0" max="30" value="12" step="1">
              <span id="outlineWidthValue">12%</span>
            </label>
          </div>
          <!-- ▲ 縁取り設定（ここまで追加） -->

          <!-- ▼ アーチ文字設定（ここから追加） -->
          <div id="archControls" class="control-row" style="margin:10px 0 14px;">
            <label>
              <input type="checkbox" id="archToggle">
              アーチ文字にする
            </label>

            <div style="margin-top:8px;">              
              <label style="margin-right:10px;">
                <input type="radio" name="archStyle" value="rainbow" checked> 虹型（∩）
              </label>
              <label>
                <input type="radio" name="archStyle" value="smile"> スマイル型（∪）
              </label>
            </div>

            <div style="margin-top:8px;">
              <span style="min-width:6em; display:inline-block;">カーブ：</span>
              <input type="range" id="archAmount" min="0" max="100" value="50" step="1">
              <span id="archAmountValue">50</span>
            </div>
          </div>
          <!-- ▲ アーチ文字設定（ここまで追加） -->


      </section>

      <!-- スタンプ -->
      <section id="panel-stamp" class="cc-panel" hidden>
        <h3 style="margin:6px 0 8px;">スタンプ</h3>
        <div class="stamp-buttons-container">
          <button class="stamp-button" onclick="addStamp('❤️')">❤️</button>
          <button class="stamp-button" onclick="addStamp('⭐')">⭐</button>
          <button class="stamp-button" onclick="addStamp('🎶')">🎶</button>
          <button class="stamp-button" onclick="addStamp('01loveu.png')"><img src="01loveu.png" alt="Love You"></button>
          <button class="stamp-button" onclick="addStamp('02ntwithFace.png')"><img src="02ntwithFace.png" alt="NT with Face"></button>
          <button class="stamp-button" onclick="addStamp('03eyestome.png')"><img src="03eyestome.png" alt="Eyes to me"></button>
          <button class="stamp-button" onclick="addStamp('04getmyheart.png')"><img src="04getmyheart.png" alt="Get my heart"></button>
          <button class="stamp-button" onclick="addStamp('05angel.png')"><img src="05angel.png" alt="Angel"></button>
          <button class="stamp-button" onclick="addStamp('06god.png')"><img src="06god.png" alt="God"></button>
          <button class="stamp-button" onclick="addStamp('07precious.png')"><img src="07precious.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('08osi_pink.png')"><img src="08osi_pink.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('09osi_yellow.png')"><img src="09osi_yellow.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('10osi_lightblue.png')"><img src="10osi_lightblue.png" alt="Precious"></button>
          <button class="stamp-button" onclick="addStamp('11osi_green.png')"><img src="11osi_green.png" alt="Precious"></button>
        </div>
      </section>

      <!-- 並べ替え（複製・削除） -->
      <section id="panel-arrange" class="cc-panel" hidden>
        <button id="duplicateBtn">複製</button>
        <button id="deleteBtn" style="background:#f44336;">削除</button>
      </section>

      <!-- 履歴（戻る・やり直し） -->
      <section id="panel-history" class="cc-panel" hidden>
        <button id="undoBtn">戻る</button>
        <button id="redoBtn">やり直し</button>
      </section>

      <!-- レイヤー（前面/背面） -->
      <section id="panel-layer" class="cc-panel" hidden>
        <button id="sendBackwardBtn">背面へ</button>
        <button id="bringForwardBtn">前面へ</button>
      </section>
    </div>
    <!-- ▲▲ ここまで “横スライド メニュー” ▲▲ -->

    <!-- 「決定 → プレビュー」ボタンをデコレーションエリア内に移動 -->
    <button id="generateBtn" class="form-button" style="margin-top: 20px;">決定 → プレビュー</button>
    <span style="min-width:6em; display:inline-block;">プレビュー表示に少し時間がかかります</span>
  </div>

  <div class="area" id="area-result" style="display: none;">
    <h2 id="section4-title">4) 完成イメージ</h2>
    <div id="previewWrapper">
      <img id="previewImage" alt="合成画像プレビュー" />
    </div>
    <div id="previewNotice" style="font-size:14px; color:black; margin-top:10px;"></div>

    <!-- ここから追加 -->
    <div id="previewSpinner" style="display:none; margin-top:10px; font-size:14px; align-items:center;">
      <span style="display:inline-block; width:18px; height:18px; border-radius:50%; margin-right:8px; vertical-align:middle; animation:spin 1s linear infinite; background:linear-gradient(135deg,#ff9fcf,#ff6fa6);"></span>
      画像を合成しています…（少しお待ちください）
    </div>

    <style>
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    /* 小さなスタイル：必要なら後でCSSファイルへ移動してください */
    </style>
    <!-- ここまで追加 -->

    <!-- ここから追加 -->
    <button id="makeBackBtn" class="form-button" style="display:none; margin-top:12px; background: linear-gradient(135deg, #ff9fcf, #ff6fa6);">
      🔁 裏面も作る
    </button>

    <div id="orderNote" style="font-size:12px; color:#555; margin-top:8px; display:none;">
      ※ 表と裏の画像を２枚アップロードして送信してください
    </div>
    <!-- ここまで追加 -->


    <!-- 「注文フォームへ進む」ボタンはここに残し、JavaScriptで表示制御 -->
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSf1wV724Vnag4FCcjeU1z-3vaCcfhCjAvGyU8432bu8dyciow/viewform?usp=dialog"
       target="_blank"
       class="form-button"
       id="goToOrderFormBtn"
       style="display: none;">📝 注文フォームへ進む</a>
  </div>

  <footer style="font-size: 6px; color: #888; margin-top: 20px;">
    © 2025 Chugoku Shimbun Hanbai Center. Web application developed by Hitomi Sasaki. All rights reserved.<br />
    このウェブアプリケーションは、株式会社中国新聞販売センターの従業員による地域イベント向けの自主開発プロジェクトです。<br />
    ※本アプリは公式サービスではありませんが、業務との親和性を考慮して使用されています。
  </footer>

  <!-- Hammer.jsを読み込み：タッチジェスチャーをよりスムーズにするため -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script>

    // ← ここに追加！
      window.addEventListener('DOMContentLoaded', () => {
        // 初期値をピンクに統一
        colorPicker.value = "#ff69b4";
        outlineColorPicker.value = "#ffc9d2";

        // 見た目（背景色）も更新
        colorPicker.style.backgroundColor = "#ff69b4";
        outlineColorPicker.style.backgroundColor = "#ffc9d2";
      });

    // DOM要素の取得
    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d');
    const templateOverlay = document.getElementById('templateOverlay');
    const imageLoader = document.getElementById('imageLoader');
    const templateSelector = document.getElementById('templateSelector');




    // --- ここから追加 ---
    const templateCache = {}; // src -> Image

    function preloadTemplate(src) {
      if (!src) return;
      if (templateCache[src]) return templateCache[src];
      const img = new Image();
      img.src = src;
      templateCache[src] = img;
      // decode が使えれば非同期にデコードを促す（エラーは無視）
      if (img.decode) img.decode().catch(() => {});
      return img;
    }

    // 選択が変わったらプリロード
    templateSelector.addEventListener('change', () => {
      preloadTemplate(templateSelector.value);
    });

    // ページ読み込み時に現在のテンプレートをプリロード（あれば）
    preloadTemplate(templateSelector.value);
    // --- ここまで追加 ---

    const confirmPhotoBtn = document.getElementById('confirmPhotoBtn');
    const reEditPhotoBtn = document.getElementById('reEditPhotoBtn');
    const generateBtn = document.getElementById('generateBtn');
    const goToOrderFormBtn = document.getElementById('goToOrderFormBtn');
    const customText = document.getElementById('customText');
    const colorPicker = document.getElementById('colorPicker');

    // --- 縁取りコントロールを参照する ---
    const outlineToggle = document.getElementById('outlineToggle');
    const outlineColorPicker = document.getElementById('outlineColorPicker');
    const outlineWidthPercent = document.getElementById('outlineWidthPercent');
    const outlineWidthValue = document.getElementById('outlineWidthValue');

    // --- アーチ文字コントロールを参照する ---
    const archToggle = document.getElementById('archToggle');
    const archStyleRadios = document.querySelectorAll('input[name="archStyle"]');
    const archAmount = document.getElementById('archAmount');
    const archAmountValue = document.getElementById('archAmountValue');



    // スライダーの数字を表示に反映
    outlineWidthPercent.addEventListener('input', () => {
      outlineWidthValue.textContent = outlineWidthPercent.value + '%';
    });
    const fontPicker = document.getElementById('fontPicker');

    const fontPickerBtn = document.getElementById('fontPickerBtn');
    const fontDropdown  = document.getElementById('fontDropdown');


    // === CapCut風ツールバーの表示切替 ===
    const ccToolbar = document.querySelector('.cc-toolbar');
    const ccItems   = document.querySelectorAll('.cc-item');
    const ccPanels  = document.querySelectorAll('.cc-panel');

    function showPanel(id) {
      // パネルの表示/非表示
      ccPanels.forEach(p => p.hidden = (p.id !== id));
      // アクティブ表示
      ccItems.forEach(b => b.classList.toggle('active', b.dataset.target === id));
      // 押したボタンを中央へ寄せる（横スクロールがスッと動く）
      const btn = document.querySelector(`.cc-item[data-target="${id}"]`);
      if (btn) btn.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
    }
    
    // 追加：すべての詳細パネルを閉じ、アクティブ表示もリセット
    function hidePanels() {
      ccPanels.forEach(p => p.hidden = true);
      ccItems.forEach(b => b.classList.remove('active'));
    }

    ccToolbar.addEventListener('click', (e) => {
      const btn = e.target.closest('.cc-item');
      if (!btn) return;
      showPanel(btn.dataset.target);
    });

    // 追加：ツールバー右端の小さな「決定」アイコンのクリックでプレビュー生成を呼ぶ
    (function() {
      const generateIconBtn = document.getElementById('generateIconBtn');
      // 無しでもエラーにならないよう existence check
      if (!generateIconBtn) return;

      generateIconBtn.addEventListener('click', (ev) => {
        ev.preventDefault();

        // 簡単な押下アニメーション（短く見せる）
        generateIconBtn.classList.add('pressed');
        setTimeout(() => generateIconBtn.classList.remove('pressed'), 120);

        // 既存の大ボタンがあるなら click を発火させて既存ロジックを再利用
        if (typeof generateBtn !== 'undefined' && generateBtn) {
          generateBtn.click();
          return;
        }

        // 万一 generateBtn が見つからない（将来の差し替えで消えた等）は
        // ここで直接プレビュー生成関数を呼び出すロジックを入れることもできます。
        console.warn('generateBtn not found — generateIconBtn clicked');
      });
    })();

    // 初期表示は何も開かない（選択時に自動オープン）
    hidePanels()





    // この配列の順序／内容は <select id="fontPicker"> と揃えています
    const FONT_CANDIDATES = [
      { name: 'Arial',          value: 'Arial, sans-serif' },
      { name: 'ドットゴシック',   value: "'DotGothic16', sans-serif" },
      { name: 'Train One',      value: "'Train One', cursive" },
      { name: '手書き風',        value: "'Cherry Bomb One', cursive" },
      { name: '丸文字',          value: "'Kaisei Tokumin', serif" },
      { name: 'M PLUS Rounded', value: "'M PLUS Rounded 1c', sans-serif" },
      { name: 'M PLUS 1p', value: "'M PLUS 1p', sans-serif" },
      { name: 'Kosugi Maru', value: "'Kosugi Maru', sans-serif" },
      { name: 'Reggae One', value: "'Reggae One', cursive" },
      { name: 'RocknRoll One', value: "'RocknRoll One', sans-serif" },
      { name: 'Yomogi', value: "'Yomogi', cursive" },
      { name: 'Hachi Maru Pop', value: "'Hachi Maru Pop', cursive" },
    ];

    // ドロップダウンの中身を作る
    function buildFontDropdown() {
      fontDropdown.innerHTML = '';
      FONT_CANDIDATES.forEach(f => {
        const item = document.createElement('div');
        item.className = 'font-option';

        const sample = document.createElement('div');
        sample.className = 'font-sample';
        sample.textContent = 'Aaあア愛';
        sample.style.fontFamily = f.value;

        const name = document.createElement('div');
        name.className = 'font-name';
        name.textContent = f.name;

        item.appendChild(sample);
        item.appendChild(name);

        item.addEventListener('click', () => {
          setFont(f.value, f.name);
          fontDropdown.hidden = true;
        });

        fontDropdown.appendChild(item);
      });
    }

    // 実際にフォントを選んだときの処理
    function setFont(value, label) {
      // 1) 元の<select>に値をセット
      fontPicker.value = value;

      // 2) 既存の「change」処理をそのまま動かす
      fontPicker.dispatchEvent(new Event('change', { bubbles: true }));

      // 3) ボタン自体も選んだフォントで表示
      fontPickerBtn.style.fontFamily = value;
      fontPickerBtn.textContent = 'Aa あア愛 – ' + label;
    }

    // ボタンをタップ／クリックでメニュー開閉
    fontPickerBtn.addEventListener('click', () => {
      fontDropdown.hidden = !fontDropdown.hidden;
    });

    // 外側をクリックしたら閉じる
    document.addEventListener('click', (e) => {
      const wrap = document.querySelector('.font-picker-wrap');
      if (wrap && !wrap.contains(e.target)) fontDropdown.hidden = true;
    });

    // 初期化：リストを組み立てて、最初は「フォントを選ぶ」と表示だけする
    buildFontDropdown();
    (() => {
      fontPickerBtn.textContent = 'フォントを選ぶ';
      fontPickerBtn.style.fontFamily = 'Arial, sans-serif'; // ← フォントを指定しておくと見やすい！
    })();




    const previewWrapper = document.getElementById('previewWrapper');

    // --- ここから追加 ---
    let mode = 'front'; // 'front' (表) または 'back' (裏)
    let frontImageDataUrl = null; // 表面のプレビュー画像(DataURL)を一時保存（必要なら利用）
    //
    // 注意：初期は 'front'。「裏面も作る」ボタンで 'back' に切替えます。
    // --- ここまで追加 ---





    const previewImage = document.getElementById('previewImage');
    const previewNotice = document.getElementById('previewNotice');
    const areaDecorations = document.getElementById('area-decorations');
    const areaResult = document.getElementById('area-result');
    // 追加: 背景色ピッカーの取得
    const backgroundColorPicker = document.getElementById('backgroundColorPicker');

    // 状態変数
    let uploadedImg = null;
    let photoObject = null;
    let isPhotoLocked = false;
    let decorationObjects = [];
    let selectedObject = null;
    let history = [];
    let historyIndex = -1;
    // 追加: 背景色を保持する変数
    let backgroundColor = '#ffffff'; // デフォルトは白

    // --- ここから追加 ---
    let isRendering = false; // generate処理中フラグ（多重クリック防止）
    // --- ここまで追加 ---

    // ジェスチャー開始時のオブジェクトの状態とタッチ中心
    var initialObjX, initialObjY, initialObjScale, initialObjRotation;
    var initialTouchCenterX, initialTouchCenterY;
    // オブジェクトの中心からタッチ中心への初期ベクトル（キャンバス座標系）
    var initialVecOffsetX, initialVecOffsetY; 

    // --- 履歴管理機能 ---
    /**
     * 現在のデコレーションオブジェクトの状態を履歴に保存します。
     */
    function saveState() {
      // 現在のインデックス以降の履歴を削除し、新しい状態を追加
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }

      // decorationObjects を「JSONにできる形」に変換する（img は src に置き換える）
      const snapshot = decorationObjects.map(obj => {
        if (obj.type === 'image') {
          return {
            id: obj.id,
            type: 'image',
            src: obj.src || (obj.img && obj.img.src) || '',
            x: obj.x,
            y: obj.y,
            scale: obj.scale,
            rotation: obj.rotation,
            width: obj.width,
            height: obj.height
          };
        } else {
          // text 等
          return {
            id: obj.id,
            type: obj.type,
            content: obj.content,
            x: obj.x,
            y: obj.y,
            scale: obj.scale,
            rotation: obj.rotation,
            color: obj.color,
            fontFamily: obj.fontFamily,
            fontSize: obj.fontSize,
            // ▼ 縁取り・アーチのプロパティも保存（無ければデフォルト）
            outlineEnabled: !!obj.outlineEnabled,
            outlineColor: obj.outlineColor || '#000000',
            outlineWidthRatio: (typeof obj.outlineWidthRatio === 'number') ? obj.outlineWidthRatio : 0.12,
            isArched: !!obj.isArched,
            archStyle: obj.archStyle || 'rainbow',
            archAmount: (typeof obj.archAmount === 'number') ? obj.archAmount : 50
          };
        }
      });

      // 履歴配列に追加してインデックスを進める
      history.push(JSON.stringify(snapshot));
      historyIndex++;
    }


    function restoreDecorationsFromSnapshot(snapshotStr) {
      if (!snapshotStr) {
        decorationObjects = [];
        selectedObject = null;
        drawAll();
        return;
      }
      const arr = JSON.parse(snapshotStr);
      decorationObjects = arr.map(item => {
        if (item.type === 'image') {
          // 事前読み込み済みの stampImages があれば使い、なければ新しい Image を作る
          let img = (typeof stampImages !== 'undefined' && stampImages[item.src]) ? stampImages[item.src] : new Image();
          // stampImages にない場合は src をセットして読み込み開始
          if (!stampImages || !stampImages[item.src]) {
            img.src = item.src;
          }
          // 画像がまだ読み込み中でも、読み込み完了時に再描画するようにする
          if (!img.complete) {
            img.onload = () => { drawAll(); };
          }
          return {
            id: item.id,
            type: 'image',
            src: item.src,
            img: img,
            x: item.x,
            y: item.y,
            scale: item.scale,
            rotation: item.rotation,
            width: item.width,
            height: item.height
          };
        } else {
          // text 等（過去の履歴に装飾プロパティが無い場合に備えてデフォルト補完）
          return {
            id: item.id,
            type: item.type,
            content: item.content,
            x: item.x,
            y: item.y,
            scale: item.scale,
            rotation: item.rotation,
            color: item.color,
            fontFamily: item.fontFamily,
            fontSize: item.fontSize,
            // ▼ 追加：縁取り／アーチを復元（無ければデフォルト）
            outlineEnabled: (typeof item.outlineEnabled !== 'undefined') ? item.outlineEnabled : false,
            outlineColor: item.outlineColor || '#000000',
            outlineWidthRatio: (typeof item.outlineWidthRatio === 'number') ? item.outlineWidthRatio : 0.12,
            isArched: (typeof item.isArched !== 'undefined') ? item.isArched : false,
            archStyle: item.archStyle || 'rainbow',
            archAmount: (typeof item.archAmount === 'number') ? item.archAmount : 50
          };
        }
      });

      selectedObject = null;
      drawAll();
    }

    /**
     * 一つ前の編集状態に戻します（アンドゥ）。
     */
    function undo() {
      if (historyIndex > 0) {
    historyIndex--;
        restoreDecorationsFromSnapshot(history[historyIndex]);
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreDecorationsFromSnapshot(history[historyIndex]);
      }
    }

    // --- 描画機能 ---
    /**
     * 写真をキャンバスに描画します。
     */
    function drawImage() {
      if (!photoObject || !uploadedImg) return;

      ctx.save(); // 現在のキャンバスの状態を保存
      // 写真の中心を基準に移動、回転、拡大縮小
      ctx.translate(photoObject.x, photoObject.y);
      ctx.rotate(photoObject.rotation);
      ctx.scale(photoObject.scale, photoObject.scale);
      // 画像を描画（中心座標が0,0になるようにオフセット）
      ctx.drawImage(uploadedImg, -uploadedImg.width / 2, -uploadedImg.height / 2);
      ctx.restore(); // 保存した状態に戻す
    }

    // --- 直線／アーチ文字の共通描画関数 -----------------------------
    function drawTextByStyle(ctx, obj) {
      // フォントとアラインを統一
      ctx.font = `${obj.fontSize}px ${obj.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const ratio  = obj.outlineWidthRatio || 0.12;
      const outerW = Math.max(1, obj.fontSize * ratio);
      const innerW = Math.max(1, outerW * 0.35);

      const strokeAndFill = (ch) => {
        if (obj.outlineEnabled) {
          ctx.lineJoin = 'round';
          ctx.miterLimit = 2;

          // 外側
          ctx.strokeStyle = obj.outlineColor || '#000000';
          ctx.lineWidth   = outerW;
          ctx.strokeText(ch, 0, 0);

          // 内側（白）
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth   = innerW;
          ctx.strokeText(ch, 0, 0);
        }
        // 本体
        ctx.fillStyle = obj.color;
        ctx.fillText(ch, 0, 0);
      };

      const isArched = !!obj.isArched && (obj.archAmount || 0) > 0;

      if (!isArched) {
        // まっすぐ描画（従来）
        strokeAndFill(obj.content);
        return;
      }

      // --- アーチ描画 ---
      const text = obj.content || '';
      if (!text) return;

      const chars  = [...text];
      const widths = chars.map(ch => ctx.measureText(ch).width);
      const totalWidth = widths.reduce((a, b) => a + b, 0);

      const MAX_RAD = 2.4; // 最大カーブ角（約137°）
      const amount  = Math.max(0, Math.min(100, obj.archAmount || 0));
      const theta   = Math.max(0.001, MAX_RAD * (amount / 100)); // 全体角度

      const R = totalWidth / theta; // 弧長 = R * θ
      // ← ここを入れ替えます（虹型=rainbow を U ＝下に膨らむにする）
      const dir = (obj.archStyle === 'rainbow') ? +1 : -1; // rainbow=U(下にふくらむ), smile=∩(上にふくらむ)

      let angle = -theta / 2; // 左端スタート
      for (let i = 0; i < chars.length; i++) {
        const w = widths[i];
        const charAngle = w / R;
        const mid = angle + charAngle / 2; // その文字の中心角

        const x = R * Math.sin(mid);
        const y = dir * R * (1 - Math.cos(mid)); // φ=0 で y=0 になる座標系

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(dir * mid); // 接線方向に回転

        strokeAndFill(chars[i]);

        ctx.restore();
        angle += charAngle;
      }
    }
    // --------------------------------------------------------------








    /**
     * デコレーションオブジェクト（テキスト、スタンプ）をキャンバスに描画します。
     */
    function drawDecorations() {
      decorationObjects.forEach(obj => {
        ctx.save();
        // オブジェクトの中心を基準に移動、回転、拡大縮小
        ctx.translate(obj.x, obj.y);
        ctx.rotate(obj.rotation);
        ctx.scale(obj.scale, obj.scale);

        if (obj.type === 'text') {
          drawTextByStyle(ctx, obj);


        } else if (obj.type === 'image') {
          // 画像を描画（中心座標が0,0になるようにオフセット）
          ctx.drawImage(obj.img, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
        }

        // 選択中のオブジェクトに枠線を表示
        if (obj === selectedObject) {
          ctx.strokeStyle = '#42a5f5';
          ctx.lineWidth = 10 / obj.scale; // スケーリングに合わせて線幅を調整
          ctx.setLineDash([20 / obj.scale, 10 / obj.scale]); // スケーリングに合わせて点線の間隔を調整
          // オブジェクトの描画サイズを計算し、枠線を描画
          const rectWidth  = obj.type === 'text' ? ctx.measureText(obj.content).width : obj.width;
          const rectHeight = obj.type === 'text' ? obj.fontSize * 1.2 : obj.height;
          ctx.strokeRect(-rectWidth / 2, -rectHeight / 2, rectWidth, rectHeight);
          ctx.setLineDash([]); // 点線モードをリセット
        }

        ctx.restore();
      });
    }

    /**
     * キャンバス全体をクリアし、写真とデコレーションを再描画します。
     */
    function drawAll() {
      // 1. まず背景色で全体を塗りつぶす
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
      // 2. 写真を描画
      drawImage();
      // 3. デコレーションを描画
      drawDecorations();
    }

    /**
     * マウス/タッチイベントのクライアント座標をキャンバス内の論理座標に変換します。
     * @param {number} clientX - イベントのclientX座標
     * @param {number} clientY - イベントのclientY座標
     * @returns {{x: number, y: number}} キャンバス内の座標
     */
    function getCanvasCoords(clientX, clientY) {
      const rect = mainCanvas.getBoundingClientRect(); // キャンバスの画面上での位置とサイズ
      const x = (clientX - rect.left) * (mainCanvas.width / rect.width);
      const y = (clientY - rect.top) * (mainCanvas.height / rect.height);
      return { x, y };
    }

    /**
     * 指定された点がオブジェクトの境界内にあるか判定します。
     * @param {{x: number, y: number}} p - 判定したい点（キャンバス座標）
     * @param {object} obj - 判定対象のオブジェクト
     * @returns {boolean} 点がオブジェクト内にあるか
     */
    function isPointInObject(p, obj) {
      // 1. 点をオブジェクトのローカル座標系に変換する (逆変換)
      // まずオブジェクトの中心を原点に移動
      const translatedX = p.x - obj.x;
      const translatedY = p.y - obj.y;

      // 回転を元に戻す
      const cos = Math.cos(-obj.rotation);
      const sin = Math.sin(-obj.rotation);
      const rotatedX = translatedX * cos - translatedY * sin;
      const rotatedY = translatedX * sin + translatedY * cos;

      // スケールを元に戻す
      const scaledX = rotatedX / obj.scale;
      const scaledY = rotatedY / obj.scale;

      // 2. オブジェクトのローカル座標系での幅と高さを計算
      let objWidth, objHeight;
      if (obj.type === 'text') {
        // テキストの場合、現在のフォント設定でテキストの実際の幅を測定
        ctx.save();
        ctx.font = `${obj.fontSize}px ${obj.fontFamily}`; // オリジナルのフォントサイズで測定
        objWidth = ctx.measureText(obj.content).width;
        objHeight = obj.fontSize * 1.2; // テキストの高さは行高を考慮
        ctx.restore();
      } else if (obj.type === 'image') {
        objWidth = obj.width;
        objHeight = obj.height;
      } else {
          return false; // 未知のタイプ
      }

      const halfObjWidth = objWidth / 2;
      const halfObjHeight = objHeight / 2;

      // 3. 変換された点が、オブジェクトのローカル境界ボックス内にあるか判定
      return scaledX >= -halfObjWidth && scaledX <= halfObjWidth &&
             scaledY >= -halfObjHeight && scaledY <= halfObjHeight;
    }

    // --- イベントリスナー ---
    /**
     * 画像ファイルの読み込み処理
     */
    imageLoader.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        uploadedImg = new Image();
        uploadedImg.onload = () => {
          // 写真オブジェクトの初期位置、スケール、回転を設定
          photoObject = {
            x: mainCanvas.width / 2, // キャンバス中央
            y: mainCanvas.height / 2, // キャンバス中央
            scale: 1,
            rotation: 0
          };

          // ====> ここに以下のコードを追加します <====
      
          // 写真がアップロードされたら背景色を白にリセット
                backgroundColor = '#ffffff'; 
                
          // ====> ここまで <====


          isPhotoLocked = false; // 写真編集を可能にする
          reEditPhotoBtn.style.display = 'none'; // 再編集ボタンは非表示
          confirmPhotoBtn.style.display = 'block'; // 確定ボタンを表示
          areaDecorations.style.display = 'none'; // デコレーションエリアを非表示
          areaResult.style.display = 'none'; // 完成イメージエリアも非表示にリセット
          drawAll(); // 全体を再描画
        };
        uploadedImg.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    /**
     * うちわテンプレートの選択変更処理
     */
    templateSelector.addEventListener('change', e => {
      // 低解像度テンプレートに切り替えて表示
      templateOverlay.src = e.target.selectedOptions[0].dataset.lowres;
    });
    
    // ====> この行の直後に追加 <====

    // 新規追加: 背景色ピッカーの変更イベント
    backgroundColorPicker.addEventListener('input', (e) => {
        backgroundColor = e.target.value; 
        // メンバーカラーピッカーの背景色を、選択された色にリアルタイムで更新
        e.target.style.backgroundColor = e.target.value; 
        uploadedImg = null; 
        photoObject = null;
        isPhotoLocked = true;
        areaDecorations.style.display = 'block'; 
        reEditPhotoBtn.style.display = 'none';
        confirmPhotoBtn.style.display = 'none';
        drawAll(); 
    });

    // ====> ここまで <====



    /**
     * 写真の配置確定ボタンの処理
     */
    confirmPhotoBtn.addEventListener('click', () => {
      if (!uploadedImg) return; // 写真がアップロードされていなければ何もしない

      // 写真をロックして「分岐」UIを出す（編集パネルは最初は閉じる）
      isPhotoLocked = true;
      confirmPhotoBtn.style.display = 'none';
      reEditPhotoBtn.style.display = 'block';
      areaDecorations.style.display = 'none'; // 編集パネルは閉じた状態で分岐表示
      document.getElementById('arrangeControls').style.display = 'flex'; // 保存/編集の入口を表示
      document.getElementById('editorWrapper').scrollIntoView({ behavior: 'smooth' });

      saveState(); // 最初のデコレーション状態を保存
    });

    /**
     * 写真の再編集ボタンの処理
     */
    reEditPhotoBtn.addEventListener('click', () => {
      isPhotoLocked = false; // 写真のロックを解除
      reEditPhotoBtn.style.display = 'none'; // 再編集ボタンを非表示
      confirmPhotoBtn.style.display = 'block'; // 確定ボタンを表示
      areaDecorations.style.display = 'none'; // デコレーションエリアを非表示
      selectedObject = null; // 選択中のデコレーションオブジェクトを解除
      areaResult.style.display = 'none'; // 完成イメージエリアも非表示にリセット
      drawAll(); // 全体を再描画
    });

    // --- ここから置き換え：決定 → プレビュー（低解像度で素早く表示 → 裏でA3生成） ---
    generateBtn.addEventListener('click', async () => {
      if (isRendering) return; // 多重クリック防止
      isRendering = true;
      generateBtn.disabled = true;

      const spinner = document.getElementById('previewSpinner');
      if (spinner) spinner.style.display = 'flex';

      try {
        // ---------- 1) 素早い「縮小プレビュー」生成（低解像度ベース） ----------
        const smallCanvas = document.createElement('canvas');
        smallCanvas.width = mainCanvas.width;   // 編集用（低解像度）の論理サイズ
        smallCanvas.height = mainCanvas.height;
        const sctx = smallCanvas.getContext('2d');

        // 背景色を塗る
        sctx.fillStyle = backgroundColor;
        sctx.fillRect(0, 0, smallCanvas.width, smallCanvas.height);

        // 写真（存在する場合）を簡易に描画（編集時と同じロジック。ただし低解像度座標）
        if (uploadedImg) {
          if (uploadedImg.decode) {
            try { await uploadedImg.decode(); } catch(e) { /* ignore */ }
          }
          // uploadedImg の実際のピクセルサイズに依存せず、編集時の見た目を再現するため
          // mainCanvas 上の scale/位置を使って描く（低解像度）
          const srcW = (uploadedImg.naturalWidth || uploadedImg.width);
          const srcH = (uploadedImg.naturalHeight || uploadedImg.height);
          const drawW = srcW * (photoObject.scale || 1);
          const drawH = srcH * (photoObject.scale || 1);

          sctx.save();
          sctx.translate(photoObject.x, photoObject.y);
          sctx.rotate(photoObject.rotation || 0);
          sctx.drawImage(uploadedImg, -drawW / 2, -drawH / 2, drawW, drawH);
          sctx.restore();
        }

        // デコレーション（テキスト・スタンプ）を低解像度で描画
        decorationObjects.forEach(obj => {
          sctx.save();
          sctx.translate(obj.x, obj.y);
          sctx.rotate(obj.rotation || 0);
          if (obj.type === 'text') {
            // 既存の関数 drawTextByStyle は obj.fontSize を期待するのでそのまま呼べる
            drawTextByStyle(sctx, obj);
          } else if (obj.type === 'image') {
            // obj.width/height は「編集時の論理サイズ」を保持しているはず
            sctx.drawImage(obj.img, -obj.width / 2, -obj.height / 2, obj.width, obj.height);
          }
          sctx.restore();
        });

        // テンプレート（高解像度ファイルをプリロードしているならそれを使う。ただしここは縮小して描く）
        let tplImg = templateCache[templateSelector.value];
        if (!tplImg) {
          tplImg = new Image();
          tplImg.src = templateSelector.value;
          if (tplImg.decode) try { await tplImg.decode(); } catch(e){/*ignore*/ }
        } else {
          if (tplImg.decode) try { await tplImg.decode(); } catch(e){/*ignore*/ }
        }
        sctx.drawImage(tplImg, 0, 0, smallCanvas.width, smallCanvas.height);

        // プレビュー用に縮小してすぐ表示（UI ロックを最小にする）
        const MAX_PREVIEW_WIDTH = 1200;
        const previewScale = Math.min(1, MAX_PREVIEW_WIDTH / smallCanvas.width);
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = Math.max(1, Math.round(smallCanvas.width * previewScale));
        previewCanvas.height = Math.max(1, Math.round(smallCanvas.height * previewScale));
        const pctx = previewCanvas.getContext('2d');
        pctx.drawImage(smallCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
        const quickDataUrl = previewCanvas.toDataURL('image/png');
        previewImage.src = quickDataUrl; // まずは縮小版を素早く表示

        // UI 表示
        areaResult.style.display = 'block';
        previewWrapper.style.display = 'block';
        goToOrderFormBtn.style.display = 'block';
        const makeBackBtn = document.getElementById('makeBackBtn');
        const orderNote = document.getElementById('orderNote');

        if (mode === 'front') {
          // 表面プレビュー時のUI（テンプレート選択を表示）
  if (makeBackBtn) makeBackBtn.style.display = 'block';
          previewNotice.innerHTML = ' 「画像を長押し👆」→ 「画像を保存」または「写真に追加」で写真アプリに保存されます。（後でフォームにアップロードします）';
          if (orderNote) orderNote.style.display = 'block';
          frontImageDataUrl = quickDataUrl; // とりあえず縮小版を一時保存

          // --- 表モードなのでテンプレート選択UIを表示に戻す ---
          const tpl = document.getElementById('templateSelector');
          const tplLabel = document.getElementById('templateLabel');
          if (tpl) tpl.style.display = 'block';
          if (tplLabel) tplLabel.textContent = 'うちわのテンプレ―トを選んでね👇';

        } else {
          // 裏面プレビュー時はテンプレート選択を非表示にして案内文を出す
          if (makeBackBtn) makeBackBtn.style.display = 'none';
          previewNotice.innerHTML = '📲 この裏面の画像も「長押し👆」して保存してください';
          if (orderNote) orderNote.style.display = 'block';

          // --- 裏モード：テンプレート選択UIを隠して案内文へ差し替える ---
          const tpl = document.getElementById('templateSelector');
          const tplLabel = document.getElementById('templateLabel');
          if (tpl) tpl.style.display = 'none';
          if (tplLabel) tplLabel.textContent = '※ 表で選んだテンプレートが裏面にも適用されます';
        }

        areaResult.scrollIntoView({ behavior: 'smooth' });

        // ---------- 2) 裏で A3 フル解像度（4961x3508）を生成してプレビュー差し替え ----------
        // 重い処理なので次のイベントループに回す（UI の応答性確保）
        setTimeout(async () => {
          try {
            const fullW = 4134; // A3 横向きの一辺（px, 250dpi）
            const fullH = 2920; // A3 縦（px, 250dpi）
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = fullW;
            fullCanvas.height = fullH;
            const fctx = fullCanvas.getContext('2d');
            fctx.imageSmoothingEnabled = true;
            fctx.imageSmoothingQuality = 'high';

            const scaleX = fullCanvas.width / mainCanvas.width;
            const scaleY = fullCanvas.height / mainCanvas.height;
            const avgScale = (scaleX + scaleY) / 2;

            // 背景色
            fctx.fillStyle = backgroundColor;
            fctx.fillRect(0, 0, fullCanvas.width, fullCanvas.height);

            // 写真（高解像度で描く）
            if (uploadedImg) {
              try { if (uploadedImg.decode) await uploadedImg.decode(); } catch(e) { /* ignore */ }
              const srcW = (uploadedImg.naturalWidth || uploadedImg.width);
              const srcH = (uploadedImg.naturalHeight || uploadedImg.height);
              const drawW = srcW * (photoObject.scale || 1) * scaleX;
              const drawH = srcH * (photoObject.scale || 1) * scaleY;

              fctx.save();
              fctx.translate((photoObject.x || 0) * scaleX, (photoObject.y || 0) * scaleY);
              fctx.rotate(photoObject.rotation || 0);
              fctx.drawImage(uploadedImg, -drawW / 2, -drawH / 2, drawW, drawH);
              fctx.restore();
            }

            // デコレーション（高解像度描画）
            for (const obj of decorationObjects) {
              fctx.save();
              fctx.translate(obj.x * scaleX, obj.y * scaleY);
              fctx.rotate(obj.rotation || 0);

              if (obj.type === 'text') {
                // drawTextByStyle は obj.fontSize に依存するため、フォントサイズをスケールした浅いコピーを渡す
                const scaledText = Object.assign({}, obj, {
                  fontSize: (obj.fontSize || 16) * (obj.scale || 1) * avgScale,
                  scale: 1 // drawTextByStyle 内で ctx.scale を期待しないようにする
                });
                drawTextByStyle(fctx, scaledText);
              } else if (obj.type === 'image') {
                try { obj.img && obj.img.decode && obj.img.decode().catch(()=>{}); } catch(e){}
                const w = (obj.width || (obj.img && (obj.img.naturalWidth || obj.img.width))) * (obj.scale || 1) * scaleX;
                const h = (obj.height || (obj.img && (obj.img.naturalHeight || obj.img.height))) * (obj.scale || 1) * scaleY;
                fctx.drawImage(obj.img, -w / 2, -h / 2, w, h);
              }

              fctx.restore();
            }

            // テンプレート（高解像度版を全面に）
            let tplImg2 = templateCache[templateSelector.value];
            if (!tplImg2) {
              tplImg2 = new Image();
              tplImg2.src = templateSelector.value;
              if (tplImg2.decode) try { await tplImg2.decode(); } catch(e){/*ignore*/ }
            } else {
              if (tplImg2.decode) try { await tplImg2.decode(); } catch(e){/*ignore*/ }
            }
            fctx.drawImage(tplImg2, 0, 0, fullCanvas.width, fullCanvas.height);

            // 生成した A3 PNG をプレビューに差し替え（ユーザーはその場で長押し保存できる）
            const fullDataUrl = fullCanvas.toDataURL('image/png');
            previewImage.src = fullDataUrl;
            if (mode === 'front') frontImageDataUrl = fullDataUrl;
          } catch (err) {
            console.warn('フル解像度生成に失敗しました', err);
            // 失敗時は縮小版のままにする（既に quickDataUrl が表示されている）
          }
        }, 50);

      } catch (e) {
        console.error('preview generate error:', e);
        alert('プレビュー生成中にエラーが発生しました。コンソールを確認してください。');
      } finally {
        if (spinner) spinner.style.display = 'none';
        isRendering = false;
        generateBtn.disabled = false;
      }
    });
    // --- ここまで置き換え ---





    // ここから追加：裏面作成モードに切り替える処理（変更：裏面は完全リセットして "1) 裏面の背景を決める" から開始）
    document.getElementById('makeBackBtn').addEventListener('click', () => {
      // 1) モード切替
      mode = 'back';

      // 2) 完全リセット（表での状態は保持したい場合は frontImageDataUrl は触らない）
      uploadedImg = null;
      photoObject = null;
      isPhotoLocked = true;      // 初期状態は写真操作をロック（写真を選択したら解除される想定）
      decorationObjects = [];    // デコを空に
      selectedObject = null;
      history = [];
      historyIndex = -1;

      // 3) 入力コントロールを初期値に戻す（安全に getElementById して存在チェック）
      const bgPicker = document.getElementById('backgroundColorPicker');
      if (bgPicker) {
        bgPicker.value = '#ffffff'; // 初期色を白に（お好みで変更可）
      }
      backgroundColor = '#ffffff';

      const tpl = document.getElementById('templateSelector');
      if (tpl) {
        tpl.selectedIndex = 0; // 最初のテンプレートに戻す
        if (typeof preloadTemplate === 'function') {
          preloadTemplate(tpl.value); // プリロード関数があれば呼ぶ（存在チェック）
        }
      }

      // ---------- 追加：裏面モードに入ったらテンプレート選択を隠す ----------
        const tplLabel = document.getElementById('templateLabel');
        // tpl は既に上で取得済み（document.getElementById('templateSelector')）
        if (tpl) tpl.style.display = 'none'; // セレクタを非表示にする
        if (tplLabel) tplLabel.textContent = '※ 表で選んだ「サイズ・型」が裏面にも適用されます';
        // ----

      // 4) UI 表示を「1) 背景を決める」エリアに合わせる
      const areaSelect = document.getElementById('area-select');
      const areaCanvas = document.getElementById('area-canvas');
      const areaDecor = document.getElementById('area-decorations');
      const areaResultEl = document.getElementById('area-result');

      if (areaResultEl) areaResultEl.style.display = 'none'; // プレビューは隠す
      if (areaDecor) areaDecor.style.display = 'none';       // デコは非表示
      if (areaSelect) areaSelect.style.display = 'block';     // 1) 背景選択を先頭に
      if (areaCanvas) areaCanvas.style.display = 'block';     // キャンバスは見せる（空の状態）

      // 写真操作系ボタンは初期非表示（写真が無ければ確定できないため）
      const confirmBtn = document.getElementById('confirmPhotoBtn');
      if (confirmBtn) confirmBtn.style.display = 'none';
      const reEditBtn = document.getElementById('reEditPhotoBtn');
      if (reEditBtn) reEditBtn.style.display = 'none';

      // 「裏面も作る」ボタンはプレビュー側にのみ出す仕様なのでここでは隠す
      const makeBackBtnEl = document.getElementById('makeBackBtn');
      if (makeBackBtnEl) makeBackBtnEl.style.display = 'none';

      // プレビュー案内リセット
      const previewNoticeEl = document.getElementById('previewNotice');
      if (previewNoticeEl) previewNoticeEl.innerHTML = '';

      // 5) 見出しを裏面向けの初期文言に変更
      const s1 = document.getElementById('section1-title');
      const s2 = document.getElementById('section2-title');
      const s3 = document.getElementById('section3-title');
      if (s1) s1.textContent = '1) 裏面の背景を決める';
      if (s2) s2.textContent = '2) 裏面をデザイン';
      if (s3) s3.textContent = '3) 裏面のデコレーション';

      // 6) 初期描画（背景色だけの空の裏面を描画）
      drawAll();

      // 7) スクロールして1番目のエリアへ
      if (areaSelect) areaSelect.scrollIntoView({ behavior: 'smooth' });
    });
    // ここまで追加

    // --- デコレーションオブジェクト追加機能 ---
    /**
     * 自由テキストをデコレーションとして追加します。
     */
    function addTextToOverlay() {
      const text = customText.value.trim();
      if (!text) return; // テキストが空なら何もしない
      const newText = {
        id: Date.now(), // 一意なID
        type: 'text',
        content: text,
        x: mainCanvas.width / 2, // キャンバス中央に配置
        y: mainCanvas.height / 2,
        scale: 1,
        rotation: 0,
        color: colorPicker.value,
        fontFamily: fontPicker.value,
        fontSize: 500, // 初期フォントサイズ

        outlineEnabled: outlineToggle.checked,
        outlineColor: outlineColorPicker.value,
        outlineWidthRatio: parseInt(outlineWidthPercent.value, 10) / 100,
        isArched: false,
        archStyle: 'rainbow',
        archAmount: 50,
      };

      decorationObjects.push(newText); // 配列に追加
      selectedObject = newText; // 追加したものを選択状態にする
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    }

    // PNGステッカー画像を事前に読み込む
    const stampImages = {};
    const pngStickers = ['01loveu.png', '02ntwithFace.png', '03eyestome.png', '04getmyheart.png',  '05angel.png', '06god.png', '07precious.png'];
    pngStickers.forEach(src => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        stampImages[src] = img; // 読み込み完了後、オブジェクトに格納
      };
    });

    /**
     * スタンプ（絵文字またはPNG画像）をデコレーションとして追加します。
     * @param {string} content - 絵文字文字列またはPNG画像ファイル名
     */
    function addStamp(content) { 
      if (content.endsWith('.png')) {
        // 画像ステッカーの場合
        const img = new Image();
        img.src = content;

        const newStamp = {
          id: Date.now(),
          type: 'image',
          src: content,
          img: img,
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
          scale: 1,
          rotation: 0,
          width: 200,  // 仮のサイズ（読み込み前）
          height: 200
        };

        img.onload = () => {
          // 本当のサイズをセット
          newStamp.width = img.naturalWidth;
          newStamp.height = img.naturalHeight;

          // 大きすぎる場合はリサイズ
          const maxDim = Math.max(newStamp.width, newStamp.height);
          const targetSize = 400; // 初期表示サイズの目標
          if (maxDim > targetSize) {
            const scaleFactor = targetSize / maxDim;
            newStamp.width *= scaleFactor;
            newStamp.height *= scaleFactor;
          }

          // 配列に追加・選択・描画
          decorationObjects.push(newStamp);
          selectedObject = newStamp;
          drawAll();
          saveState();
        };

      } else {
        // テキストや絵文字の場合
        const newStamp = {
          id: Date.now(),
          type: 'text',
          content: content,
          x: mainCanvas.width / 2,
          y: mainCanvas.height / 2,
          scale: 1,
          rotation: 0,
          color: 'black',
          fontFamily: 'sans-serif',
          fontSize: 500,
          // ▼ 追加：縁取り／アーチの初期値
          outlineEnabled: false,
          outlineColor: '#000000',
          outlineWidthRatio: 0.12,
          isArched: false,
          archStyle: 'rainbow',
          archAmount: 50
        };

        decorationObjects.push(newStamp);
        selectedObject = newStamp;
        drawAll();
        saveState();
      }
    }


    // --- デコレーションオブジェクトの編集コントロール ---
    /**
     * デコレーションオブジェクトの選択を切り替えます。
     */
    const _selectBtn = document.getElementById('selectBtn'); // ★追加①：ボタンを変数に入れる
    if (_selectBtn) {                                        // ★追加②：ボタンがある時だけ中を実行
      _selectBtn.addEventListener('click', () => {           // ← 元の行を _selectBtn に差し替えて中へ移動
        if (decorationObjects.length === 0) return;
        const currentIndex = decorationObjects.indexOf(selectedObject);
        const nextIndex = (currentIndex + 1) % decorationObjects.length;
        selectedObject = decorationObjects[nextIndex];
        drawAll();
      });
    } // ← if の閉じカッコ（新規ではないけど、②を開いたのでここで閉じます）

    document.getElementById('undoBtn').addEventListener('click', undo); // 戻るボタン
    document.getElementById('redoBtn').addEventListener('click', redo); // やり直しボタン

    /**
     * 選択中のデコレーションオブジェクトを削除します。
     */
    document.getElementById('deleteBtn').addEventListener('click', () => {
      if (!selectedObject) return;
      decorationObjects = decorationObjects.filter(obj => obj !== selectedObject); // 選択中のオブジェクトを除外
      selectedObject = null; // 選択状態を解除
      drawAll(); // 全体を再描画
      saveState(); // 状態を履歴に保存
    });

    /**
     * 選択中のデコレーションオブジェクトを複製します。
     */
    document.getElementById('duplicateBtn').addEventListener('click', () => {
      if (!selectedObject) return;
      // 選択オブジェクトを一度シリアライズしてから戻す（img は消えるが、後で src から再作成）
      const plain = JSON.parse(JSON.stringify(selectedObject));
      const newObj = Object.assign({}, plain);
      newObj.id = Date.now();
      newObj.x += 20;
      newObj.y += 20;

      if (newObj.type === 'image') {
        // 画像の場合は src から Image を作る/使う
        const img = (typeof stampImages !== 'undefined' && stampImages[newObj.src]) ? stampImages[newObj.src] : new Image();
        img.src = newObj.src;
        newObj.img = img;
      }

      decorationObjects.push(newObj);
      selectedObject = newObj;
      drawAll();
      saveState();
    });

    /**
     * 選択中のデコレーションオブジェクトを背面へ移動します。
     */
    document.getElementById('sendBackwardBtn').addEventListener('click', () => {
      const index = decorationObjects.indexOf(selectedObject);
      if (index > 0) { // 最前面でなければ
        const obj = decorationObjects.splice(index, 1)[0]; // 選択中のオブジェクトを配列から取り出す
        decorationObjects.splice(index - 1, 0, obj); // 一つ前の位置に挿入
        drawAll(); // 全体を再描画
        saveState(); // 状態を履歴に保存
      }
    });

    /**
     * 選択中のデコレーションオブジェクトを前面へ移動します。
     */
    document.getElementById('bringForwardBtn').addEventListener('click', () => {
      const index = decorationObjects.indexOf(selectedObject);
      if (index < decorationObjects.length - 1) { // 最背面でなければ
        const obj = decorationObjects.splice(index, 1)[0]; // 選択中のオブジェクトを配列から取り出す
        decorationObjects.splice(index + 1, 0, obj); // 一つ後の位置に挿入
        drawAll(); // 全体を再描画
        saveState(); // 状態を履歴に保存
      }
    });

    // --- テキストデコレーションのリアルタイム更新 ---
    customText.addEventListener('input', () => {
      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.content = customText.value; // テキスト内容を更新
        drawAll(); // 全体を再描画
      }
    });

    colorPicker.addEventListener('input', (e) => {
      // 自由テキスト用カラーピッカーの背景色を、選択された色にリアルタイムで更新
      e.target.style.backgroundColor = e.target.value;

      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.color = colorPicker.value; // 色を更新
        drawAll(); // 全体を再描画
      }
    });

    fontPicker.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.fontFamily = fontPicker.value; // フォントを更新
        drawAll(); // 全体を再描画
      }
    });

    // ← この下に追加！
    outlineColorPicker.addEventListener('input', (e) => {
      // 縁取りカラーピッカーの見た目をリアルタイムで更新
      e.target.style.backgroundColor = e.target.value;

      if (selectedObject && selectedObject.type === 'text') {
        selectedObject.outlineColor = outlineColorPicker.value;
        drawAll();
      }
    });

    function updateSelectedTextOutline(updater) {
      if (selectedObject && selectedObject.type === 'text') {
        updater(selectedObject);
        drawAll(); // 再描画（あなたのコードでは drawDecorations() かもしれません）
      }
    }

    outlineToggle.addEventListener('change', () => {
      updateSelectedTextOutline(obj => obj.outlineEnabled = outlineToggle.checked);
      saveState(); // ← 追加
    });
    outlineColorPicker.addEventListener('input', () => {
      updateSelectedTextOutline(obj => obj.outlineColor = outlineColorPicker.value);
    });
    outlineColorPicker.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        saveState();
      }
    });



    outlineWidthPercent.addEventListener('input', () => {
      outlineWidthValue.textContent = outlineWidthPercent.value + '%';
      updateSelectedTextOutline(obj => obj.outlineWidthRatio = parseInt(outlineWidthPercent.value, 10) / 100);
    });
    outlineWidthPercent.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        saveState();
      }
    });
    // --- アーチ文字のリアルタイム更新 ---
    function updateSelectedTextArch(updater) {
      if (selectedObject && selectedObject.type === 'text') {
        updater(selectedObject);
        drawAll();
      }
    }

    archToggle.addEventListener('change', () => {
      updateSelectedTextArch(obj => obj.isArched = archToggle.checked);
      saveState(); // ← 追加
    });

    archStyleRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        const checked = document.querySelector('input[name="archStyle"]:checked');
        updateSelectedTextArch(obj => obj.archStyle = checked ? checked.value : 'rainbow');
        saveState(); // ← 追加
      });
    });

    archAmount.addEventListener('input', () => {
      archAmountValue.textContent = archAmount.value;
      updateSelectedTextArch(obj => obj.archAmount = parseInt(archAmount.value, 10));
    });
    archAmount.addEventListener('change', () => {
      if (selectedObject && selectedObject.type === 'text') {
        saveState();
      }
    });


    // --- Hammer.js によるタッチ/マウスジェスチャーハンドリング ---
    const hammertime = new Hammer(mainCanvas);

    // ブラウザの慣性スクロール/ページズームを確実に無効化（CSSに加えて保険）
    mainCanvas.style.touchAction = 'none';

    const pan    = hammertime.get('pan');
    const pinch  = hammertime.get('pinch');
    const rotate = hammertime.get('rotate');

    // 1本指パンのみ許可（2本以上の指では pan を発火させない）
    pan.set({ enable: true, pointers: 1, threshold: 0 });

    // ピンチ／回転は常に有効
    pinch.set({ enable: true });
    rotate.set({ enable: true });

    // 2本指ジェスチャー（pinch/rotate）が認識されたら pan は発火しないようにする
    pinch.recognizeWith(rotate);
    pan.requireFailure([pinch, rotate]);



    // 操作対象のオブジェクトを返すヘルパー関数
    function getActiveObject() {
        if (!isPhotoLocked) {
            return photoObject; // 写真編集中は写真がターゲット
        } else if (selectedObject) {
            return selectedObject; // デコレーション編集中は選択中のデコレーションがターゲット
        }
        return null; // 何も操作対象がない場合
    }

    // タップでデコレーションを選択
    hammertime.on('tap', function(e) {
      if (isPhotoLocked) { // 写真がロックされている場合のみデコレーションを選択
        const p = getCanvasCoords(e.srcEvent.clientX, e.srcEvent.clientY); // タッチ位置をキャンバス座標に変換
        let found = false;
        // Zオーダーを考慮し、配列の最後（最も手前）から逆順に判定
        for (let i = decorationObjects.length - 1; i >= 0; i--) {
          const obj = decorationObjects[i];


          if (isPointInObject(p, obj)) {
            selectedObject = obj; // オブジェクトを選択状態にする
            drawAll(); // 全体を再描画

            // 追加：選択内容に応じて詳細パネルを自動オープン
            if (selectedObject && selectedObject.type === 'text') {
              showPanel('panel-text');
            } else if (selectedObject) {
              // 画像スタンプなどは配置・レイヤー操作中心に
              showPanel('panel-arrange');
            }

            found = true;
            break;
          }
        }
        if (!found) { // どのオブジェクトも選択されなかった場合
          selectedObject = null; // 選択状態を解除
          drawAll(); // 全体を再描画
          // 追加：未選択ならパネルを閉じる
          hidePanels();
        }
      }
    });

    // パン（移動）ジェスチャー
    hammertime.on('panstart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
        // --- 基準値を必ずリセット ---
          initialObjX = activeObj.x;
          initialObjY = activeObj.y;
          initialObjScale = activeObj.scale;
          initialObjRotation = activeObj.rotation;
          // 2本指以上なら pan は処理しない（念のための安全弁）
          if (e.pointers && e.pointers.length !== 1) return;

          // 直前の位置・拡大率・回転を基準にする
          initialObjX = activeObj.x;
          initialObjY = activeObj.y;
          initialObjScale = activeObj.scale;
          initialObjRotation = activeObj.rotation;

          // ジェスチャー開始時のタッチ中心点をキャンバス座標で記録
          const touchCenter = getCanvasCoords(e.center.x, e.center.y);
          initialTouchCenterX = touchCenter.x;
          initialTouchCenterY = touchCenter.y;
        }
    });
    hammertime.on('pan', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
        // 2本指以上なら pan は処理しない（念のための安全弁）
        if (e.pointers && e.pointers.length !== 1) return;
            // 現在のタッチ中心点をキャンバス座標で取得
            const currentTouchCenter = getCanvasCoords(e.center.x, e.center.y);
            // オブジェクトの新しい位置は、開始時の位置にタッチ中心点の移動量を加算
            activeObj.x = initialObjX + (currentTouchCenter.x - initialTouchCenterX);
            activeObj.y = initialObjY + (currentTouchCenter.y - initialTouchCenterY);
            drawAll();
        }
    });
    hammertime.on('panend', function() {
        if(isPhotoLocked) saveState(); // デコレーション移動後に履歴保存
    });

    // ピンチ（拡大縮小）ジェスチャー
    hammertime.on('pinchstart', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
        // --- ピンチ開始時に必ず基準をリセット ---
        initialObjX = activeObj.x;
        initialObjY = activeObj.y;
        initialObjScale = activeObj.scale;
        initialObjRotation = activeObj.rotation;
            // 軽タッチ（変化が小さい）なら初期値をまだ更新しない
            const scaleDelta = Math.abs(e.scale - 1);
            let scaleThreshold = 0.1;
            let rotationThreshold = 5;

            // activeObj がスタンプなら、もっと大きめのしきい値を設定
            if (activeObj && activeObj.type === 'stamp') {
                scaleThreshold = 0.15;     // 15% 未満なら軽タッチ扱い
                rotationThreshold = 8;     // 8° 未満なら軽タッチ扱い
            }

            if (scaleDelta < scaleThreshold && Math.abs(e.rotation) < rotationThreshold) {
                return; // 軽タッチ扱い
            }

            const touchCenter = getCanvasCoords(e.center.x, e.center.y);
            initialTouchCenterX = touchCenter.x;
            initialTouchCenterY = touchCenter.y;

            initialObjX = activeObj.x;
            initialObjY = activeObj.y;
            initialObjScale = activeObj.scale;
            initialObjRotation = activeObj.rotation;

            // オブジェクトの中心からタッチ中心への初期ベクトル (キャンバス座標系)
            initialVecOffsetX = initialTouchCenterX - initialObjX;
            initialVecOffsetY = initialTouchCenterY - initialObjY;
        }
    });
    
    // --- ここに追加する ---
    // スケールの範囲を制限する関数
    function clampScale(s) {
      const MIN = 0.1;   // 最小 10%
      const MAX = 10;    // 最大 10倍
      return Math.min(MAX, Math.max(MIN, s));
    }
    // --- ここまで追加 ---

    hammertime.on('pinch', function(e) {
        const activeObj = getActiveObject();
        if (activeObj) {
            // スケールだけ更新
            const newScale = clampScale(initialObjScale * e.scale);
            activeObj.scale = newScale;

            // 回転だけ更新
            activeObj.rotation = initialObjRotation + (e.rotation * Math.PI / 180);

            // 位置 (x, y) は変更しない → ズレ防止
            drawAll();
        }
    });

    hammertime.on('pinchend', function(e) {
        // 最後に計算した状態を確定させる
        initialObjX = photoObject.x;
        initialObjY = photoObject.y;
        initialObjScale = photoObject.scale;
        initialObjRotation = photoObject.rotation;

        if (isPhotoLocked) saveState();
    });


    // --- PC向けマウスイベントハンドリング ---
    let isDragging = false; // ドラッグ中かどうかのフラグ
    let lastPos = { x: 0, y: 0 }; // 前回のマウス位置 (クライアント座標)
    let dragTarget = null; // 'photo', 'decoration', 'rotate-photo', 'rotate-decoration'

    mainCanvas.addEventListener('mousedown', function(e) {
      const p = getCanvasCoords(e.clientX, e.clientY); // クリック位置をキャンバス座標に変換
      isDragging = true;
      lastPos = { x: e.clientX, y: e.clientY }; // クライアント座標を保存

      if (e.button === 0) { // 左クリック（移動）
        if (!isPhotoLocked) {
          dragTarget = 'photo';
        } else {
          selectedObject = null; // まず選択を解除
          // デコレーションを逆順で探し、一番手前のものを選択
          for (let i = decorationObjects.length - 1; i >= 0; i--) {
            const obj = decorationObjects[i];
            if (isPointInObject(p, obj)) {
              selectedObject = obj;
            // 追加：選択内容で詳細パネルを自動オープン
              if (selectedObject && selectedObject.type === 'text') {
                showPanel('panel-text');
              } else {
                showPanel('panel-arrange');
              }


              dragTarget = 'decoration';
              break;
            }
          }
          // 追加：何も選べなかった場合は閉じる
          if (!selectedObject) {
            hidePanels();
          }

        }
      } else if (e.button === 2) { // 右クリック（回転）
        if (!isPhotoLocked) {
          dragTarget = 'rotate-photo';
        } else if (selectedObject) {
          dragTarget = 'rotate-decoration';
        }
      }
      drawAll();
    });

    mainCanvas.addEventListener('mousemove', function(e) {
      if (!isDragging || !dragTarget) return;

      // 移動量をキャンバスの論理ピクセルに変換
      const dx_canvas = (e.clientX - lastPos.x) * (mainCanvas.width / mainCanvas.getBoundingClientRect().width);
      const dy_canvas = (e.clientY - lastPos.y) * (mainCanvas.height / mainCanvas.getBoundingClientRect().height);

      if (dragTarget === 'photo') {
        photoObject.x += dx_canvas;
        photoObject.y += dy_canvas;
      } else if (dragTarget === 'decoration' && selectedObject) {
        selectedObject.x += dx_canvas;
        selectedObject.y += dy_canvas;
      } else if (dragTarget === 'rotate-photo') {
        photoObject.rotation += dx_canvas * 0.0005; // マウスの横移動量に応じて回転（調整済み）
      } else if (dragTarget === 'rotate-decoration' && selectedObject) {
        selectedObject.rotation += dx_canvas * 0.0005; // マウスの横移動量に応じて回転（調整済み）
      }

      lastPos = { x: e.clientX, y: e.clientY };
      drawAll();
    });

    mainCanvas.addEventListener('mouseup', function(e) {
      isDragging = false;
      dragTarget = null;
      if(isPhotoLocked) saveState(); // デコレーション操作後に履歴保存
    });

    mainCanvas.addEventListener('mouseleave', function() {
      isDragging = false;
      dragTarget = null;
    });

    // 右クリックメニューを無効化
    mainCanvas.addEventListener('contextmenu', e => e.preventDefault());

    // 初期描画
    drawAll();
  </script>
</body>
</html>